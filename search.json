[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mastering Python Through Errors A Practical Guide",
    "section": "",
    "text": "1 Python Error Guide - Complete File Index",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Python Error Guide - Complete File Index</span>"
    ]
  },
  {
    "objectID": "index.html#package-contents",
    "href": "index.html#package-contents",
    "title": "Mastering Python Through Errors A Practical Guide",
    "section": "1.1 üì¶ Package Contents",
    "text": "1.1 üì¶ Package Contents\nThis directory contains everything you need to publish your 20-chapter Python Error Guide.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Python Error Guide - Complete File Index</span>"
    ]
  },
  {
    "objectID": "index.html#files-in-this-package",
    "href": "index.html#files-in-this-package",
    "title": "Mastering Python Through Errors A Practical Guide",
    "section": "1.2 üóÇÔ∏è Files in This Package",
    "text": "1.2 üóÇÔ∏è Files in This Package\n\n1.2.1 1. Core Documentation\n\n1.2.1.1 README.md\n\nPurpose: Main guide overview and table of contents\nUse for: Landing page, GitHub README\nSize: 5.0 KB\nContains:\n\nComplete guide introduction\nFull 20-chapter table of contents\nLearning paths\nError index\nQuick start guide\n\n\nView README.md\n\n\n\n1.2.1.2 PACKAGE_SUMMARY.md\n\nPurpose: Overview of this publishing package\nUse for: Understanding what you have and next steps\nSize: ~10 KB\nContains:\n\nWhat‚Äôs included\nStep-by-step next steps\nPublishing platform options\nLaunch plan\nSuccess tips\n\n\nView PACKAGE_SUMMARY.md\n\n\n\n\n1.2.2 2. Guide Content\n\n1.2.2.1 chapter-01-variables-data-types.md ‚úÖ\n\nStatus: COMPLETE\nPurpose: Full chapter 1 - example/template\nSize: 16 KB\nContains:\n\nVariables and data types\nCommon errors: NameError, TypeError, ValueError\nCode examples (wrong and correct)\nPractice problems with solutions\nKey takeaways\n\n\nView Chapter 1\n\n\n\n1.2.2.2 Chapters 2-20 üìù\n\nStatus: IN CONVERSATION ABOVE\nPurpose: Remaining 19 chapters\nLocation: Scroll up in the conversation\nHow to extract: See EXTRACTION_GUIDE.md\n\nChapter List: - Chapter 2: Operators and Expressions - Chapter 3: Strings and String Methods - Chapter 4: Lists and List Methods - Chapter 5: Dictionaries and Sets - Chapter 6: Tuples and Immutability - Chapter 7: Conditional Statements - Chapter 8: Loops - Chapter 9: Functions - Chapter 10: File I/O - Chapter 11: Regular Expressions - Chapter 12: Pandas Basics - Chapter 13: Pandas Advanced - Chapter 14: NumPy - Chapter 15: Matplotlib - Chapter 16: Object-Oriented Programming - Chapter 17: Modules and Imports - Chapter 18: Exception Handling - Chapter 19: Debugging Techniques - Chapter 20: Testing and Code Quality\n\nHappy Publishing! üöÄüìöüêç\nLast Updated: October 26, 2025 Package Version: 1.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Python Error Guide - Complete File Index</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html",
    "href": "chapter-01-variables-data-types.html",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "",
    "text": "2.1 Introduction\nWelcome to your journey of mastering Python errors! Before we can understand errors, we need to understand the basics: variables and data types. Most Python errors stem from misunderstanding how Python handles data.\nThink of variables as labeled boxes that store information. The type of information (number, text, list, etc.) determines what operations you can perform. Using the wrong type leads to errors - and that‚Äôs what we‚Äôll learn to avoid!",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html#understanding-variables",
    "href": "chapter-01-variables-data-types.html#understanding-variables",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "2.2 1.1 Understanding Variables",
    "text": "2.2 1.1 Understanding Variables\n\n2.2.1 What is a Variable?\n# A variable is a name that refers to a value\nname = \"Alice\"\nage = 25\nis_student = True\n\n# Variables can change (they're \"variable\")\nage = 26  # Changed the value\nKey Concepts: - Variables are created when you first assign a value - Python is dynamically typed - you don‚Äôt declare types - Variable names are case-sensitive (age ‚â† Age) - Use descriptive names (user_age not x)\n\n\n\n2.2.2 Error Type 1: NameError: name 'X' is not defined\nError Message:\n&gt;&gt;&gt; print(age)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'age' is not defined\nWhat Happened: You tried to use a variable that doesn‚Äôt exist yet.\nWhy It Happens: - Variable was never created - Typo in variable name - Variable used before assignment - Wrong scope (variable defined in function, used outside)\nCode Example - WRONG:\n# Using before defining\nprint(username)  # ERROR! username doesn't exist yet\nusername = \"Alice\"\n\n# Typo in variable name\nuser_name = \"Bob\"\nprint(user_nane)  # ERROR! Typo: 'nane' instead of 'name'\n\n# Case sensitivity\nAge = 30\nprint(age)  # ERROR! Python sees 'age' and 'Age' as different\n\n# Forgetting to assign\nresult  # ERROR! Just naming isn't enough\nresult = 10  # Need to assign a value\nCode Example - CORRECT:\n# Define before using\nusername = \"Alice\"\nprint(username)  # ‚úì Works\n\n# Check spelling carefully\nuser_name = \"Bob\"\nprint(user_name)  # ‚úì Correct spelling\n\n# Match case exactly\nage = 30\nprint(age)  # ‚úì Correct case\n\n# Always assign a value\nresult = 10\nprint(result)  # ‚úì Works\nPrevention Pattern:\n# Check if variable exists before using\ntry:\n    print(username)\nexcept NameError:\n    username = \"Default User\"\n    print(username)\n\n# Or use getattr with default for attributes\n# (We'll cover this later)",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html#basic-data-types",
    "href": "chapter-01-variables-data-types.html#basic-data-types",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "2.3 1.2 Basic Data Types",
    "text": "2.3 1.2 Basic Data Types\n\n2.3.1 Numbers: int and float\n# Integers (whole numbers)\nage = 25\nyear = 2025\ntemperature = -10\n\n# Floats (decimal numbers)\nprice = 19.99\npi = 3.14159\ntemperature = -10.5\n\n# Python automatically chooses the right type\nx = 5      # int\ny = 5.0    # float\nz = 5.     # float (same as 5.0)\n\n\n\n2.3.2 Error Type 2: TypeError: unsupported operand type(s)\nError Message:\n&gt;&gt;&gt; \"5\" + 5\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: can only concatenate str (not \"int\") to str\nWhat Happened: You tried to combine incompatible types (string + number).\nWhy It Happens: - Mixing strings and numbers in operations - Wrong type from user input (always strings) - Forgetting to convert types\nCode Example - WRONG:\n# Mixing types\nage = \"25\"\nnext_year = age + 1  # ERROR! Can't add string + int\n\n# User input is always string\nuser_input = input(\"Enter a number: \")  # Returns string\nresult = user_input + 10  # ERROR! String + int\n\n# Forgetting conversion\nprice = \"19.99\"\ntax = price * 0.1  # ERROR! Can't multiply string by float\nCode Example - CORRECT:\n# Convert string to int\nage = \"25\"\nnext_year = int(age) + 1  # ‚úì Works: 26\n\n# Convert user input\nuser_input = input(\"Enter a number: \")\nnumber = int(user_input)  # Convert to int first\nresult = number + 10  # ‚úì Works\n\n# Convert string to float\nprice = \"19.99\"\nprice_float = float(price)\ntax = price_float * 0.1  # ‚úì Works\n\n# Convert number to string (for concatenation)\nage = 25\nmessage = \"Age: \" + str(age)  # ‚úì Works\n# Or use f-strings (better):\nmessage = f\"Age: {age}\"  # ‚úì Automatic conversion\nType Conversion Functions:\n# String to number\nint(\"123\")      # 123 (integer)\nfloat(\"3.14\")   # 3.14 (float)\nint(\"3.14\")     # ERROR! Can't convert float string directly to int\nint(float(\"3.14\"))  # 3 (convert to float first, then int)\n\n# Number to string\nstr(123)        # \"123\"\nstr(3.14)       # \"3.14\"\n\n# Check type\ntype(5)         # &lt;class 'int'&gt;\ntype(5.0)       # &lt;class 'float'&gt;\ntype(\"5\")       # &lt;class 'str'&gt;\n\nisinstance(5, int)     # True\nisinstance(5.0, int)   # False\nisinstance(5.0, float) # True\n\n\n\n2.3.3 Error Type 3: ValueError: invalid literal for int()\nError Message:\n&gt;&gt;&gt; int(\"hello\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: invalid literal for int() with base 10: 'hello'\nWhat Happened: You tried to convert a string to a number, but the string doesn‚Äôt contain a valid number.\nWhy It Happens: - String contains non-numeric characters - Empty string - String with spaces (leading/trailing) - User input validation issues\nCode Example - WRONG:\n# Non-numeric string\nage = int(\"twenty-five\")  # ERROR! Not a number\n\n# Empty string\nvalue = int(\"\")  # ERROR! Empty\n\n# String with spaces\nnumber = int(\"  42  \")  # ERROR! (Actually this works, but not always safe)\n\n# Decimal string to int\nvalue = int(\"3.14\")  # ERROR! Use float first\nCode Example - CORRECT:\n# Validate before converting\ntext = \"hello\"\nif text.isdigit():\n    number = int(text)\nelse:\n    print(\"Not a valid number\")  # ‚úì Handles error\n\n# Handle conversion errors with try/except\nuser_input = \"invalid\"\ntry:\n    number = int(user_input)\nexcept ValueError:\n    print(\"Please enter a valid number\")\n    number = 0  # Default value\n\n# Strip whitespace before converting\ntext = \"  42  \"\nnumber = int(text.strip())  # ‚úì Works\n\n# Convert float string to int (two steps)\ntext = \"3.14\"\nnumber = int(float(text))  # ‚úì Works: 3\n\n# Validate with helper function\ndef safe_int(text, default=0):\n    \"\"\"Safely convert to int with default\"\"\"\n    try:\n        return int(text)\n    except ValueError:\n        return default\n\nvalue = safe_int(\"invalid\", default=0)  # ‚úì Returns 0\nvalue = safe_int(\"42\")  # ‚úì Returns 42",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html#strings",
    "href": "chapter-01-variables-data-types.html#strings",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "2.4 1.3 Strings",
    "text": "2.4 1.3 Strings\n\n2.4.1 String Basics\n# Creating strings\nname = \"Alice\"\nmessage = 'Hello, World!'\nmultiline = \"\"\"This is\na multiline\nstring\"\"\"\n\n# String operations\ngreeting = \"Hello\" + \" \" + \"World\"  # Concatenation\nrepeated = \"Ha\" * 3  # \"HaHaHa\"\nlength = len(\"Python\")  # 6\n\n\n\n2.4.2 Error Type 4: String Index Errors\nError Message:\n&gt;&gt;&gt; text = \"Hello\"\n&gt;&gt;&gt; print(text[10])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: string index out of range\nWhat Happened: You tried to access a character position that doesn‚Äôt exist.\nWhy It Happens: - Index too large (beyond string length) - Forgetting Python uses 0-based indexing - Empty string\nCode Example - WRONG:\ntext = \"Hello\"  # Length is 5, indices are 0-4\n\n# Index too large\nchar = text[5]  # ERROR! Valid indices: 0-4\n\n# Wrong assumption about length\nfirst = text[1]  # This is 'e', not 'H' (0-based!)\n\n# Empty string\nempty = \"\"\nchar = empty[0]  # ERROR! No characters\nCode Example - CORRECT:\ntext = \"Hello\"\n\n# Use valid indices (0 to len-1)\nfirst = text[0]   # ‚úì 'H' (first character)\nlast = text[4]    # ‚úì 'o' (last character)\nlast = text[-1]   # ‚úì 'o' (negative index from end)\n\n# Check length before accessing\nif len(text) &gt; 5:\n    char = text[5]\nelse:\n    print(\"Index out of range\")\n\n# Safe access with try/except\ntry:\n    char = text[10]\nexcept IndexError:\n    char = None  # Or default value\n\n# Use slicing (doesn't raise error)\nsubstring = text[10:15]  # ‚úì Returns empty string, no error\nString Indexing:\ntext = \"Python\"\n#       012345  (positive indices)\n#      -654321  (negative indices)\n\ntext[0]    # 'P'\ntext[5]    # 'n'\ntext[-1]   # 'n' (last character)\ntext[-6]   # 'P' (first character)\n\n# Slicing [start:stop:step]\ntext[0:3]   # 'Pyt' (indices 0, 1, 2)\ntext[:3]    # 'Pyt' (from start)\ntext[3:]    # 'hon' (to end)\ntext[::2]   # 'Pto' (every 2nd character)\ntext[::-1]  # 'nohtyP' (reversed)",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html#booleans",
    "href": "chapter-01-variables-data-types.html#booleans",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "2.5 1.4 Booleans",
    "text": "2.5 1.4 Booleans\n\n2.5.1 Boolean Basics\n# Boolean values\nis_valid = True\nis_empty = False\n\n# Comparison operations create booleans\nage = 25\nis_adult = age &gt;= 18  # True\nis_teen = 13 &lt;= age &lt; 20  # True\n\n# Logical operations\nx = True\ny = False\nresult = x and y  # False\nresult = x or y   # True\nresult = not x    # False\n\n\n\n2.5.2 Error Type 5: Type Confusion with Booleans\nWhat Happened: Treating non-boolean values as if they were boolean, or vice versa.\nCode Example - WRONG:\n# Confusing truthy/falsy with boolean\nvalue = \"False\"  # This is a string!\nif value:\n    print(\"This runs!\")  # String \"False\" is truthy!\n\n# Comparing boolean wrong way\nis_valid = True\nif is_valid == \"True\":  # Comparing bool to string\n    print(\"Won't work\")  # Never executes\n\n# Using assignment in condition\nx = 5\nif x = 10:  # ERROR! Assignment, not comparison\n    print(\"Won't work\")\nCode Example - CORRECT:\n# Use actual boolean values\nvalue = False  # ‚úì Boolean, not string\n\n# Compare correctly\nis_valid = True\nif is_valid:  # ‚úì Direct boolean check\n    print(\"Valid!\")\n\n# Use == for comparison\nx = 5\nif x == 10:  # ‚úì Comparison operator\n    print(\"Equal to 10\")\n\n# Understand truthy/falsy\n# Falsy: False, None, 0, \"\", [], {}, ()\n# Truthy: Everything else\n\nif \"\":  # Empty string is falsy\n    print(\"Won't print\")\n\nif \"text\":  # Non-empty string is truthy\n    print(\"Will print\")  # ‚úì\n\n# Explicit boolean conversion\ntext = \"hello\"\nbool(text)  # True (non-empty string)\nbool(\"\")    # False (empty string)\nbool(0)     # False\nbool(42)    # True",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html#none-type",
    "href": "chapter-01-variables-data-types.html#none-type",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "2.6 1.5 None Type",
    "text": "2.6 1.5 None Type\n\n2.6.1 Understanding None\n# None represents absence of value\nresult = None\nname = None\n\n# Checking for None\nif result is None:\n    print(\"No result yet\")\n\n# Don't use == for None\nif result == None:  # Works but not recommended\n    print(\"Better use 'is'\")\n\nif result is None:  # ‚úì Preferred way\n    print(\"No result\")\n\n\n\n2.6.2 Error Type 6: TypeError: 'NoneType' object is not...\nError Message:\n&gt;&gt;&gt; result = None\n&gt;&gt;&gt; result + 5\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'int'\nWhat Happened: You tried to use None as if it were another type (number, string, etc.).\nWhy It Happens: - Function returns None (implicit or explicit) - Variable not initialized properly - Forgetting to return value from function\nCode Example - WRONG:\n# Function returns None implicitly\ndef calculate():\n    result = 5 + 3\n    # Oops, forgot to return!\n\nanswer = calculate()  # Gets None\ntotal = answer + 10  # ERROR! None + 10\n\n# Using None in operations\nvalue = None\ndoubled = value * 2  # ERROR! Can't multiply None\n\n# Method that returns None\nnumbers = [3, 1, 2]\nresult = numbers.sort()  # sort() returns None!\nprint(result[0])  # ERROR! Can't index None\nCode Example - CORRECT:\n# Always return a value from functions\ndef calculate():\n    result = 5 + 3\n    return result  # ‚úì Explicit return\n\nanswer = calculate()\ntotal = answer + 10  # ‚úì Works\n\n# Check for None before using\nvalue = None\nif value is not None:\n    doubled = value * 2\nelse:\n    doubled = 0  # Default value\n\n# Some methods modify in-place and return None\nnumbers = [3, 1, 2]\nnumbers.sort()  # Modifies list, returns None\nprint(numbers[0])  # ‚úì Use the modified list: 1\n\n# Or use function that returns new value\nnumbers = [3, 1, 2]\nsorted_numbers = sorted(numbers)  # Returns new sorted list\nprint(sorted_numbers[0])  # ‚úì Works: 1\n\n# Provide default value\ndef get_value():\n    return None\n\nresult = get_value() or 0  # Use 0 if None\nresult = get_value() if get_value() is not None else 0  # More explicit",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html#practice-problems---fix-these-errors",
    "href": "chapter-01-variables-data-types.html#practice-problems---fix-these-errors",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "2.7 1.6 Practice Problems - Fix These Errors!",
    "text": "2.7 1.6 Practice Problems - Fix These Errors!\n\n2.7.1 Problem 1: NameError\nprint(user_name)\nuser_name = \"Alice\"\nWhat‚Äôs wrong?\n\n\nClick for Answer\n\nError: NameError: name 'user_name' is not defined\nWhy: Variable is used before it‚Äôs defined.\nFix:\nuser_name = \"Alice\"  # Define first\nprint(user_name)     # Then use ‚úì\n\n\n\n\n2.7.2 Problem 2: TypeError\nage = \"25\"\nnext_year = age + 1\nprint(next_year)\nWhat‚Äôs wrong?\n\n\nClick for Answer\n\nError: TypeError: can only concatenate str (not \"int\") to str\nWhy: Can‚Äôt add string and integer.\nFix:\nage = \"25\"\nnext_year = int(age) + 1  # Convert to int first ‚úì\nprint(next_year)  # 26\n\n\n\n\n2.7.3 Problem 3: ValueError\nuser_input = \"twenty-five\"\nage = int(user_input)\nWhat‚Äôs wrong?\n\n\nClick for Answer\n\nError: ValueError: invalid literal for int() with base 10: 'twenty-five'\nWhy: String doesn‚Äôt contain a valid number.\nFix:\nuser_input = \"twenty-five\"\ntry:\n    age = int(user_input)\nexcept ValueError:\n    print(\"Please enter a numeric value\")\n    age = 0  # Default value ‚úì\n\n\n\n\n2.7.4 Problem 4: IndexError\ntext = \"Hi\"\nprint(text[5])\nWhat‚Äôs wrong?\n\n\nClick for Answer\n\nError: IndexError: string index out of range\nWhy: Index 5 doesn‚Äôt exist (string has indices 0 and 1 only).\nFix:\ntext = \"Hi\"\nif len(text) &gt; 5:\n    print(text[5])\nelse:\n    print(\"Index out of range\")  # ‚úì\n\n# Or use negative indexing\nprint(text[-1])  # Last character: 'i' ‚úì\n\n\n\n\n2.7.5 Problem 5: NoneType Error\ndef get_discount():\n    discount = 0.1\n    # Missing return statement\n\nprice = 100\nfinal_price = price - get_discount()\nWhat‚Äôs wrong?\n\n\nClick for Answer\n\nError: TypeError: unsupported operand type(s) for -: 'int' and 'NoneType'\nWhy: Function doesn‚Äôt return a value (returns None implicitly).\nFix:\ndef get_discount():\n    discount = 0.1\n    return discount  # ‚úì Add return statement\n\nprice = 100\nfinal_price = price - get_discount()  # ‚úì Works now",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html#key-takeaways",
    "href": "chapter-01-variables-data-types.html#key-takeaways",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "2.8 1.7 Key Takeaways",
    "text": "2.8 1.7 Key Takeaways\n\n2.8.1 What You Learned\n\nDefine variables before using them - Avoid NameError\nMatch types in operations - Convert when needed\nValidate before converting - Use try/except for conversions\nCheck string length before indexing - Avoid IndexError\nAlways return values from functions - Avoid NoneType errors\nUse appropriate comparison - is for None, == for values\n\n\n\n2.8.2 Common Patterns\n# Pattern 1: Safe type conversion\ntry:\n    number = int(user_input)\nexcept ValueError:\n    number = 0  # Default value\n\n# Pattern 2: Safe string indexing\nif len(text) &gt; index:\n    char = text[index]\n\n# Pattern 3: Check for None\nif value is not None:\n    # Use value\n\n# Pattern 4: Provide defaults\nresult = function() or default_value\n\n\n2.8.3 Error Summary Table\n\n\n\n\n\n\n\n\nError Type\nCommon Cause\nPrevention\n\n\n\n\nNameError\nUsing undefined variable\nDefine before use\n\n\nTypeError\nMixing incompatible types\nConvert types explicitly\n\n\nValueError\nInvalid conversion\nValidate before converting\n\n\nIndexError\nInvalid string index\nCheck length first\n\n\nNoneType errors\nUsing None in operations\nCheck for None, return values",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-01-variables-data-types.html#moving-forward",
    "href": "chapter-01-variables-data-types.html#moving-forward",
    "title": "2¬† Chapter 1: Variables and Data Types - The Foundation of Python Errors",
    "section": "2.9 1.8 Moving Forward",
    "text": "2.9 1.8 Moving Forward\nYou now understand the basics of variables and data types, and how to avoid common errors. In Chapter 2, we‚Äôll explore Operators and Expressions and learn about more error types!",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Chapter 1: Variables and Data Types - The Foundation of Python Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html",
    "href": "chapter-02-operators-expressions.html",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "",
    "text": "3.1 Introduction\nYou‚Äôve mastered variables and types. Now let‚Äôs explore operators - the symbols that let you perform operations on data (+, -, *, /, ==, etc.). Understanding operators prevents calculation errors and logic bugs.\nOperators in Python: - Arithmetic operators: +, -, *, /, //, %,  - Comparison operators: ==, !=, &lt;, &gt;, &lt;=, &gt;= - Logical operators: and, or, not - Assignment operators**: =, +=, -=, *=, etc.\nLet‚Äôs master operators by understanding their errors!",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html#arithmetic-operators",
    "href": "chapter-02-operators-expressions.html#arithmetic-operators",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "3.2 2.1 Arithmetic Operators",
    "text": "3.2 2.1 Arithmetic Operators\n\n3.2.1 Basic Math Operations\n# Addition\nresult = 5 + 3  # 8\n\n# Subtraction\nresult = 10 - 4  # 6\n\n# Multiplication\nresult = 3 * 4  # 12\n\n# Division\nresult = 10 / 3  # 3.333... (always returns float)\n\n# Floor division (rounds down)\nresult = 10 // 3  # 3 (integer division)\n\n# Modulo (remainder)\nresult = 10 % 3  # 1\n\n# Exponentiation\nresult = 2 ** 3  # 8 (2 to the power of 3)\n\n\n\n3.2.2 Error Type 1: ZeroDivisionError: division by zero\nError Message:\n&gt;&gt;&gt; result = 10 / 0\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nZeroDivisionError: division by zero\nWhat Happened: You tried to divide by zero, which is mathematically undefined.\nWhy It Happens: - Literal zero in denominator - Variable that becomes zero - User input that‚Äôs zero - Calculation result that‚Äôs zero\nCode Example - WRONG:\n# Direct division by zero\nresult = 10 / 0  # ERROR!\n\n# Variable is zero\ndenominator = 0\nresult = 100 / denominator  # ERROR!\n\n# User input\nnumber = int(input(\"Enter divisor: \"))  # User enters 0\nresult = 50 / number  # ERROR!\n\n# Calculation results in zero\nx = 5\ny = 5\nresult = 10 / (x - y)  # ERROR! (5 - 5 = 0)\n\n# Modulo by zero\nremainder = 10 % 0  # ERROR! Also causes ZeroDivisionError\nCode Example - CORRECT:\n# Check before dividing\ndenominator = 0\nif denominator != 0:\n    result = 100 / denominator\nelse:\n    result = 0  # Or handle appropriately\n    print(\"Cannot divide by zero\")\n\n# Using try/except\ntry:\n    result = 10 / denominator\nexcept ZeroDivisionError:\n    print(\"Error: Division by zero\")\n    result = None\n\n# Function with validation\ndef safe_divide(numerator, denominator):\n    \"\"\"Safely divide two numbers\"\"\"\n    if denominator == 0:\n        return None  # Or raise custom error\n    return numerator / denominator\n\nresult = safe_divide(10, 0)  # Returns None\nresult = safe_divide(10, 2)  # Returns 5.0\n\n# Using a default value\ndef divide_with_default(a, b, default=0):\n    \"\"\"Divide with default value if b is zero\"\"\"\n    try:\n        return a / b\n    except ZeroDivisionError:\n        return default\n\nresult = divide_with_default(10, 0, default=0)  # 0\nresult = divide_with_default(10, 2)  # 5.0\n\n# For modulo\ndef safe_modulo(a, b):\n    \"\"\"Safe modulo operation\"\"\"\n    if b == 0:\n        return None\n    return a % b\nPrevention Pattern:\n# Always validate divisor\ndef calculate_average(total, count):\n    if count == 0:\n        return 0  # Or appropriate default\n    return total / count\n\n# Check in mathematical expressions\nx = 10\ny = 5\ndenominator = (x - y)\nif denominator != 0:\n    result = 100 / denominator\n\n\n\n3.2.3 Error Type 2: TypeError: unsupported operand type(s) for X\nError Message:\n&gt;&gt;&gt; result = \"5\" + 5\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'str' and 'int'\nWhat Happened: You tried to perform an arithmetic operation on incompatible types.\nWhy It Happens: - Mixing strings and numbers - Using operators on wrong types - Forgetting type conversions\nCode Example - WRONG:\n# String + number\nresult = \"5\" + 5  # ERROR!\n\n# String * string\nresult = \"hello\" * \"world\"  # ERROR!\n\n# List + number\nresult = [1, 2, 3] + 5  # ERROR!\n\n# Division with strings\nresult = \"10\" / \"2\"  # ERROR!\n\n# Subtraction with strings\nresult = \"10\" - 5  # ERROR!\nCode Example - CORRECT:\n# Convert string to number\nresult = int(\"5\") + 5  # ‚úì 10\nresult = float(\"5.5\") + 5  # ‚úì 10.5\n\n# Or convert number to string\nresult = \"5\" + str(5)  # ‚úì \"55\"\n\n# String repetition (works!)\nresult = \"hello\" * 3  # ‚úì \"hellohellohello\"\n\n# List repetition (works!)\nresult = [1, 2] * 3  # ‚úì [1, 2, 1, 2, 1, 2]\n\n# List concatenation\nresult = [1, 2, 3] + [4, 5]  # ‚úì [1, 2, 3, 4, 5]\n\n# Proper string operations\nresult = int(\"10\") / int(\"2\")  # ‚úì 5.0\n\n# Type checking before operation\nvalue = \"5\"\nif isinstance(value, str):\n    value = int(value)\nresult = value + 5  # ‚úì 10\nUnderstanding Operator Compatibility:\n# What works with each operator:\n\n# + (Addition/Concatenation)\n5 + 3  # ‚úì Numbers\n\"a\" + \"b\"  # ‚úì Strings\n[1] + [2]  # ‚úì Lists\n# \"5\" + 5  # ‚úó String + Number\n\n# * (Multiplication/Repetition)\n5 * 3  # ‚úì Numbers\n\"a\" * 3  # ‚úì String repetition\n[1] * 3  # ‚úì List repetition\n# \"a\" * \"b\"  # ‚úó String * String\n\n# - (Subtraction)\n5 - 3  # ‚úì Numbers only\n# \"5\" - \"3\"  # ‚úó Not for strings\n\n# / (Division)\n10 / 2  # ‚úì Numbers only\n# \"10\" / \"2\"  # ‚úó Not for strings",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html#comparison-operators",
    "href": "chapter-02-operators-expressions.html#comparison-operators",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "3.3 2.2 Comparison Operators",
    "text": "3.3 2.2 Comparison Operators\n\n3.3.1 Understanding Comparisons\n# Equality\n5 == 5  # True\n\"hello\" == \"hello\"  # True\n\n# Inequality\n5 != 3  # True\n\n# Greater than / Less than\n10 &gt; 5  # True\n3 &lt; 7  # True\n\n# Greater than or equal / Less than or equal\n5 &gt;= 5  # True\n3 &lt;= 3  # True\n\n# Chaining comparisons\n1 &lt; 5 &lt; 10  # True (same as: 1 &lt; 5 and 5 &lt; 10)\n\n\n\n3.3.2 Error Type 3: Wrong Comparison Operator\nWhat Happened: Using = instead of ==, or other comparison mistakes.\nCode Example - WRONG:\n# Using = instead of ==\nif x = 5:  # ERROR! SyntaxError\n    print(\"Five\")\n\n# Comparing with wrong type\nif \"5\" == 5:  # False (no error, but wrong logic)\n    print(\"Equal\")  # Doesn't print\n\n# Using is for value comparison\nx = 1000\ny = 1000\nif x is y:  # False (checks identity, not value)\n    print(\"Same\")  # Doesn't print\n\n# Wrong negation\nif not x == 5:  # Works but verbose\n    print(\"Not five\")\nCode Example - CORRECT:\n# Use == for comparison\nx = 5\nif x == 5:  # ‚úì Correct\n    print(\"Five\")\n\n# Convert types before comparing\nif int(\"5\") == 5:  # ‚úì True\n    print(\"Equal\")\n\n# Use == for value comparison\nx = 1000\ny = 1000\nif x == y:  # ‚úì True\n    print(\"Same\")\n\n# Use is only for None, True, False\nvalue = None\nif value is None:  # ‚úì Correct\n    print(\"No value\")\n\n# Use != for not equal\nif x != 5:  # ‚úì Better than: not x == 5\n    print(\"Not five\")\n\n# String comparison (case-sensitive)\nname = \"Alice\"\nif name == \"Alice\":  # ‚úì True\n    print(\"Hello Alice\")\n\nif name.lower() == \"alice\":  # ‚úì Case-insensitive\n    print(\"Hello Alice\")\nComparison Best Practices:\n# For numbers: use ==, !=, &lt;, &gt;, &lt;=, &gt;=\nage = 25\nif age &gt;= 18:  # ‚úì\n    print(\"Adult\")\n\n# For None: use is/is not\nvalue = None\nif value is None:  # ‚úì Preferred\n    print(\"No value\")\n\n# For strings: use ==, consider case\nname = \"Alice\"\nif name == \"Alice\":  # ‚úì Case-sensitive\n    print(\"Match\")\n\nif name.lower() == \"alice\":  # ‚úì Case-insensitive\n    print(\"Match\")\n\n# For booleans: use == or direct\nis_valid = True\nif is_valid:  # ‚úì Direct\n    print(\"Valid\")\n\nif is_valid == True:  # ‚úì Works but verbose\n    print(\"Valid\")\n\n# For collections: use == for value, is for identity\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]\nif list1 == list2:  # ‚úì True (same values)\n    print(\"Same values\")\n\nif list1 is list2:  # False (different objects)\n    print(\"Same object\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html#logical-operators",
    "href": "chapter-02-operators-expressions.html#logical-operators",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "3.4 2.3 Logical Operators",
    "text": "3.4 2.3 Logical Operators\n\n3.4.1 Understanding and, or, not\n# and - Both must be True\nTrue and True  # True\nTrue and False  # False\nFalse and False  # False\n\n# or - At least one must be True\nTrue or False  # True\nFalse or False  # False\nTrue or True  # True\n\n# not - Reverses the boolean\nnot True  # False\nnot False  # True\n\n# Combining operators\nx = 10\nif x &gt; 5 and x &lt; 15:  # True\n    print(\"Between 5 and 15\")\n\n# Short-circuit evaluation\nif x &gt; 5 and expensive_function():  # expensive_function only called if x &gt; 5\n    print(\"Both conditions true\")\n\n\n\n3.4.2 Error Type 4: Logical Operator Mistakes\nCode Example - WRONG:\n# Using bitwise operators instead of logical\nif True & False:  # Using & instead of 'and'\n    print(\"Wrong operator\")\n\n# Wrong order of operations\nif not x == 5:  # Confusing - applies 'not' first\n    print(\"Not five\")\n\n# Chaining with wrong logic\nage = 25\nif age &gt; 18 and &lt; 65:  # ERROR! SyntaxError\n    print(\"Working age\")\n\n# Missing parentheses\nif x &gt; 5 and y &gt; 3 or z &gt; 10:  # Ambiguous\n    print(\"Condition met\")\n\n# Comparing with boolean literals unnecessarily\nif is_valid == True:  # Verbose\n    print(\"Valid\")\nCode Example - CORRECT:\n# Use logical operators correctly\nif True and False:  # ‚úì Logical AND\n    print(\"Both true\")\n\n# Clear negation\nif x != 5:  # ‚úì Better than: not x == 5\n    print(\"Not five\")\n\n# Proper chaining\nage = 25\nif age &gt; 18 and age &lt; 65:  # ‚úì Correct\n    print(\"Working age\")\n\n# Or use chaining\nif 18 &lt; age &lt; 65:  # ‚úì More Pythonic\n    print(\"Working age\")\n\n# Use parentheses for clarity\nif (x &gt; 5 and y &gt; 3) or z &gt; 10:  # ‚úì Clear intent\n    print(\"Condition met\")\n\n# Direct boolean check\nif is_valid:  # ‚úì Simple and clear\n    print(\"Valid\")\n\n# Combining conditions clearly\nusername = \"admin\"\npassword = \"secret\"\nif username == \"admin\" and password == \"secret\":  # ‚úì\n    print(\"Login successful\")\n\n# Short-circuit evaluation\nif user is not None and user.is_active():  # ‚úì Safe\n    print(\"Active user\")\nLogical Operator Truth Tables:\n# AND truth table\nTrue and True    # True\nTrue and False   # False\nFalse and True   # False\nFalse and False  # False\n\n# OR truth table\nTrue or True     # True\nTrue or False    # True\nFalse or True    # True\nFalse or False   # False\n\n# NOT truth table\nnot True         # False\nnot False        # True\n\n# Combining operators\nnot (True and False)  # True\nTrue and not False    # True\nFalse or not False    # True",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html#assignment-operators",
    "href": "chapter-02-operators-expressions.html#assignment-operators",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "3.5 2.4 Assignment Operators",
    "text": "3.5 2.4 Assignment Operators\n\n3.5.1 Compound Assignment\n# Basic assignment\nx = 5\n\n# Addition assignment\nx += 3  # Same as: x = x + 3\n# x is now 8\n\n# Subtraction assignment\nx -= 2  # Same as: x = x - 2\n# x is now 6\n\n# Multiplication assignment\nx *= 2  # Same as: x = x * 2\n# x is now 12\n\n# Division assignment\nx /= 3  # Same as: x = x / 3\n# x is now 4.0\n\n# Floor division assignment\nx //= 2  # Same as: x = x // 2\n# x is now 2.0\n\n# Modulo assignment\nx %= 2  # Same as: x = x % 2\n# x is now 0.0\n\n# Exponentiation assignment\nx = 2\nx **= 3  # Same as: x = x ** 3\n# x is now 8\n\n\n\n3.5.2 Error Type 5: Assignment Mistakes\nCode Example - WRONG:\n# Multiple assignment with different types\nx = y = \"5\"\nx += 5  # ERROR! TypeError: can only concatenate str (not \"int\") to str\n\n# Undefined variable in compound assignment\ntotal += 10  # ERROR! NameError if total not defined\n\n# Wrong operator order\n5 = x  # ERROR! SyntaxError: can't assign to literal\n\n# Modifying immutable\nx = 5\nx[0] = 3  # ERROR! TypeError: 'int' object does not support item assignment\nCode Example - CORRECT:\n# Initialize before compound assignment\ntotal = 0  # ‚úì Initialize first\ntotal += 10  # ‚úì Now works: total is 10\n\n# Type-consistent operations\nx = 5  # Integer\nx += 3  # ‚úì Still integer: 8\n\ny = \"5\"  # String\ny += \"3\"  # ‚úì String concatenation: \"53\"\n\n# Correct assignment order\nx = 5  # ‚úì Variable on left, value on right\n\n# Multiple assignment with same type\nx = y = z = 0  # ‚úì All set to 0\nx += 5  # ‚úì x is now 5\n\n# Counter pattern\ncount = 0\ncount += 1  # Increment\ncount -= 1  # Decrement\n\n# Accumulator pattern\ntotal = 0\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    total += num  # Accumulate sum\n# total is 15\n\n# String building (though join is better for large strings)\nmessage = \"\"\nmessage += \"Hello\"\nmessage += \" \"\nmessage += \"World\"\n# message is \"Hello World\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html#operator-precedence",
    "href": "chapter-02-operators-expressions.html#operator-precedence",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "3.6 2.5 Operator Precedence",
    "text": "3.6 2.5 Operator Precedence\n\n3.6.1 Order of Operations\n# Python operator precedence (high to low):\n# 1. ** (exponentiation)\n# 2. *, /, //, % (multiplication, division, floor division, modulo)\n# 3. +, - (addition, subtraction)\n# 4. ==, !=, &lt;, &gt;, &lt;=, &gt;= (comparisons)\n# 5. not\n# 6. and\n# 7. or\n\n# Examples\nresult = 2 + 3 * 4  # 14 (not 20) - multiplication first\nresult = (2 + 3) * 4  # 20 - parentheses override\n\nresult = 10 - 3 - 2  # 5 (left to right: 10-3=7, 7-2=5)\nresult = 2 ** 3 ** 2  # 512 (right to left: 3**2=9, 2**9=512)\n\n# Comparison chaining\n1 &lt; 2 &lt; 3  # True (same as: 1 &lt; 2 and 2 &lt; 3)\n\n# Logical operators\nTrue or False and False  # True (and before or)\n(True or False) and False  # False (parentheses first)\n\n\n\n3.6.2 Error Type 6: Precedence Confusion\nCode Example - WRONG:\n# Expecting left-to-right for all operators\nresult = 2 ** 3 ** 2  # 512, not 64 (exponentiation is right-to-left)\n\n# Forgetting multiplication before addition\nresult = 2 + 3 * 4  # 14, not 20\n\n# Logical operator precedence\nif x &gt; 5 or y &gt; 3 and z &gt; 10:  # 'and' has higher precedence\n    # This is: x &gt; 5 or (y &gt; 3 and z &gt; 10)\n    # Not: (x &gt; 5 or y &gt; 3) and z &gt; 10\n    print(\"Condition met\")\n\n# Comparison with calculations\nif 5 + 5 == 10:  # Works, but can be confusing\n    print(\"Equal\")\nCode Example - CORRECT:\n# Use parentheses for clarity\nresult = 2 ** (3 ** 2)  # ‚úì 512 (explicit right-to-left)\nresult = (2 ** 3) ** 2  # ‚úì 64 (left-to-right)\n\nresult = (2 + 3) * 4  # ‚úì 20 (addition first)\n\n# Clear logical expressions\nif (x &gt; 5) or (y &gt; 3 and z &gt; 10):  # ‚úì Explicit grouping\n    print(\"Condition met\")\n\n# Separate calculation and comparison\nsum_value = 5 + 5\nif sum_value == 10:  # ‚úì More readable\n    print(\"Equal\")\n\n# Complex expressions with clear grouping\nresult = ((10 + 5) * 2) / (3 + 2)  # ‚úì Very clear\n# = (15 * 2) / 5\n# = 30 / 5\n# = 6.0\n\n# Mathematical formula with proper precedence\n# Formula: (a + b) / (c - d)\na, b, c, d = 10, 5, 8, 3\nresult = (a + b) / (c - d)  # ‚úì Clear grouping\nBest Practice:\n# When in doubt, use parentheses!\n# Better to be explicit than to rely on precedence rules\n\n# Unclear\nresult = 2 + 3 * 4 - 5 / 2\n\n# Clear\nresult = 2 + (3 * 4) - (5 / 2)",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html#practice-problems---fix-these-errors",
    "href": "chapter-02-operators-expressions.html#practice-problems---fix-these-errors",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "3.7 2.6 Practice Problems - Fix These Errors!",
    "text": "3.7 2.6 Practice Problems - Fix These Errors!\n\n3.7.1 Problem 1: Division by Zero\nx = 10\ny = 0\nresult = x / y\n\n\nClick for Answer\n\nError: ZeroDivisionError: division by zero\nWhy: Dividing by zero\nFix:\nx = 10\ny = 0\n\n# Check before dividing\nif y != 0:\n    result = x / y\nelse:\n    result = 0  # Or None, or handle error\n    print(\"Cannot divide by zero\")\n\n# Or use try/except\ntry:\n    result = x / y\nexcept ZeroDivisionError:\n    result = 0\n    print(\"Cannot divide by zero\")\n\n\n\n\n3.7.2 Problem 2: Type Mismatch\nage = \"25\"\nnext_year = age + 1\n\n\nClick for Answer\n\nError: TypeError: can only concatenate str (not \"int\") to str\nWhy: Can‚Äôt add string and integer\nFix:\nage = \"25\"\nnext_year = int(age) + 1  # ‚úì Convert to int first\nprint(next_year)  # 26\n\n\n\n\n3.7.3 Problem 3: Wrong Comparison\nx = 5\nif x = 5:\n    print(\"Five\")\n\n\nClick for Answer\n\nError: SyntaxError: invalid syntax\nWhy: Using = (assignment) instead of == (comparison)\nFix:\nx = 5\nif x == 5:  # ‚úì Use == for comparison\n    print(\"Five\")\n\n\n\n\n3.7.4 Problem 4: Operator Precedence\nresult = 10 - 5 - 3\nprint(result)  # What does this print?\n\n\nClick for Answer\n\nAnswer: 2\nExplanation: Subtraction is left-to-right - 10 - 5 = 5 - 5 - 3 = 2\nNot: 10 - (5 - 3) = 10 - 2 = 8\nTo get 8:\nresult = 10 - (5 - 3)  # ‚úì Use parentheses\n\n\n\n\n3.7.5 Problem 5: Logical Operators\nage = 25\nif age &gt; 18 and &lt; 65:\n    print(\"Working age\")\n\n\nClick for Answer\n\nError: SyntaxError: invalid syntax\nWhy: Missing variable in second comparison\nFix:\nage = 25\n\n# Option 1: Repeat variable\nif age &gt; 18 and age &lt; 65:  # ‚úì\n    print(\"Working age\")\n\n# Option 2: Chaining (more Pythonic)\nif 18 &lt; age &lt; 65:  # ‚úì\n    print(\"Working age\")\n\n\n\n\n3.7.6 Problem 6: String Multiplication\nresult = \"hello\" * \"3\"\n\n\nClick for Answer\n\nError: TypeError: can't multiply sequence by non-int of type 'str'\nWhy: Can‚Äôt multiply string by string\nFix:\nresult = \"hello\" * 3  # ‚úì Multiply by integer\nprint(result)  # \"hellohellohello\"\n\n# If \"3\" is user input:\ncount = \"3\"\nresult = \"hello\" * int(count)  # ‚úì Convert to int first",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html#key-takeaways",
    "href": "chapter-02-operators-expressions.html#key-takeaways",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "3.8 2.7 Key Takeaways",
    "text": "3.8 2.7 Key Takeaways\n\n3.8.1 What You Learned\n\nCheck for zero before division - Prevent ZeroDivisionError\nMatch types in operations - Convert when needed\nUse == for comparison - Not = (assignment)\nUnderstand operator precedence - Use parentheses when unclear\nUse logical operators correctly - and, or, not\nInitialize before compound assignment - total += 1 needs total to exist\nUse is for None/True/False - Use == for other values\n\n\n\n3.8.2 Common Patterns\n# Pattern 1: Safe division\nif denominator != 0:\n    result = numerator / denominator\n\n# Pattern 2: Type conversion\nvalue = int(string_value) + 5\n\n# Pattern 3: Range checking\nif 0 &lt;= value &lt;= 100:\n    # Value in range\n\n# Pattern 4: Null checking with logic\nif user is not None and user.is_active():\n    # Safe to call method\n\n# Pattern 5: Counter\ncount = 0\ncount += 1\n\n\n3.8.3 Error Summary Table\n\n\n\n\n\n\n\n\nError Type\nCommon Cause\nPrevention\n\n\n\n\nZeroDivisionError\nDividing by zero\nCheck denominator != 0\n\n\nTypeError in operations\nMixing incompatible types\nConvert types first\n\n\nSyntaxError in if\nUsing = instead of ==\nUse == for comparison\n\n\nWrong results\nOperator precedence\nUse parentheses",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-02-operators-expressions.html#moving-forward",
    "href": "chapter-02-operators-expressions.html#moving-forward",
    "title": "3¬† Chapter 2: Operators and Expressions - Mathematical and Logical Errors",
    "section": "3.9 2.8 Moving Forward",
    "text": "3.9 2.8 Moving Forward\nYou now understand operators and expressions. You can: - Perform arithmetic safely - Compare values correctly - Use logical operators effectively - Avoid common operator errors\nIn Chapter 3, we‚Äôll explore Strings and String Methods - working with text and avoiding string errors!",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Chapter 2: Operators and Expressions - Mathematical and Logical Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html",
    "href": "chapter-03-strings-methods.html",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "",
    "text": "4.1 Introduction\nYou‚Äôve mastered variables and operators. Now let‚Äôs explore strings - one of the most commonly used data types in Python. Strings represent text, and Python provides powerful methods to manipulate them.\nString-related errors are extremely common: - IndexError: Accessing invalid string positions - AttributeError: Using wrong methods or typos - ValueError: Invalid operations on strings - TypeError: Wrong types in string operations\nLet‚Äôs master strings by understanding their errors!",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#string-basics",
    "href": "chapter-03-strings-methods.html#string-basics",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.2 3.1 String Basics",
    "text": "4.2 3.1 String Basics\n\n4.2.1 Creating and Using Strings\n# Creating strings\nname = \"Alice\"\nmessage = 'Hello, World!'\nmultiline = \"\"\"This is\na multiline\nstring\"\"\"\n\n# String concatenation\ngreeting = \"Hello\" + \" \" + \"World\"  # \"Hello World\"\n\n# String repetition\nrepeated = \"Ha\" * 3  # \"HaHaHa\"\n\n# String length\nlength = len(\"Python\")  # 6\n\n# Accessing characters (0-indexed)\ntext = \"Python\"\nfirst = text[0]   # 'P'\nlast = text[-1]   # 'n'\n\n\n\n4.2.2 Error Type 1: IndexError: string index out of range\nError Message:\n&gt;&gt;&gt; text = \"Hello\"\n&gt;&gt;&gt; char = text[10]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: string index out of range\nWhat Happened: You tried to access a character at an index that doesn‚Äôt exist in the string.\nWhy It Happens: - Index beyond string length - Empty string - Off-by-one errors (forgetting 0-based indexing) - Negative index too large\nCode Example - WRONG:\ntext = \"Hello\"  # Length 5, indices 0-4\n\n# Index too large\nchar = text[5]  # ERROR! Valid indices: 0-4\n\n# Much too large\nchar = text[100]  # ERROR!\n\n# Empty string\nempty = \"\"\nchar = empty[0]  # ERROR! No characters\n\n# Wrong assumption\nfirst = text[1]  # Gets 'e', not 'H' (0-based indexing!)\n\n# Negative index too large\nchar = text[-10]  # ERROR! Only goes back to -5\nCode Example - CORRECT:\ntext = \"Hello\"\n\n# Use valid indices\nfirst = text[0]   # ‚úì 'H' (first character)\nlast = text[4]    # ‚úì 'o' (last character)\nlast = text[-1]   # ‚úì 'o' (last character, better way)\n\n# Check length before accessing\nindex = 10\nif index &lt; len(text):\n    char = text[index]\nelse:\n    print(f\"Index {index} out of range\")\n\n# Safe access with try/except\ntry:\n    char = text[10]\nexcept IndexError:\n    char = None  # Or default value\n    print(\"Index out of range\")\n\n# Use slicing (doesn't raise error)\nsubstring = text[10:15]  # ‚úì Returns empty string, no error\n\n# Get last character safely\nif text:  # Check if not empty\n    last = text[-1]\nelse:\n    last = None\n\n# Iterate safely with indices\nfor i in range(len(text)):\n    char = text[i]  # ‚úì Always valid\n    print(char)\n\n# Or iterate directly (better)\nfor char in text:  # ‚úì No indexing needed\n    print(char)\nString Indexing Reference:\ntext = \"Python\"\n#       012345  (positive indices)\n#      -654321  (negative indices)\n\ntext[0]    # 'P' (first)\ntext[5]    # 'n' (last)\ntext[-1]   # 'n' (last, using negative)\ntext[-6]   # 'P' (first, using negative)\n\n# Valid range: 0 to len(text)-1\n# Or: -len(text) to -1",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#string-slicing",
    "href": "chapter-03-strings-methods.html#string-slicing",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.3 3.2 String Slicing",
    "text": "4.3 3.2 String Slicing\n\n4.3.1 Understanding Slicing\ntext = \"Python\"\n\n# Basic slicing [start:stop]\ntext[0:3]   # 'Pyt' (indices 0, 1, 2)\ntext[2:5]   # 'tho' (indices 2, 3, 4)\n\n# Omitting start or stop\ntext[:3]    # 'Pyt' (from beginning)\ntext[3:]    # 'hon' (to end)\ntext[:]     # 'Python' (entire string)\n\n# Step parameter [start:stop:step]\ntext[::2]   # 'Pto' (every 2nd character)\ntext[1::2]  # 'yhn' (every 2nd, starting at 1)\n\n# Negative step (reverse)\ntext[::-1]  # 'nohtyP' (reversed)\n\n# Negative indices in slicing\ntext[-3:]   # 'hon' (last 3 characters)\ntext[:-2]   # 'Pyth' (all but last 2)\n\n\n\n4.3.2 Error Type 2: Slicing Mistakes (No Error, But Wrong Results)\nWhat Happened: Slicing doesn‚Äôt raise errors, but wrong indices give unexpected results.\nCode Example - WRONG LOGIC:\ntext = \"Hello World\"\n\n# Getting empty string unexpectedly\nsubstring = text[5:3]  # '' (start &gt; stop gives empty)\n\n# Wrong order\nsubstring = text[10:0]  # '' (should be text[0:10])\n\n# Confusing positive and negative\nsubstring = text[-1:0]  # '' (wrong direction)\n\n# Off-by-one errors\n# Want \"Hello\" (first 5 chars)\nsubstring = text[0:4]  # 'Hell' (missing last char!)\n\n# Want \"World\" (last 5 chars)\nsubstring = text[6:10]  # 'Worl' (missing last char!)\nCode Example - CORRECT:\ntext = \"Hello World\"\n\n# Get first N characters\nfirst_5 = text[:5]  # ‚úì 'Hello'\n\n# Get last N characters\nlast_5 = text[-5:]  # ‚úì 'World'\n\n# Get middle portion\nmiddle = text[6:11]  # ‚úì 'World' (or text[6:])\n\n# Remove first N characters\nwithout_first_6 = text[6:]  # ‚úì 'World'\n\n# Remove last N characters\nwithout_last_6 = text[:-6]  # ‚úì 'Hello'\n\n# Get every 2nd character\nevery_2nd = text[::2]  # ‚úì 'HloWrd'\n\n# Reverse string\nreversed_text = text[::-1]  # ‚úì 'dlroW olleH'\n\n# Safe slicing (never errors)\nsubstring = text[100:200]  # ‚úì '' (empty, no error)\n\n# Get substring between positions\nstart = 0\nend = 5\nsubstring = text[start:end]  # ‚úì 'Hello'\n\n# Extract file extension\nfilename = \"document.txt\"\nextension = filename[filename.rfind('.'):]  # ‚úì '.txt'\n# Or better:\nextension = filename.split('.')[-1]  # ‚úì 'txt'\nSlicing Patterns:\ntext = \"Python Programming\"\n\n# First word\nfirst_word = text.split()[0]  # 'Python'\n# Or: text[:text.find(' ')]\n\n# Last word\nlast_word = text.split()[-1]  # 'Programming'\n# Or: text[text.rfind(' ')+1:]\n\n# First N characters\ntext[:5]  # 'Pytho'\n\n# Last N characters  \ntext[-5:]  # 'mming'\n\n# Middle portion\ntext[7:18]  # 'Programming'\n\n# Remove whitespace from ends\ntext.strip()  # Removes leading/trailing spaces\n\n# Reverse\ntext[::-1]  # 'gnimmargorP nohtyP'",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#string-methods",
    "href": "chapter-03-strings-methods.html#string-methods",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.4 3.3 String Methods",
    "text": "4.4 3.3 String Methods\n\n4.4.1 Common String Methods\ntext = \"Hello World\"\n\n# Case conversion\ntext.upper()        # 'HELLO WORLD'\ntext.lower()        # 'hello world'\ntext.capitalize()   # 'Hello world'\ntext.title()        # 'Hello World'\n\n# Checking content\ntext.startswith('Hello')  # True\ntext.endswith('World')    # True\ntext.isalpha()      # False (has space)\ntext.isdigit()      # False\ntext.isalnum()      # False (has space)\n\n# Finding substrings\ntext.find('World')   # 6 (index where found)\ntext.find('Python')  # -1 (not found)\ntext.index('World')  # 6 (raises ValueError if not found)\n\n# Replacing\ntext.replace('World', 'Python')  # 'Hello Python'\n\n# Splitting and joining\nwords = text.split()  # ['Hello', 'World']\njoined = ' '.join(words)  # 'Hello World'\n\n# Stripping whitespace\n\"  hello  \".strip()   # 'hello'\n\"  hello  \".lstrip()  # 'hello  '\n\"  hello  \".rstrip()  # '  hello'\n\n\n\n4.4.2 Error Type 3: AttributeError: 'str' object has no attribute 'X'\nError Message:\n&gt;&gt;&gt; text = \"hello\"\n&gt;&gt;&gt; text.append(\"!\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'str' object has no attribute 'append'\nWhat Happened: You tried to use a method that doesn‚Äôt exist for strings, or you made a typo.\nWhy It Happens: - Using list methods on strings - Typo in method name - Confusing similar methods - Wrong object type\nCode Example - WRONG:\ntext = \"hello\"\n\n# List methods don't work on strings\ntext.append(\"!\")  # ERROR! Strings don't have append\n\n# Typo in method name\ntext.uppper()  # ERROR! Typo: should be upper()\n\n# Wrong method\ntext.add(\"world\")  # ERROR! No 'add' method\n\n# Trying to modify immutably\ntext[0] = 'H'  # ERROR! Strings are immutable\n\n# Wrong assumptions\ntext.remove('l')  # ERROR! Strings don't have remove\nCode Example - CORRECT:\ntext = \"hello\"\n\n# Use string concatenation instead of append\ntext = text + \"!\"  # ‚úì \"hello!\"\n# Or use +=\ntext += \"!\"  # ‚úì\n\n# Correct method names\ntext.upper()  # ‚úì \"HELLO\"\ntext.lower()  # ‚úì \"hello\"\n\n# Use replace to \"modify\" strings\ntext = text.replace('h', 'H')  # ‚úì \"Hello\"\n\n# Remove characters with replace\ntext = text.replace('l', '')  # ‚úì \"heo\" (removes all 'l')\n\n# Create new string instead of modifying\ntext = \"hello\"\nnew_text = 'H' + text[1:]  # ‚úì \"Hello\"\n\n# Check if method exists\nif hasattr(text, 'upper'):\n    result = text.upper()  # ‚úì\n\n# Common string methods (not list methods)\ntext = \"hello world\"\ntext.split()          # ‚úì Returns list: ['hello', 'world']\ntext.replace('o', '0') # ‚úì Returns: 'hell0 w0rld'\ntext.find('world')    # ‚úì Returns: 6\ntext.startswith('h')  # ‚úì Returns: True\ntext.strip()          # ‚úì Removes whitespace\ntext.count('l')       # ‚úì Returns: 3\nString Method Reference:\ntext = \"Hello World\"\n\n# Case methods\ntext.upper()      # HELLO WORLD\ntext.lower()      # hello world\ntext.capitalize() # Hello world\ntext.title()      # Hello World\ntext.swapcase()   # hELLO wORLD\n\n# Checking methods (return bool)\ntext.isalpha()    # False (has space)\ntext.isdigit()    # False\ntext.isalnum()    # False\ntext.isspace()    # False\ntext.isupper()    # False\ntext.islower()    # False\ntext.istitle()    # True\n\n# Search methods\ntext.find('o')        # 4 (first occurrence)\ntext.rfind('o')       # 7 (last occurrence)\ntext.index('o')       # 4 (like find, but raises ValueError if not found)\ntext.count('o')       # 2\ntext.startswith('He') # True\ntext.endswith('ld')   # True\n\n# Modification methods (return new string)\ntext.replace('World', 'Python')  # Hello Python\ntext.strip()          # Removes whitespace\ntext.lstrip()         # Removes left whitespace\ntext.rstrip()         # Removes right whitespace\n\n# Split and join\ntext.split()          # ['Hello', 'World']\ntext.split('o')       # ['Hell', ' W', 'rld']\n' '.join(['a', 'b'])  # 'a b'\n\n# Padding and alignment\ntext.center(20)       # '    Hello World     '\ntext.ljust(20)        # 'Hello World         '\ntext.rjust(20)        # '         Hello World'\ntext.zfill(20)        # '000000000Hello World'",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#string-formatting",
    "href": "chapter-03-strings-methods.html#string-formatting",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.5 3.4 String Formatting",
    "text": "4.5 3.4 String Formatting\n\n4.5.1 String Formatting Methods\n# f-strings (Python 3.6+) - RECOMMENDED\nname = \"Alice\"\nage = 25\nmessage = f\"My name is {name} and I'm {age} years old\"\n# \"My name is Alice and I'm 25 years old\"\n\n# format() method\nmessage = \"My name is {} and I'm {} years old\".format(name, age)\n\n# %-formatting (old style)\nmessage = \"My name is %s and I'm %d years old\" % (name, age)\n\n# Formatting numbers\npi = 3.14159\nformatted = f\"Pi is {pi:.2f}\"  # \"Pi is 3.14\"\n\n# Formatting with width\nnumber = 42\nformatted = f\"Number: {number:5d}\"  # \"Number:    42\"\n\n\n\n4.5.2 Error Type 4: ValueError: invalid format string\nError Message:\n&gt;&gt;&gt; name = \"Alice\"\n&gt;&gt;&gt; message = f\"Hello {nme}\"  # Typo in variable name\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'nme' is not defined\nWhat Happened: Errors in f-strings or format strings.\nCode Example - WRONG:\n# Typo in variable name\nname = \"Alice\"\nmessage = f\"Hello {nme}\"  # ERROR! 'nme' not defined\n\n# Wrong number of arguments in format()\ntemplate = \"Hello {} and {}\"\nmessage = template.format(\"Alice\")  # ERROR! Needs 2 arguments\n\n# Wrong format specifier\nnumber = 42\nformatted = f\"{number:.2f}\"  # ERROR! Can't format int as float\n# (Actually works in Python 3, but conceptually wrong)\n\n# Unclosed brace\nmessage = f\"Hello {name\"  # ERROR! SyntaxError: unclosed '{'\n\n# Wrong %-formatting\nname = \"Alice\"\nage = 25\nmessage = \"Name: %s, Age: %s\" % name  # ERROR! Needs tuple with 2 items\nCode Example - CORRECT:\n# Correct variable name\nname = \"Alice\"\nmessage = f\"Hello {name}\"  # ‚úì\n\n# Correct number of arguments\ntemplate = \"Hello {} and {}\"\nmessage = template.format(\"Alice\", \"Bob\")  # ‚úì\n\n# Correct format specifier for float\nnumber = 42.5\nformatted = f\"{number:.2f}\"  # ‚úì \"42.50\"\n\n# Convert int to float if needed\nnumber = 42\nformatted = f\"{float(number):.2f}\"  # ‚úì \"42.00\"\n\n# Closed braces\nmessage = f\"Hello {name}\"  # ‚úì\n\n# Correct %-formatting\nname = \"Alice\"\nage = 25\nmessage = \"Name: %s, Age: %d\" % (name, age)  # ‚úì Tuple\n\n# f-string with expressions\nx = 10\ny = 20\nmessage = f\"Sum is {x + y}\"  # ‚úì \"Sum is 30\"\n\n# Format with padding\nnumber = 42\nformatted = f\"{number:05d}\"  # ‚úì \"00042\" (5 digits, zero-padded)\n\n# Multiple variables\nfirst = \"Alice\"\nlast = \"Smith\"\nage = 25\nmessage = f\"{first} {last} is {age} years old\"  # ‚úì\n\n# Format numbers in f-strings\nprice = 19.99\nmessage = f\"Price: ${price:.2f}\"  # ‚úì \"Price: $19.99\"\n\n# Use format() safely\nmessage = \"Hello {}\".format(name)  # ‚úì\nmessage = \"Hello {name}\".format(name=name)  # ‚úì Named\n\n# Escape braces\nmessage = f\"Use {{braces}} in f-strings\"  # ‚úì \"Use {braces} in f-strings\"\nFormat Specifier Reference:\nnumber = 42\npi = 3.14159\ntext = \"hello\"\n\n# Integer formatting\nf\"{number:d}\"     # '42' (decimal)\nf\"{number:5d}\"    # '   42' (width 5)\nf\"{number:05d}\"   # '00042' (zero-padded)\n\n# Float formatting\nf\"{pi:f}\"         # '3.141590' (default 6 decimals)\nf\"{pi:.2f}\"       # '3.14' (2 decimals)\nf\"{pi:8.2f}\"      # '    3.14' (width 8, 2 decimals)\n\n# String formatting\nf\"{text:s}\"       # 'hello'\nf\"{text:&gt;10s}\"    # '     hello' (right-aligned, width 10)\nf\"{text:&lt;10s}\"    # 'hello     ' (left-aligned)\nf\"{text:^10s}\"    # '  hello   ' (centered)\n\n# Percentage\nvalue = 0.85\nf\"{value:.1%}\"    # '85.0%'\n\n# Scientific notation\nlarge = 1000000\nf\"{large:e}\"      # '1.000000e+06'\nf\"{large:.2e}\"    # '1.00e+06'",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#string-immutability",
    "href": "chapter-03-strings-methods.html#string-immutability",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.6 3.5 String Immutability",
    "text": "4.6 3.5 String Immutability\n\n4.6.1 Understanding Immutability\n# Strings are immutable - cannot be changed\ntext = \"hello\"\n\n# This creates a NEW string\ntext = text.upper()  # \"HELLO\"\n\n# Original string unchanged (if referenced elsewhere)\noriginal = \"hello\"\nmodified = original.upper()\nprint(original)  # Still \"hello\"\nprint(modified)  # \"HELLO\"\n\n\n\n4.6.2 Error Type 5: TypeError: 'str' object does not support item assignment\nError Message:\n&gt;&gt;&gt; text = \"hello\"\n&gt;&gt;&gt; text[0] = 'H'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'str' object does not support item assignment\nWhat Happened: You tried to change a character in a string. Strings are immutable in Python.\nWhy It Happens: - Trying to modify string directly - Treating string like a list - Not understanding immutability\nCode Example - WRONG:\ntext = \"hello\"\n\n# Can't modify characters\ntext[0] = 'H'  # ERROR! Strings are immutable\n\n# Can't delete characters\ndel text[0]  # ERROR! Can't delete from immutable\n\n# Can't use list methods that modify\ntext.append('!')  # ERROR! No such method\ntext.remove('l')  # ERROR! No such method\ntext.insert(0, 'H')  # ERROR! No such method\nCode Example - CORRECT:\ntext = \"hello\"\n\n# Create new string with change\ntext = 'H' + text[1:]  # ‚úì \"Hello\"\n\n# Use string methods that return new strings\ntext = text.replace('h', 'H')  # ‚úì \"Hello\"\n\n# Build new string\ntext = \"hello\"\nnew_text = \"\"\nfor char in text:\n    if char == 'h':\n        new_text += 'H'\n    else:\n        new_text += char\n# new_text is \"Hello\"\n\n# Use list for modifications, then join\ntext = \"hello\"\nchars = list(text)  # ['h', 'e', 'l', 'l', 'o']\nchars[0] = 'H'      # ‚úì Lists are mutable\ntext = ''.join(chars)  # ‚úì \"Hello\"\n\n# Multiple replacements\ntext = \"hello world\"\ntext = text.replace('h', 'H').replace('w', 'W')\n# \"Hello World\"\n\n# Remove characters\ntext = \"hello\"\ntext = text.replace('l', '')  # ‚úì \"heo\"\n\n# Insert characters (create new string)\ntext = \"heo\"\ntext = text[:2] + 'll' + text[2:]  # ‚úì \"hello\"\n\n# Reverse string (creates new)\ntext = \"hello\"\nreversed_text = text[::-1]  # ‚úì \"olleh\"\nWhy Immutability Matters:\n# Immutability makes strings safe\ndef process_text(text):\n    text = text.upper()  # Creates NEW string\n    return text\n\noriginal = \"hello\"\nresult = process_text(original)\nprint(original)  # Still \"hello\" - unchanged\nprint(result)    # \"HELLO\" - new string\n\n# Multiple references to same string\ntext1 = \"hello\"\ntext2 = text1\ntext1 = text1.upper()  # Creates NEW string\nprint(text1)  # \"HELLO\"\nprint(text2)  # \"hello\" - unchanged\n\n# This is different from lists (mutable)\nlist1 = [1, 2, 3]\nlist2 = list1\nlist1.append(4)  # Modifies same list\nprint(list1)  # [1, 2, 3, 4]\nprint(list2)  # [1, 2, 3, 4] - also changed!",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#common-string-operations",
    "href": "chapter-03-strings-methods.html#common-string-operations",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.7 3.6 Common String Operations",
    "text": "4.7 3.6 Common String Operations\n\n4.7.1 Checking String Content\ntext = \"Hello123\"\n\n# Check if all characters are letters\ntext.isalpha()  # False (has digits)\n\n# Check if all characters are digits\ntext.isdigit()  # False (has letters)\n\n# Check if alphanumeric (letters and digits)\ntext.isalnum()  # True\n\n# Check if all lowercase\n\"hello\".islower()  # True\n\"Hello\".islower()  # False\n\n# Check if all uppercase\n\"HELLO\".isupper()  # True\n\n# Check if empty\ntext = \"\"\nif text:  # False - empty string is falsy\n    print(\"Has content\")\nelse:\n    print(\"Empty\")\n\n# Check if whitespace only\n\"   \".isspace()  # True\n\"hello\".isspace()  # False\n\n\n\n4.7.2 Error Type 6: String Comparison Pitfalls\nCode Example - WRONG LOGIC:\n# Case-sensitive comparison\nname = \"Alice\"\nif name == \"alice\":  # False!\n    print(\"Match\")\n\n# Leading/trailing whitespace\ntext = \"  hello  \"\nif text == \"hello\":  # False!\n    print(\"Match\")\n\n# Type mismatch\nnumber = \"5\"\nif number == 5:  # False! String vs int\n    print(\"Match\")\n\n# Empty string checks\ntext = \"\"\nif text == None:  # False! Empty string is not None\n    print(\"None\")\nCode Example - CORRECT:\n# Case-insensitive comparison\nname = \"Alice\"\nif name.lower() == \"alice\":  # ‚úì True\n    print(\"Match\")\n\n# Strip whitespace first\ntext = \"  hello  \"\nif text.strip() == \"hello\":  # ‚úì True\n    print(\"Match\")\n\n# Convert types before comparing\nnumber = \"5\"\nif int(number) == 5:  # ‚úì True\n    print(\"Match\")\n\n# Or convert the other way\nif number == str(5):  # ‚úì True\n    print(\"Match\")\n\n# Check for empty string\ntext = \"\"\nif not text:  # ‚úì True - empty string is falsy\n    print(\"Empty\")\n\n# Or explicitly\nif text == \"\":  # ‚úì True\n    print(\"Empty\")\n\n# Check for None\nvalue = None\nif value is None:  # ‚úì True\n    print(\"None\")\n\n# Check for empty or None\nif not text or text is None:  # ‚úì\n    print(\"Empty or None\")\n\n# Substring checking\ntext = \"Hello World\"\nif \"World\" in text:  # ‚úì True\n    print(\"Contains 'World'\")\n\n# Starts with / ends with\nfilename = \"document.txt\"\nif filename.endswith('.txt'):  # ‚úì True\n    print(\"Text file\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#practice-problems---fix-these-errors",
    "href": "chapter-03-strings-methods.html#practice-problems---fix-these-errors",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.8 3.7 Practice Problems - Fix These Errors!",
    "text": "4.8 3.7 Practice Problems - Fix These Errors!\n\n4.8.1 Problem 1: Index Out of Range\ntext = \"Python\"\nprint(text[6])\n\n\nClick for Answer\n\nError: IndexError: string index out of range\nWhy: String has indices 0-5, trying to access index 6\nFix:\ntext = \"Python\"\nprint(text[5])  # ‚úì Last character: 'n'\n# Or\nprint(text[-1])  # ‚úì Better: 'n'\n\n\n\n\n4.8.2 Problem 2: Wrong Method\ntext = \"hello\"\ntext.append(\" world\")\n\n\nClick for Answer\n\nError: AttributeError: 'str' object has no attribute 'append'\nWhy: Strings don‚Äôt have append method (lists do)\nFix:\ntext = \"hello\"\ntext = text + \" world\"  # ‚úì Concatenation\n# Or\ntext += \" world\"  # ‚úì Also works\nprint(text)  # \"hello world\"\n\n\n\n\n4.8.3 Problem 3: String Immutability\ntext = \"hello\"\ntext[0] = 'H'\n\n\nClick for Answer\n\nError: TypeError: 'str' object does not support item assignment\nWhy: Strings are immutable\nFix:\ntext = \"hello\"\ntext = 'H' + text[1:]  # ‚úì Create new string\nprint(text)  # \"Hello\"\n\n# Or use replace\ntext = \"hello\"\ntext = text.replace('h', 'H')  # ‚úì \"Hello\"\n\n\n\n\n4.8.4 Problem 4: Format String Error\nname = \"Alice\"\nage = 25\nmessage = f\"Hello {name}, you are {ag} years old\"\n\n\nClick for Answer\n\nError: NameError: name 'ag' is not defined\nWhy: Typo in variable name inside f-string\nFix:\nname = \"Alice\"\nage = 25\nmessage = f\"Hello {name}, you are {age} years old\"  # ‚úì Correct variable name\nprint(message)  # \"Hello Alice, you are 25 years old\"\n\n\n\n\n4.8.5 Problem 5: Comparison Error\ntext = \"  hello  \"\nif text == \"hello\":\n    print(\"Match\")\nelse:\n    print(\"No match\")\n\n\nClick for Answer\n\nIssue: Prints ‚ÄúNo match‚Äù due to whitespace\nFix:\ntext = \"  hello  \"\nif text.strip() == \"hello\":  # ‚úì Strip whitespace first\n    print(\"Match\")\nelse:\n    print(\"No match\")\n# Prints: \"Match\"",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#key-takeaways",
    "href": "chapter-03-strings-methods.html#key-takeaways",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.9 3.8 Key Takeaways",
    "text": "4.9 3.8 Key Takeaways\n\n4.9.1 What You Learned\n\nCheck string length before indexing - Avoid IndexError\nUse correct string methods - Strings don‚Äôt have list methods\nStrings are immutable - Create new strings, don‚Äôt modify\nUse f-strings for formatting - Modern and clear\nStrip whitespace when comparing - Avoid comparison issues\nCase-insensitive comparison - Use .lower() or .upper()\nSlicing never errors - But check logic for correct results\n\n\n\n4.9.2 Common Patterns\n# Pattern 1: Safe character access\nif len(text) &gt; index:\n    char = text[index]\n\n# Pattern 2: Case-insensitive comparison\nif text.lower() == \"hello\":\n    print(\"Match\")\n\n# Pattern 3: Clean and compare\nif text.strip() == \"expected\":\n    print(\"Match\")\n\n# Pattern 4: Create new string from old\ntext = 'H' + text[1:]\n\n# Pattern 5: Check empty string\nif not text:\n    print(\"Empty\")\n\n# Pattern 6: Safe substring check\nif \"substring\" in text:\n    print(\"Found\")\n\n\n4.9.3 Error Summary Table\n\n\n\nError Type\nCommon Cause\nPrevention\n\n\n\n\nIndexError\nIndex beyond string length\nCheck len() first\n\n\nAttributeError\nWrong method or typo\nUse correct string methods\n\n\nTypeError\nTrying to modify string\nCreate new string instead\n\n\nValueError\nWrong format string\nCheck variable names and format",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-03-strings-methods.html#moving-forward",
    "href": "chapter-03-strings-methods.html#moving-forward",
    "title": "4¬† Chapter 3: Strings and String Methods - Text Manipulation Errors",
    "section": "4.10 3.9 Moving Forward",
    "text": "4.10 3.9 Moving Forward\nYou now understand strings and string methods. You can: - Access characters safely - Use string methods correctly - Format strings properly - Handle immutability - Compare strings accurately\nIn Chapter 4, we‚Äôll explore Lists and List Methods - working with collections and avoiding list errors!",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Chapter 3: Strings and String Methods - Text Manipulation Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html",
    "href": "chapter-04-lists-methods.html",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "",
    "text": "5.1 Introduction\nYou‚Äôve mastered strings. Now let‚Äôs explore lists - Python‚Äôs most versatile collection type. Lists store multiple items in a single variable and are mutable (unlike strings).\nCommon list errors: - IndexError: Accessing invalid positions - ValueError: Item not found - TypeError: Wrong operations or types - AttributeError: Wrong methods\nLists are everywhere in Python. Let‚Äôs master them by understanding their errors!",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#list-basics",
    "href": "chapter-04-lists-methods.html#list-basics",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.2 4.1 List Basics",
    "text": "5.2 4.1 List Basics\n\n5.2.1 Creating and Using Lists\n# Creating lists\nnumbers = [1, 2, 3, 4, 5]\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nmixed = [1, \"hello\", 3.14, True]\nempty = []\n\n# List length\nlength = len(numbers)  # 5\n\n# Accessing elements (0-indexed)\nfirst = numbers[0]   # 1\nlast = numbers[-1]   # 5\n\n# Modifying elements (lists are mutable!)\nnumbers[0] = 10  # [10, 2, 3, 4, 5]\n\n# Adding elements\nnumbers.append(6)  # [10, 2, 3, 4, 5, 6]\n\n# List concatenation\ncombined = [1, 2] + [3, 4]  # [1, 2, 3, 4]\n\n# List repetition\nrepeated = [1, 2] * 3  # [1, 2, 1, 2, 1, 2]\n\n\n\n5.2.2 Error Type 1: IndexError: list index out of range\nError Message:\n&gt;&gt;&gt; numbers = [1, 2, 3]\n&gt;&gt;&gt; print(numbers[5])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: list index out of range\nWhat Happened: You tried to access an index that doesn‚Äôt exist in the list.\nWhy It Happens: - Index beyond list length - Empty list - Off-by-one errors - Wrong loop bounds\nCode Example - WRONG:\nnumbers = [1, 2, 3]  # Length 3, indices 0-2\n\n# Index too large\nvalue = numbers[5]  # ERROR! Valid indices: 0-2\n\n# Empty list\nempty = []\nvalue = empty[0]  # ERROR! No elements\n\n# Off-by-one in loop\nfor i in range(len(numbers) + 1):  # Goes to 4!\n    print(numbers[i])  # ERROR when i=3\n\n# Wrong assumption\nfirst = numbers[1]  # Gets 2, not 1 (0-based!)\n\n# Negative index too large\nvalue = numbers[-10]  # ERROR! Only -3 to -1 valid\n\n# After removing elements\nnumbers = [1, 2, 3]\nnumbers.remove(2)  # Now [1, 3]\nvalue = numbers[2]  # ERROR! Only 0-1 valid now\nCode Example - CORRECT:\nnumbers = [1, 2, 3]\n\n# Use valid indices\nfirst = numbers[0]   # ‚úì 1\nlast = numbers[2]    # ‚úì 3\nlast = numbers[-1]   # ‚úì 3 (better - works for any length)\n\n# Check length before accessing\nindex = 5\nif index &lt; len(numbers):\n    value = numbers[index]\nelse:\n    print(f\"Index {index} out of range\")\n\n# Safe access with try/except\ntry:\n    value = numbers[5]\nexcept IndexError:\n    value = None\n    print(\"Index out of range\")\n\n# Use proper loop bounds\nfor i in range(len(numbers)):  # ‚úì 0, 1, 2\n    print(numbers[i])\n\n# Better: iterate directly (no indexing needed)\nfor num in numbers:  # ‚úì No index errors possible\n    print(num)\n\n# Safe get with default (custom function)\ndef safe_get(lst, index, default=None):\n    \"\"\"Safely get list item with default\"\"\"\n    try:\n        return lst[index]\n    except IndexError:\n        return default\n\nvalue = safe_get(numbers, 5, default=0)  # ‚úì Returns 0\n\n# Check before accessing after modifications\nnumbers = [1, 2, 3]\nnumbers.remove(2)\nif len(numbers) &gt; 2:\n    value = numbers[2]\nelse:\n    print(\"Not enough elements\")\n\n# Use slicing (doesn't raise errors)\nsubset = numbers[5:10]  # ‚úì Returns [], no error\nList Indexing Reference:\nnumbers = [10, 20, 30, 40, 50]\n#           0   1   2   3   4   (positive indices)\n#          -5  -4  -3  -2  -1   (negative indices)\n\nnumbers[0]    # 10 (first)\nnumbers[4]    # 50 (last)\nnumbers[-1]   # 50 (last, better way)\nnumbers[-5]   # 10 (first)\n\n# Valid range: 0 to len(numbers)-1\n# Or: -len(numbers) to -1",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#list-slicing",
    "href": "chapter-04-lists-methods.html#list-slicing",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.3 4.2 List Slicing",
    "text": "5.3 4.2 List Slicing\n\n5.3.1 Understanding List Slicing\nnumbers = [0, 1, 2, 3, 4, 5]\n\n# Basic slicing [start:stop]\nnumbers[1:4]   # [1, 2, 3] (indices 1, 2, 3)\nnumbers[0:3]   # [0, 1, 2]\n\n# Omitting start or stop\nnumbers[:3]    # [0, 1, 2] (from beginning)\nnumbers[3:]    # [3, 4, 5] (to end)\nnumbers[:]     # [0, 1, 2, 3, 4, 5] (copy entire list)\n\n# Step parameter [start:stop:step]\nnumbers[::2]   # [0, 2, 4] (every 2nd element)\nnumbers[1::2]  # [1, 3, 5] (every 2nd, starting at 1)\n\n# Negative step (reverse)\nnumbers[::-1]  # [5, 4, 3, 2, 1, 0] (reversed)\n\n# Negative indices in slicing\nnumbers[-3:]   # [3, 4, 5] (last 3 elements)\nnumbers[:-2]   # [0, 1, 2, 3] (all but last 2)\n\n# Modifying with slicing\nnumbers[1:3] = [10, 20]  # [0, 10, 20, 3, 4, 5]",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#list-methods",
    "href": "chapter-04-lists-methods.html#list-methods",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.4 4.3 List Methods",
    "text": "5.4 4.3 List Methods\n\n5.4.1 Common List Methods\nnumbers = [1, 2, 3]\n\n# Adding elements\nnumbers.append(4)        # [1, 2, 3, 4] - add to end\nnumbers.insert(0, 0)     # [0, 1, 2, 3, 4] - add at position\nnumbers.extend([5, 6])   # [0, 1, 2, 3, 4, 5, 6] - add multiple\n\n# Removing elements\nnumbers.remove(3)        # [0, 1, 2, 4, 5, 6] - remove first occurrence\npopped = numbers.pop()   # [0, 1, 2, 4, 5] - remove and return last\npopped = numbers.pop(0)  # [1, 2, 4, 5] - remove at index\n\n# Finding elements\nindex = numbers.index(2)  # 1 - position of first occurrence\ncount = numbers.count(2)  # 1 - how many times it appears\n\n# Sorting\nnumbers.sort()            # [1, 2, 4, 5] - sort in place\nnumbers.reverse()         # [5, 4, 2, 1] - reverse in place\n\n# Clearing\nnumbers.clear()          # [] - remove all elements\n\n# Copying\noriginal = [1, 2, 3]\nshallow_copy = original.copy()  # Creates independent copy\n\n\n\n5.4.2 Error Type 2: ValueError: X is not in list\nError Message:\n&gt;&gt;&gt; numbers = [1, 2, 3]\n&gt;&gt;&gt; numbers.remove(5)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: list.remove(x): x not in list\nWhat Happened: You tried to remove or find an item that doesn‚Äôt exist in the list.\nWhy It Happens: - Using remove() on non-existent item - Using index() on non-existent item - Wrong value or type\nCode Example - WRONG:\nnumbers = [1, 2, 3]\n\n# Remove non-existent item\nnumbers.remove(5)  # ERROR! 5 not in list\n\n# Find non-existent item\nindex = numbers.index(5)  # ERROR! 5 not in list\n\n# Type mismatch\nnumbers = [1, 2, 3]\nnumbers.remove(\"1\")  # ERROR! \"1\" (string) not same as 1 (int)\n\n# After already removing\nnumbers = [1, 2, 3]\nnumbers.remove(2)  # [1, 3]\nnumbers.remove(2)  # ERROR! 2 already removed\n\n# Case sensitivity with strings\nnames = [\"Alice\", \"Bob\"]\nnames.remove(\"alice\")  # ERROR! Case doesn't match\nCode Example - CORRECT:\nnumbers = [1, 2, 3]\n\n# Check before removing\nif 5 in numbers:\n    numbers.remove(5)\nelse:\n    print(\"5 not in list\")  # ‚úì\n\n# Use try/except for remove\ntry:\n    numbers.remove(5)\nexcept ValueError:\n    print(\"Item not found\")  # ‚úì\n\n# Check before finding\nif 5 in numbers:\n    index = numbers.index(5)\nelse:\n    index = -1  # or None\n\n# Safe find function\ndef safe_index(lst, item, default=-1):\n    \"\"\"Safely find index with default\"\"\"\n    try:\n        return lst.index(item)\n    except ValueError:\n        return default\n\nindex = safe_index(numbers, 5, default=-1)  # ‚úì Returns -1\n\n# Remove by index instead (if you know position)\nif len(numbers) &gt; 2:\n    numbers.pop(2)  # ‚úì Removes item at index 2\n\n# Remove all occurrences\nnumbers = [1, 2, 3, 2, 2]\nwhile 2 in numbers:  # ‚úì Removes all 2s\n    numbers.remove(2)\n# Result: [1, 3]\n\n# Or use list comprehension\nnumbers = [1, 2, 3, 2, 2]\nnumbers = [x for x in numbers if x != 2]  # ‚úì [1, 3]\n\n# Case-insensitive removal for strings\nnames = [\"Alice\", \"Bob\"]\nto_remove = \"alice\"\nnames = [n for n in names if n.lower() != to_remove.lower()]  # ‚úì\n\n# Use discard for sets (no error if not found)\nnumber_set = {1, 2, 3}\nnumber_set.discard(5)  # ‚úì No error - we'll learn sets in Ch 5\n\n\n\n5.4.3 Error Type 3: TypeError: list indices must be integers or slices, not X\nError Message:\n&gt;&gt;&gt; numbers = [1, 2, 3]\n&gt;&gt;&gt; print(numbers[\"0\"])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: list indices must be integers or slices, not str\nWhat Happened: You tried to use a non-integer as a list index.\nWhy It Happens: - Using string instead of integer - Using float instead of integer - Forgetting to convert types\nCode Example - WRONG:\nnumbers = [1, 2, 3]\n\n# String index\nvalue = numbers[\"0\"]  # ERROR! Use 0, not \"0\"\n\n# Float index\nvalue = numbers[1.5]  # ERROR! Use int, not float\n\n# Variable that's wrong type\nindex = \"1\"\nvalue = numbers[index]  # ERROR! index is string\n\n# User input (always string)\nindex = input(\"Enter index: \")  # \"1\"\nvalue = numbers[index]  # ERROR! Need to convert\nCode Example - CORRECT:\nnumbers = [1, 2, 3]\n\n# Use integer indices\nvalue = numbers[0]  # ‚úì 1\n\n# Convert string to int\nindex = \"1\"\nvalue = numbers[int(index)]  # ‚úì 2\n\n# Convert user input\nindex = input(\"Enter index: \")\ntry:\n    index = int(index)\n    value = numbers[index]\nexcept (ValueError, IndexError) as e:\n    print(f\"Invalid index: {e}\")\n\n# Convert float to int (if needed)\nindex = 1.7\nvalue = numbers[int(index)]  # ‚úì Uses 1\n\n# Validate before converting\nindex_str = \"1\"\nif index_str.isdigit():\n    value = numbers[int(index_str)]  # ‚úì\nelse:\n    print(\"Invalid index\")\n\n# Safe index function\ndef get_by_index(lst, index):\n    \"\"\"Safely get item by index, handling type conversion\"\"\"\n    try:\n        # Convert to int if needed\n        if not isinstance(index, int):\n            index = int(index)\n        return lst[index]\n    except (ValueError, IndexError, TypeError) as e:\n        return None\n\nvalue = get_by_index(numbers, \"1\")  # ‚úì Returns 2\nvalue = get_by_index(numbers, \"10\")  # ‚úì Returns None",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#list-mutability",
    "href": "chapter-04-lists-methods.html#list-mutability",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.5 4.4 List Mutability",
    "text": "5.5 4.4 List Mutability\n\n5.5.1 Understanding Mutability\n# Lists are mutable - can be changed in place\nnumbers = [1, 2, 3]\nnumbers[0] = 10  # ‚úì Changed: [10, 2, 3]\nnumbers.append(4)  # ‚úì Changed: [10, 2, 3, 4]\n\n# This affects all references\nlist1 = [1, 2, 3]\nlist2 = list1  # list2 points to SAME list\nlist1.append(4)\nprint(list1)  # [1, 2, 3, 4]\nprint(list2)  # [1, 2, 3, 4] - also changed!\n\n# To avoid this, create a copy\nlist1 = [1, 2, 3]\nlist2 = list1.copy()  # or list1[:]\nlist1.append(4)\nprint(list1)  # [1, 2, 3, 4]\nprint(list2)  # [1, 2, 3] - unchanged ‚úì\n\n\n\n5.5.2 Error Type 4: Unintended List Modification\nWhat Happened: Modifying a list affects all references to that list.\nCode Example - WRONG:\n# Shared reference problem\ndef add_item(lst):\n    lst.append(4)\n    return lst\n\noriginal = [1, 2, 3]\nnew_list = add_item(original)\nprint(original)  # [1, 2, 3, 4] - Oops! Original changed!\n\n# Default mutable argument (dangerous!)\ndef add_to_list(item, lst=[]):\n    lst.append(item)\n    return lst\n\nresult1 = add_to_list(1)  # [1]\nresult2 = add_to_list(2)  # [1, 2] - Unexpected! Same list!\nresult3 = add_to_list(3)  # [1, 2, 3] - Still same list!\n\n# Multiple references\nlist1 = [1, 2, 3]\nlist2 = list1\nlist3 = list1\nlist2.append(4)\nprint(list1)  # [1, 2, 3, 4]\nprint(list2)  # [1, 2, 3, 4]\nprint(list3)  # [1, 2, 3, 4] - All changed!\nCode Example - CORRECT:\n# Create a copy in function\ndef add_item(lst):\n    new_list = lst.copy()  # ‚úì Create copy\n    new_list.append(4)\n    return new_list\n\noriginal = [1, 2, 3]\nnew_list = add_item(original)\nprint(original)  # [1, 2, 3] - Unchanged ‚úì\nprint(new_list)  # [1, 2, 3, 4]\n\n# Use None as default, create new list inside\ndef add_to_list(item, lst=None):\n    if lst is None:\n        lst = []  # ‚úì Create new list each time\n    lst.append(item)\n    return lst\n\nresult1 = add_to_list(1)  # [1] ‚úì\nresult2 = add_to_list(2)  # [2] ‚úì Different list\nresult3 = add_to_list(3)  # [3] ‚úì Different list\n\n# Create independent copies\nlist1 = [1, 2, 3]\nlist2 = list1.copy()  # ‚úì or list1[:]\nlist3 = list1.copy()  # ‚úì\nlist2.append(4)\nprint(list1)  # [1, 2, 3] - Unchanged\nprint(list2)  # [1, 2, 3, 4]\nprint(list3)  # [1, 2, 3] - Unchanged\n\n# Deep copy for nested lists\nimport copy\nnested = [[1, 2], [3, 4]]\nshallow = nested.copy()  # Inner lists still shared\ndeep = copy.deepcopy(nested)  # ‚úì Complete independent copy\n\n# Explicitly modify or return new\ndef process_list(lst, modify=False):\n    \"\"\"\n    Process list - modify in place or return new\n    \"\"\"\n    if modify:\n        lst.append(4)\n        return lst\n    else:\n        new_list = lst.copy()\n        new_list.append(4)\n        return new_list\n\noriginal = [1, 2, 3]\nnew = process_list(original, modify=False)  # ‚úì Original safe",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#list-comprehensions",
    "href": "chapter-04-lists-methods.html#list-comprehensions",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.6 4.5 List Comprehensions",
    "text": "5.6 4.5 List Comprehensions\n\n5.6.1 Understanding List Comprehensions\n# Traditional loop\nsquares = []\nfor x in range(5):\n    squares.append(x ** 2)\n# [0, 1, 4, 9, 16]\n\n# List comprehension (more Pythonic)\nsquares = [x ** 2 for x in range(5)]\n# [0, 1, 4, 9, 16]\n\n# With condition\nevens = [x for x in range(10) if x % 2 == 0]\n# [0, 2, 4, 6, 8]\n\n# Transforming list\nnames = [\"alice\", \"bob\", \"charlie\"]\nupper_names = [name.upper() for name in names]\n# [\"ALICE\", \"BOB\", \"CHARLIE\"]\n\n# Nested comprehensions\nmatrix = [[i*j for j in range(3)] for i in range(3)]\n# [[0, 0, 0], [0, 1, 2], [0, 2, 4]]\n\n\n\n5.6.2 Error Type 5: List Comprehension Mistakes\nCode Example - WRONG:\n# Syntax error - wrong order\nsquares = [for x in range(5) x ** 2]  # ERROR! Wrong order\n\n# Missing brackets\nsquares = x ** 2 for x in range(5)  # ERROR! This makes generator, not list\n\n# Using wrong variable\nnumbers = [1, 2, 3]\ndoubled = [x * 2 for num in numbers]  # ERROR! x not defined\n\n# Complex logic without parentheses\nresult = [x for x in range(10) if x &gt; 5 and &lt; 8]  # ERROR! Syntax error\n\n# Trying to use statements\nresult = [print(x) for x in range(5)]  # Works but prints None values\nCode Example - CORRECT:\n# Correct syntax [expression for variable in iterable]\nsquares = [x ** 2 for x in range(5)]  # ‚úì\n\n# Add brackets for list\nsquares = [x ** 2 for x in range(5)]  # ‚úì List\n# Or omit for generator (advanced)\nsquares_gen = (x ** 2 for x in range(5))  # Generator\n\n# Use correct variable\nnumbers = [1, 2, 3]\ndoubled = [num * 2 for num in numbers]  # ‚úì\n\n# Complete conditions\nresult = [x for x in range(10) if x &gt; 5 and x &lt; 8]  # ‚úì\n# Or use chaining\nresult = [x for x in range(10) if 5 &lt; x &lt; 8]  # ‚úì\n\n# Use functions for side effects separately\nfor x in range(5):  # ‚úì Better for printing\n    print(x)\n\n# Complex comprehensions\n# Filter and transform\nnumbers = [1, 2, 3, 4, 5, 6]\neven_squares = [x ** 2 for x in numbers if x % 2 == 0]  # ‚úì\n# [4, 16, 36]\n\n# Multiple conditions\nresult = [x for x in range(20) if x % 2 == 0 if x % 3 == 0]  # ‚úì\n# [0, 6, 12, 18]\n\n# Nested comprehension\nmatrix = [[i+j for j in range(3)] for i in range(3)]  # ‚úì\n# [[0, 1, 2], [1, 2, 3], [2, 3, 4]]\n\n# Flattening nested list\nnested = [[1, 2], [3, 4], [5, 6]]\nflat = [item for sublist in nested for item in sublist]  # ‚úì\n# [1, 2, 3, 4, 5, 6]",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#common-list-patterns",
    "href": "chapter-04-lists-methods.html#common-list-patterns",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.7 4.6 Common List Patterns",
    "text": "5.7 4.6 Common List Patterns\n\n5.7.1 Useful List Operations\nnumbers = [1, 2, 3, 4, 5]\n\n# Check if list is empty\nif numbers:  # ‚úì True if not empty\n    print(\"Has items\")\n\nif not numbers:  # ‚úì True if empty\n    print(\"Empty\")\n\n# Check membership\nif 3 in numbers:  # ‚úì True\n    print(\"Found 3\")\n\n# Get min/max\nminimum = min(numbers)  # 1\nmaximum = max(numbers)  # 5\n\n# Sum all elements\ntotal = sum(numbers)  # 15\n\n# Count occurrences\nnumbers = [1, 2, 2, 3, 2]\ncount = numbers.count(2)  # 3\n\n# Find all indices of value\nindices = [i for i, x in enumerate(numbers) if x == 2]\n# [1, 2, 4]\n\n# Remove duplicates (preserves order)\nnumbers = [1, 2, 2, 3, 1, 4]\nunique = list(dict.fromkeys(numbers))  # [1, 2, 3, 4]\n# Or using set (may not preserve order)\nunique = list(set(numbers))\n\n# Zip multiple lists\nnames = [\"Alice\", \"Bob\"]\nages = [25, 30]\ncombined = list(zip(names, ages))\n# [(\"Alice\", 25), (\"Bob\", 30)]\n\n# Sort without modifying original\nnumbers = [3, 1, 4, 1, 5]\nsorted_numbers = sorted(numbers)  # [1, 1, 3, 4, 5]\nprint(numbers)  # [3, 1, 4, 1, 5] - unchanged",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#practice-problems---fix-these-errors",
    "href": "chapter-04-lists-methods.html#practice-problems---fix-these-errors",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.8 4.7 Practice Problems - Fix These Errors!",
    "text": "5.8 4.7 Practice Problems - Fix These Errors!\n\n5.8.1 Problem 1: Index Out of Range\nnumbers = [10, 20, 30]\nfor i in range(len(numbers) + 1):\n    print(numbers[i])\n\n\nClick for Answer\n\nError: IndexError: list index out of range\nWhy: Loop goes to index 3, but list only has indices 0-2\nFix:\nnumbers = [10, 20, 30]\nfor i in range(len(numbers)):  # ‚úì Remove +1\n    print(numbers[i])\n\n# Or better - iterate directly:\nfor num in numbers:  # ‚úì No indexing needed\n    print(num)\n\n\n\n\n5.8.2 Problem 2: ValueError\nnumbers = [1, 2, 3]\nnumbers.remove(5)\n\n\nClick for Answer\n\nError: ValueError: list.remove(x): x not in list\nWhy: 5 doesn‚Äôt exist in the list\nFix:\nnumbers = [1, 2, 3]\n\n# Check first\nif 5 in numbers:\n    numbers.remove(5)\nelse:\n    print(\"5 not in list\")  # ‚úì\n\n# Or use try/except\ntry:\n    numbers.remove(5)\nexcept ValueError:\n    print(\"Item not found\")  # ‚úì\n\n\n\n\n5.8.3 Problem 3: Type Error\nnumbers = [1, 2, 3]\nindex = \"1\"\nprint(numbers[index])\n\n\nClick for Answer\n\nError: TypeError: list indices must be integers or slices, not str\nWhy: Index is string, needs to be integer\nFix:\nnumbers = [1, 2, 3]\nindex = \"1\"\nprint(numbers[int(index)])  # ‚úì Convert to int\n# Prints: 2\n\n\n\n\n5.8.4 Problem 4: Unintended Modification\ndef add_item(lst):\n    lst.append(99)\n    return lst\n\noriginal = [1, 2, 3]\nnew_list = add_item(original)\nprint(original)  # What does this print?\n\n\nClick for Answer\n\nIssue: Prints [1, 2, 3, 99] - original was modified!\nWhy: Function modified the original list, not a copy\nFix:\ndef add_item(lst):\n    new = lst.copy()  # ‚úì Create copy\n    new.append(99)\n    return new\n\noriginal = [1, 2, 3]\nnew_list = add_item(original)\nprint(original)  # [1, 2, 3] - unchanged ‚úì\nprint(new_list)  # [1, 2, 3, 99]\n\n\n\n\n5.8.5 Problem 5: Wrong List Comprehension\nnumbers = [1, 2, 3, 4, 5]\nevens = [x for x in numbers if x % 2 = 0]\n\n\nClick for Answer\n\nError: SyntaxError: invalid syntax\nWhy: Using = (assignment) instead of == (comparison)\nFix:\nnumbers = [1, 2, 3, 4, 5]\nevens = [x for x in numbers if x % 2 == 0]  # ‚úì Use ==\nprint(evens)  # [2, 4]",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#key-takeaways",
    "href": "chapter-04-lists-methods.html#key-takeaways",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.9 4.8 Key Takeaways",
    "text": "5.9 4.8 Key Takeaways\n\n5.9.1 What You Learned\n\nCheck length before indexing - Avoid IndexError\nCheck membership before removing - Use in operator\nUse integer indices - Convert strings/floats to int\nBe aware of mutability - Lists can be modified\nCreate copies when needed - Use .copy() or [:]\nUse list comprehensions - More Pythonic and readable\nIterate directly when possible - Avoid indexing errors\n\n\n\n5.9.2 Common Patterns\n# Pattern 1: Safe access\nif index &lt; len(numbers):\n    value = numbers[index]\n\n# Pattern 2: Check before remove\nif item in numbers:\n    numbers.remove(item)\n\n# Pattern 3: Create copy\nnew_list = original.copy()\n\n# Pattern 4: Iterate without indices\nfor item in numbers:\n    print(item)\n\n# Pattern 5: List comprehension\nresult = [x * 2 for x in numbers if x &gt; 0]\n\n# Pattern 6: Empty check\nif numbers:  # Has items\n    first = numbers[0]\n\n\n5.9.3 Error Summary Table\n\n\n\n\n\n\n\n\nError Type\nCommon Cause\nPrevention\n\n\n\n\nIndexError\nIndex out of range\nCheck len() first, use iteration\n\n\nValueError\nItem not in list\nCheck with in before remove/index\n\n\nTypeError\nNon-integer index\nConvert to int\n\n\nUnintended modification\nShared references\nUse .copy()",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-04-lists-methods.html#moving-forward",
    "href": "chapter-04-lists-methods.html#moving-forward",
    "title": "5¬† Chapter 4: Lists and List Methods - Collection Errors",
    "section": "5.10 4.9 Moving Forward",
    "text": "5.10 4.9 Moving Forward\nYou now understand lists and list methods. You can: - Access list elements safely - Add and remove items correctly - Use list methods properly - Handle mutability - Write list comprehensions\nIn Chapter 5, we‚Äôll explore Dictionaries and Sets - key-value pairs and unique collections!",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Chapter 4: Lists and List Methods - Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html",
    "href": "chapter-05-dictionaries-sets.html",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "",
    "text": "6.1 Introduction\nYou‚Äôve mastered lists. Now let‚Äôs explore dictionaries and sets - two powerful collection types that work differently from lists.\nDictionaries store key-value pairs (like a real dictionary: word ‚Üí definition). Sets store unique items with no duplicates.\nCommon errors: - KeyError: Accessing non-existent dictionary keys - TypeError: Unhashable types as keys - AttributeError: Wrong methods - Set operation errors\nLet‚Äôs master these collections by understanding their errors!",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#dictionary-basics",
    "href": "chapter-05-dictionaries-sets.html#dictionary-basics",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.2 5.1 Dictionary Basics",
    "text": "6.2 5.1 Dictionary Basics\n\n6.2.1 Creating and Using Dictionaries\n# Creating dictionaries\nperson = {\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"city\": \"New York\"\n}\n\n# Empty dictionary\nempty = {}\n# Or\nempty = dict()\n\n# Accessing values\nname = person[\"name\"]  # \"Alice\"\nage = person[\"age\"]    # 25\n\n# Adding/modifying values\nperson[\"email\"] = \"alice@email.com\"  # Add new key\nperson[\"age\"] = 26                    # Modify existing\n\n# Dictionary length\nlength = len(person)  # Number of key-value pairs\n\n# Check if key exists\nif \"name\" in person:\n    print(\"Name exists\")\n\n\n\n6.2.2 Error Type 1: KeyError: 'key_name'\nError Message:\n&gt;&gt;&gt; person = {\"name\": \"Alice\", \"age\": 25}\n&gt;&gt;&gt; print(person[\"email\"])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 'email'\nWhat Happened: You tried to access a dictionary key that doesn‚Äôt exist.\nWhy It Happens: - Key doesn‚Äôt exist in dictionary - Typo in key name - Case sensitivity - Wrong data type for key\nCode Example - WRONG:\nperson = {\"name\": \"Alice\", \"age\": 25}\n\n# Non-existent key\nemail = person[\"email\"]  # ERROR! Key doesn't exist\n\n# Typo in key\nname = person[\"nane\"]  # ERROR! Typo\n\n# Case sensitivity\ncity = person[\"City\"]  # ERROR! Key is \"city\" not \"City\"\n\n# Wrong type\ndata = {1: \"one\", 2: \"two\"}\nvalue = data[\"1\"]  # ERROR! Key is int 1, not string \"1\"\n\n# After deleting\nperson = {\"name\": \"Alice\", \"age\": 25}\ndel person[\"age\"]\nage = person[\"age\"]  # ERROR! Already deleted\n\n# Nested dictionary access\ndata = {\"user\": {\"name\": \"Alice\"}}\nemail = data[\"user\"][\"email\"]  # ERROR! \"email\" doesn't exist\nCode Example - CORRECT:\nperson = {\"name\": \"Alice\", \"age\": 25}\n\n# Check key exists before accessing\nif \"email\" in person:\n    email = person[\"email\"]\nelse:\n    email = None\n    print(\"Email not found\")\n\n# Use .get() method (RECOMMENDED)\nemail = person.get(\"email\")  # ‚úì Returns None if not found\nemail = person.get(\"email\", \"no-email@example.com\")  # ‚úì With default\n\n# Use try/except\ntry:\n    email = person[\"email\"]\nexcept KeyError:\n    email = None\n    print(\"Key not found\")\n\n# Check spelling carefully\nname = person[\"name\"]  # ‚úì Correct spelling\n\n# Match case exactly\ndata = {\"city\": \"NYC\", \"City\": \"New York\"}\ncity = data[\"city\"]  # ‚úì \"NYC\"\nCity = data[\"City\"]  # ‚úì \"New York\" (different key!)\n\n# Match key type\ndata = {1: \"one\", 2: \"two\"}\nvalue = data[1]  # ‚úì Use int, not string\n\n# Safe nested access\ndata = {\"user\": {\"name\": \"Alice\"}}\nemail = data.get(\"user\", {}).get(\"email\", \"N/A\")  # ‚úì Safe chain\n\n# Or check each level\nif \"user\" in data and \"email\" in data[\"user\"]:\n    email = data[\"user\"][\"email\"]\nelse:\n    email = \"N/A\"\n\n# Use setdefault to get or create\nperson = {\"name\": \"Alice\"}\nemail = person.setdefault(\"email\", \"default@example.com\")\n# If \"email\" exists, returns its value\n# If not, sets it to default and returns default\nDictionary Access Patterns:\nperson = {\"name\": \"Alice\", \"age\": 25}\n\n# Direct access (raises KeyError if missing)\nname = person[\"name\"]  # Use when key MUST exist\n\n# .get() method (returns None or default)\nemail = person.get(\"email\")  # Use when key might not exist\nemail = person.get(\"email\", \"N/A\")  # With default value\n\n# Check first\nif \"email\" in person:\n    email = person[\"email\"]\n\n# Get with default using setdefault\nemail = person.setdefault(\"email\", \"new@example.com\")\n# Sets and returns default if key doesn't exist",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#dictionary-methods",
    "href": "chapter-05-dictionaries-sets.html#dictionary-methods",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.3 5.2 Dictionary Methods",
    "text": "6.3 5.2 Dictionary Methods\n\n6.3.1 Common Dictionary Methods\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Get keys, values, items\nkeys = person.keys()      # dict_keys(['name', 'age', 'city'])\nvalues = person.values()  # dict_values(['Alice', 25, 'NYC'])\nitems = person.items()    # dict_items([('name', 'Alice'), ...])\n\n# Convert to lists\nkey_list = list(person.keys())  # ['name', 'age', 'city']\n\n# Get with default\nemail = person.get(\"email\", \"N/A\")  # \"N/A\"\n\n# Set default if missing\nperson.setdefault(\"country\", \"USA\")  # Adds if not exists\n\n# Update dictionary\nperson.update({\"email\": \"alice@example.com\", \"age\": 26})\n\n# Remove items\nage = person.pop(\"age\")        # Remove and return value\nperson.pop(\"email\", None)      # Safe removal with default\ndel person[\"city\"]             # Remove (raises KeyError if missing)\nperson.clear()                 # Remove all items\n\n# Copy dictionary\ncopy = person.copy()  # Shallow copy\n\n\n\n6.3.2 Error Type 2: TypeError: unhashable type: 'list'\nError Message:\n&gt;&gt;&gt; data = {[1, 2]: \"value\"}\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\nWhat Happened: You tried to use a mutable object (like list or dict) as a dictionary key.\nWhy It Happens: - Using list as key - Using dict as key - Using set as key - Mutable objects can‚Äôt be keys\nCode Example - WRONG:\n# List as key\ndata = {[1, 2]: \"value\"}  # ERROR! Lists are mutable\n\n# Dictionary as key\ndata = {{\"a\": 1}: \"value\"}  # ERROR! Dicts are mutable\n\n# Set as key\ndata = {{1, 2}: \"value\"}  # ERROR! Sets are mutable\n\n# Variable holding mutable\nkey = [1, 2, 3]\ndata = {key: \"value\"}  # ERROR! key is a list\nCode Example - CORRECT:\n# Use tuple instead of list (tuples are immutable)\ndata = {(1, 2): \"value\"}  # ‚úì Tuples work as keys\nprint(data[(1, 2)])  # \"value\"\n\n# Use frozenset instead of set\ndata = {frozenset([1, 2]): \"value\"}  # ‚úì Frozen sets work\n\n# Convert list to tuple\nkey_list = [1, 2, 3]\ndata = {tuple(key_list): \"value\"}  # ‚úì Convert to tuple\n\n# Immutable types that work as keys:\ndata = {\n    42: \"int\",              # ‚úì int\n    3.14: \"float\",          # ‚úì float\n    \"key\": \"string\",        # ‚úì string\n    (1, 2): \"tuple\",        # ‚úì tuple\n    True: \"bool\",           # ‚úì bool\n    frozenset([1]): \"fs\"    # ‚úì frozenset\n}\n\n# Use string representation if you must use mutable\nkey_list = [1, 2, 3]\nkey = str(key_list)  # \"[1, 2, 3]\"\ndata = {key: \"value\"}  # ‚úì String key\n\n# Or use tuple of sorted items for dict\noriginal = {\"b\": 2, \"a\": 1}\nkey = tuple(sorted(original.items()))\ndata = {key: \"value\"}  # ‚úì\n\n# Store complex keys as tuples\n# Instead of: {[x, y]: value}\ncoordinates = {(10, 20): \"point1\", (30, 40): \"point2\"}  # ‚úì\nHashable vs Unhashable:\n# HASHABLE (can be dictionary keys):\n# - int, float, string, tuple, bool, frozenset\n# - Immutable objects\n\n# UNHASHABLE (cannot be dictionary keys):\n# - list, dict, set\n# - Mutable objects\n\n# Test if something is hashable\ntry:\n    hash([1, 2, 3])\nexcept TypeError:\n    print(\"Unhashable\")  # Lists are unhashable\n\nhash((1, 2, 3))  # ‚úì Works - tuples are hashable",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#dictionary-iteration",
    "href": "chapter-05-dictionaries-sets.html#dictionary-iteration",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.4 5.3 Dictionary Iteration",
    "text": "6.4 5.3 Dictionary Iteration\n\n6.4.1 Iterating Over Dictionaries\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Iterate over keys (default)\nfor key in person:\n    print(key)  # name, age, city\n\n# Explicit keys\nfor key in person.keys():\n    print(key)\n\n# Iterate over values\nfor value in person.values():\n    print(value)  # Alice, 25, NYC\n\n# Iterate over key-value pairs\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n# name: Alice\n# age: 25\n# city: NYC\n\n\n\n6.4.2 Error Type 3: RuntimeError: dictionary changed size during iteration\nError Message:\n&gt;&gt;&gt; person = {\"name\": \"Alice\", \"age\": 25}\n&gt;&gt;&gt; for key in person:\n...     if key == \"age\":\n...         del person[key]\nRuntimeError: dictionary changed size during iteration\nWhat Happened: You tried to modify a dictionary while iterating over it.\nWhy It Happens: - Adding keys during iteration - Removing keys during iteration - Modifying dictionary size while looping\nCode Example - WRONG:\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Deleting during iteration\nfor key in person:\n    if key == \"age\":\n        del person[key]  # ERROR! Can't modify during iteration\n\n# Adding during iteration\nfor key in person:\n    if key == \"name\":\n        person[\"email\"] = \"alice@example.com\"  # ERROR!\n\n# Popping during iteration\nfor key in person:\n    person.pop(key)  # ERROR!\nCode Example - CORRECT:\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Create list of keys first\nfor key in list(person.keys()):  # ‚úì Convert to list\n    if key == \"age\":\n        del person[key]\n\n# Or collect keys to delete\nkeys_to_delete = []\nfor key in person:\n    if key == \"age\":\n        keys_to_delete.append(key)\n\nfor key in keys_to_delete:\n    del person[key]  # ‚úì Delete after iteration\n\n# Use dictionary comprehension to filter\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\nperson = {k: v for k, v in person.items() if k != \"age\"}  # ‚úì\n# Result: {\"name\": \"Alice\", \"city\": \"NYC\"}\n\n# Safe modification of values (not keys) is OK\nfor key in person:\n    person[key] = str(person[key]).upper()  # ‚úì Modifying values OK\n# Result: {\"name\": \"ALICE\", \"city\": \"NYC\"}\n\n# Create new dictionary with modifications\nnew_person = {}\nfor key, value in person.items():\n    if key != \"age\":\n        new_person[key] = value  # ‚úì\n\n# Use copy for safe iteration\nfor key in person.copy():  # ‚úì Iterate over copy\n    if key == \"age\":\n        del person[key]",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#set-basics",
    "href": "chapter-05-dictionaries-sets.html#set-basics",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.5 5.4 Set Basics",
    "text": "6.5 5.4 Set Basics\n\n6.5.1 Creating and Using Sets\n# Creating sets\nnumbers = {1, 2, 3, 4, 5}\nnames = {\"Alice\", \"Bob\", \"Charlie\"}\n\n# Empty set (must use set(), not {})\nempty = set()  # ‚úì Empty set\n# empty = {}  # This creates empty dict, not set!\n\n# Set from list (removes duplicates)\nnumbers = set([1, 2, 2, 3, 3, 3])  # {1, 2, 3}\n\n# Adding elements\nnumbers.add(6)  # {1, 2, 3, 6}\n\n# Removing elements\nnumbers.remove(2)    # Raises KeyError if not found\nnumbers.discard(2)   # No error if not found\npopped = numbers.pop()  # Remove and return arbitrary element\n\n# Set length\nlength = len(numbers)\n\n# Check membership\nif 3 in numbers:\n    print(\"Found 3\")\n\n\n\n6.5.2 Error Type 4: KeyError in Sets\nError Message:\n&gt;&gt;&gt; numbers = {1, 2, 3}\n&gt;&gt;&gt; numbers.remove(5)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 5\nWhat Happened: You tried to remove an element that doesn‚Äôt exist in the set.\nWhy It Happens: - Using remove() on non-existent item - Already removed item - Wrong value or type\nCode Example - WRONG:\nnumbers = {1, 2, 3}\n\n# Remove non-existent item\nnumbers.remove(5)  # ERROR! 5 not in set\n\n# Type mismatch\nnumbers.remove(\"1\")  # ERROR! \"1\" != 1\n\n# Already removed\nnumbers.remove(2)  # OK first time\nnumbers.remove(2)  # ERROR! Already removed\nCode Example - CORRECT:\nnumbers = {1, 2, 3}\n\n# Check before removing\nif 5 in numbers:\n    numbers.remove(5)\nelse:\n    print(\"5 not in set\")\n\n# Use discard() instead (never raises error)\nnumbers.discard(5)  # ‚úì No error if not found\nnumbers.discard(2)  # ‚úì Removes 2\nnumbers.discard(2)  # ‚úì No error, already gone\n\n# Use try/except\ntry:\n    numbers.remove(5)\nexcept KeyError:\n    print(\"Item not found\")\n\n# Match type\nnumbers = {1, 2, 3}\nnumbers.discard(1)  # ‚úì Use int, not string\n\n# Remove all matching items\nto_remove = {2, 5, 7}\nnumbers = numbers - to_remove  # ‚úì Creates new set\n# Only removes items that exist\nSet Methods Comparison:\nnumbers = {1, 2, 3}\n\n# remove() - raises KeyError if not found\nnumbers.remove(2)  # ‚úì OK\nnumbers.remove(5)  # ‚úó KeyError\n\n# discard() - never raises error\nnumbers.discard(2)  # ‚úì OK\nnumbers.discard(5)  # ‚úì OK (no error)\n\n# pop() - removes and returns arbitrary element\nvalue = numbers.pop()  # ‚úì Removes one element\n# On empty set:\nempty = set()\n# empty.pop()  # KeyError: 'pop from an empty set'\n\n# clear() - removes all elements\nnumbers.clear()  # {}, now empty",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#set-operations",
    "href": "chapter-05-dictionaries-sets.html#set-operations",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.6 5.5 Set Operations",
    "text": "6.6 5.5 Set Operations\n\n6.6.1 Mathematical Set Operations\nset1 = {1, 2, 3, 4}\nset2 = {3, 4, 5, 6}\n\n# Union (all elements from both sets)\nunion = set1 | set2  # {1, 2, 3, 4, 5, 6}\nunion = set1.union(set2)  # Same\n\n# Intersection (elements in both sets)\nintersection = set1 & set2  # {3, 4}\nintersection = set1.intersection(set2)  # Same\n\n# Difference (elements in set1 but not set2)\ndifference = set1 - set2  # {1, 2}\ndifference = set1.difference(set2)  # Same\n\n# Symmetric difference (elements in either but not both)\nsym_diff = set1 ^ set2  # {1, 2, 5, 6}\nsym_diff = set1.symmetric_difference(set2)  # Same\n\n# Subset and superset\nis_subset = {1, 2}.issubset({1, 2, 3})  # True\nis_superset = {1, 2, 3}.issuperset({1, 2})  # True\n\n# Disjoint (no common elements)\nare_disjoint = {1, 2}.isdisjoint({3, 4})  # True\n\n\n\n6.6.2 Error Type 5: TypeError: unhashable type in Sets\nError Message:\n&gt;&gt;&gt; numbers = {1, 2, [3, 4]}\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\nWhat Happened: You tried to add a mutable object to a set.\nWhy It Happens: - Adding list to set - Adding dict to set - Adding set to set - Set elements must be immutable\nCode Example - WRONG:\n# List in set\nnumbers = {1, 2, [3, 4]}  # ERROR! Lists are mutable\n\n# Dict in set\ndata = {1, 2, {\"a\": 1}}  # ERROR! Dicts are mutable\n\n# Set in set\nnested = {1, 2, {3, 4}}  # ERROR! Sets are mutable\n\n# Adding mutable element\nnumbers = {1, 2, 3}\nnumbers.add([4, 5])  # ERROR!\nCode Example - CORRECT:\n# Use tuple instead of list\nnumbers = {1, 2, (3, 4)}  # ‚úì Tuples are immutable\nprint(numbers)  # {1, 2, (3, 4)}\n\n# Use frozenset instead of set\nnested = {1, 2, frozenset([3, 4])}  # ‚úì Frozen sets work\nprint(nested)  # {1, 2, frozenset({3, 4})}\n\n# Convert before adding\nnumbers = {1, 2, 3}\nto_add = [4, 5]\nnumbers.add(tuple(to_add))  # ‚úì\n# {1, 2, 3, (4, 5)}\n\n# Only immutable types work\nvalid_set = {\n    42,              # ‚úì int\n    3.14,            # ‚úì float\n    \"hello\",         # ‚úì string\n    (1, 2),          # ‚úì tuple\n    True,            # ‚úì bool\n    frozenset([1])   # ‚úì frozenset\n}\n\n# For lists of items, store as tuples\ncoordinates = {(0, 0), (1, 1), (2, 2)}  # ‚úì\n\n# Or convert to strings if needed\nitems = {str([1, 2]), str([3, 4])}  # ‚úì\n# {'[1, 2]', '[3, 4]'}",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#common-dictionary-and-set-patterns",
    "href": "chapter-05-dictionaries-sets.html#common-dictionary-and-set-patterns",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.7 5.6 Common Dictionary and Set Patterns",
    "text": "6.7 5.6 Common Dictionary and Set Patterns\n\n6.7.1 Useful Patterns\n# Counting items\nwords = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\", \"apple\"]\ncount = {}\nfor word in words:\n    count[word] = count.get(word, 0) + 1\n# {'apple': 3, 'banana': 2, 'cherry': 1}\n\n# Or use setdefault\ncount = {}\nfor word in words:\n    count.setdefault(word, 0)\n    count[word] += 1\n\n# Or use Counter (better)\nfrom collections import Counter\ncount = Counter(words)\n\n# Grouping items\npeople = [\n    {\"name\": \"Alice\", \"age\": 25},\n    {\"name\": \"Bob\", \"age\": 30},\n    {\"name\": \"Charlie\", \"age\": 25}\n]\nby_age = {}\nfor person in people:\n    age = person[\"age\"]\n    if age not in by_age:\n        by_age[age] = []\n    by_age[age].append(person[\"name\"])\n# {25: ['Alice', 'Charlie'], 30: ['Bob']}\n\n# Remove duplicates while preserving order\nitems = [1, 2, 2, 3, 1, 4, 3]\nunique = list(dict.fromkeys(items))  # [1, 2, 3, 4]\n\n# Merge dictionaries (Python 3.9+)\ndict1 = {\"a\": 1, \"b\": 2}\ndict2 = {\"c\": 3, \"d\": 4}\nmerged = dict1 | dict2  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\n# Or use update\nmerged = dict1.copy()\nmerged.update(dict2)\n\n# Invert dictionary (swap keys and values)\noriginal = {\"a\": 1, \"b\": 2, \"c\": 3}\ninverted = {v: k for k, v in original.items()}\n# {1: 'a', 2: 'b', 3: 'c'}\n\n# Find common elements\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\ncommon = set(list1) & set(list2)  # {4, 5}\n\n# Find unique elements\nunique_to_list1 = set(list1) - set(list2)  # {1, 2, 3}",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#practice-problems---fix-these-errors",
    "href": "chapter-05-dictionaries-sets.html#practice-problems---fix-these-errors",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.8 5.7 Practice Problems - Fix These Errors!",
    "text": "6.8 5.7 Practice Problems - Fix These Errors!\n\n6.8.1 Problem 1: KeyError\nperson = {\"name\": \"Alice\", \"age\": 25}\nprint(person[\"email\"])\n\n\nClick for Answer\n\nError: KeyError: 'email'\nWhy: ‚Äúemail‚Äù key doesn‚Äôt exist\nFix:\nperson = {\"name\": \"Alice\", \"age\": 25}\n\n# Use .get() with default\nprint(person.get(\"email\", \"N/A\"))  # ‚úì Prints: N/A\n\n# Or check first\nif \"email\" in person:\n    print(person[\"email\"])\nelse:\n    print(\"Email not found\")  # ‚úì\n\n\n\n\n6.8.2 Problem 2: Unhashable Type\ndata = {[1, 2]: \"value\"}\n\n\nClick for Answer\n\nError: TypeError: unhashable type: 'list'\nWhy: Lists can‚Äôt be dictionary keys (they‚Äôre mutable)\nFix:\n# Use tuple instead\ndata = {(1, 2): \"value\"}  # ‚úì Tuples work as keys\nprint(data[(1, 2)])  # \"value\"\n\n\n\n\n6.8.3 Problem 3: Modifying During Iteration\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\nfor key in person:\n    if key == \"age\":\n        del person[key]\n\n\nClick for Answer\n\nError: RuntimeError: dictionary changed size during iteration\nWhy: Can‚Äôt modify dictionary size while iterating\nFix:\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Iterate over list of keys\nfor key in list(person.keys()):  # ‚úì Convert to list\n    if key == \"age\":\n        del person[key]\n\n# Or use dictionary comprehension\nperson = {k: v for k, v in person.items() if k != \"age\"}  # ‚úì\n\n\n\n\n6.8.4 Problem 4: Set Remove Error\nnumbers = {1, 2, 3}\nnumbers.remove(5)\n\n\nClick for Answer\n\nError: KeyError: 5\nWhy: 5 doesn‚Äôt exist in the set\nFix:\nnumbers = {1, 2, 3}\n\n# Use discard instead (no error if not found)\nnumbers.discard(5)  # ‚úì No error\n\n# Or check first\nif 5 in numbers:\n    numbers.remove(5)\nelse:\n    print(\"5 not in set\")  # ‚úì\n\n\n\n\n6.8.5 Problem 5: Empty Set Creation\nempty = {}\nempty.add(1)\n\n\nClick for Answer\n\nError: AttributeError: 'dict' object has no attribute 'add'\nWhy: {} creates empty dict, not empty set\nFix:\n# Use set() for empty set\nempty = set()  # ‚úì Empty set\nempty.add(1)   # ‚úì Works\nprint(empty)   # {1}\n\n# {} creates empty dictionary\nempty_dict = {}  # ‚úì Empty dict\nempty_dict[\"key\"] = \"value\"  # ‚úì Works for dict",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#key-takeaways",
    "href": "chapter-05-dictionaries-sets.html#key-takeaways",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.9 5.8 Key Takeaways",
    "text": "6.9 5.8 Key Takeaways\n\n6.9.1 What You Learned\n\nUse .get() for safe dictionary access - Returns None instead of KeyError\nOnly immutable types as dict keys - Use tuples, not lists\nDon‚Äôt modify dict during iteration - Create list of keys first\nUse discard() for safe set removal - No error if item not found\nEmpty set needs set() - {} creates empty dict\nCheck membership with in - Before accessing or removing\nSets automatically remove duplicates - Great for unique items\n\n\n\n6.9.2 Common Patterns\n# Pattern 1: Safe dictionary access\nvalue = data.get(\"key\", default_value)\n\n# Pattern 2: Check before access\nif \"key\" in data:\n    value = data[\"key\"]\n\n# Pattern 3: Safe iteration modification\nfor key in list(data.keys()):\n    if condition:\n        del data[key]\n\n# Pattern 4: Safe set removal\nnumbers.discard(item)  # No error\n\n# Pattern 5: Remove duplicates\nunique = list(set(items))\n\n# Pattern 6: Count occurrences\ncount = {}\nfor item in items:\n    count[item] = count.get(item, 0) + 1\n\n\n6.9.3 Error Summary Table\n\n\n\n\n\n\n\n\nError Type\nCommon Cause\nPrevention\n\n\n\n\nKeyError (dict)\nNon-existent key\nUse .get() or check with in\n\n\nTypeError (unhashable)\nMutable key/element\nUse immutable types (tuple, frozenset)\n\n\nRuntimeError\nModifying during iteration\nIterate over list(dict.keys())\n\n\nKeyError (set)\nRemove non-existent item\nUse discard() instead of remove()",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-05-dictionaries-sets.html#moving-forward",
    "href": "chapter-05-dictionaries-sets.html#moving-forward",
    "title": "6¬† Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors",
    "section": "6.10 5.9 Moving Forward",
    "text": "6.10 5.9 Moving Forward\nYou now understand dictionaries and sets. You can: - Access dictionary values safely - Use correct types for keys - Iterate and modify safely - Perform set operations - Handle unique collections\nIn Chapter 6, we‚Äôll explore Tuples and Immutability - understanding immutable sequences!",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Chapter 5: Dictionaries and Sets - Key-Value and Unique Collection Errors</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html",
    "href": "chapter-06-tuples-immutability.html",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "",
    "text": "7.1 Introduction\nYou‚Äôve mastered lists and dictionaries. Now let‚Äôs explore tuples - immutable sequences that look similar to lists but behave very differently.\nTuples are ordered collections like lists, but once created, they cannot be modified. This immutability makes them useful for data that shouldn‚Äôt change and as dictionary keys.\nCommon errors: - TypeError: Trying to modify tuples - AttributeError: Using list methods on tuples - Unpacking errors - Index errors (similar to lists)\nLet‚Äôs master tuples by understanding their errors!",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#tuple-basics",
    "href": "chapter-06-tuples-immutability.html#tuple-basics",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.2 6.1 Tuple Basics",
    "text": "7.2 6.1 Tuple Basics\n\n7.2.1 Creating and Using Tuples\n# Creating tuples\ncoordinates = (10, 20)\nperson = (\"Alice\", 25, \"NYC\")\ncolors = (\"red\", \"green\", \"blue\")\n\n# Single element tuple (comma is required!)\nsingle = (5,)    # ‚úì Tuple with one element\nnot_tuple = (5)  # Just the number 5, not a tuple!\n\n# Empty tuple\nempty = ()\nempty = tuple()\n\n# Tuple without parentheses (tuple packing)\npoint = 10, 20, 30  # (10, 20, 30)\n\n# Accessing elements (like lists)\nfirst = coordinates[0]   # 10\nlast = coordinates[-1]   # 20\n\n# Tuple length\nlength = len(person)  # 3\n\n# Check membership\nif \"Alice\" in person:\n    print(\"Found Alice\")\n\n# Slicing (returns new tuple)\nsubset = colors[1:]  # ('green', 'blue')\n\n\n\n7.2.2 Error Type 1: TypeError: 'tuple' object does not support item assignment\nError Message:\n&gt;&gt;&gt; coordinates = (10, 20)\n&gt;&gt;&gt; coordinates[0] = 15\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\nWhat Happened: You tried to modify a tuple. Tuples are immutable - they cannot be changed after creation.\nWhy It Happens: - Trying to change tuple elements - Treating tuple like a list - Not understanding immutability - Trying to use mutating methods\nCode Example - WRONG:\ncoordinates = (10, 20)\n\n# Can't modify elements\ncoordinates[0] = 15  # ERROR! Tuples are immutable\n\n# Can't delete elements\ndel coordinates[0]  # ERROR! Can't delete from tuple\n\n# Can't append\ncoordinates.append(30)  # ERROR! No append method\n\n# Can't extend\ncoordinates.extend([30, 40])  # ERROR! No extend method\n\n# Can't remove\ncoordinates.remove(10)  # ERROR! No remove method\n\n# Can't use list methods\ncoordinates.insert(0, 5)  # ERROR! No insert method\ncoordinates.pop()  # ERROR! No pop method\ncoordinates.reverse()  # ERROR! No reverse method\ncoordinates.sort()  # ERROR! No sort method\nCode Example - CORRECT:\ncoordinates = (10, 20)\n\n# Create new tuple with changes\ncoordinates = (15, 20)  # ‚úì New tuple\n\n# Concatenate tuples (creates new tuple)\ncoordinates = coordinates + (30,)  # ‚úì (15, 20, 30)\n\n# Concatenate multiple\ncoordinates = coordinates + (40, 50)  # ‚úì (15, 20, 30, 40, 50)\n\n# Repeat tuples\nrepeated = (1, 2) * 3  # ‚úì (1, 2, 1, 2, 1, 2)\n\n# Convert to list, modify, convert back\ncoordinates = (10, 20, 30)\ntemp_list = list(coordinates)  # [10, 20, 30]\ntemp_list[0] = 15              # Modify list\ncoordinates = tuple(temp_list)  # ‚úì (15, 20, 30)\n\n# Build new tuple with comprehension\nnumbers = (1, 2, 3, 4, 5)\ndoubled = tuple(x * 2 for x in numbers)  # ‚úì (2, 4, 6, 8, 10)\n\n# Replace by slicing\ncoordinates = (10, 20, 30)\ncoordinates = (15,) + coordinates[1:]  # ‚úì (15, 20, 30)\n\n# Filter tuple\nnumbers = (1, 2, 3, 4, 5)\nevens = tuple(x for x in numbers if x % 2 == 0)  # ‚úì (2, 4)\n\n# Delete entire tuple (can delete the variable)\ncoordinates = (10, 20)\ndel coordinates  # ‚úì Deletes the variable, not just contents\nWhy Tuples Are Immutable:\n# Immutability benefits:\n# 1. Can be used as dictionary keys\nlocation_data = {\n    (10, 20): \"Point A\",\n    (30, 40): \"Point B\"\n}  # ‚úì Tuples work as keys\n\n# 2. Safer - can't be accidentally modified\ndef process_data(data):\n    # If data is a tuple, we know it won't change\n    return data[0] + data[1]\n\n# 3. Slightly faster than lists\n# 4. Can be used in sets\npoints = {(0, 0), (1, 1), (2, 2)}  # ‚úì Set of tuples\n\n# Lists can't do these:\n# {[0, 0], [1, 1]}  # ERROR! Lists can't be in sets\n# {[10, 20]: \"value\"}  # ERROR! Lists can't be dict keys",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#tuple-unpacking",
    "href": "chapter-06-tuples-immutability.html#tuple-unpacking",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.3 6.2 Tuple Unpacking",
    "text": "7.3 6.2 Tuple Unpacking\n\n7.3.1 Understanding Unpacking\n# Basic unpacking\ncoordinates = (10, 20)\nx, y = coordinates  # x=10, y=20\n\n# Multiple values\nperson = (\"Alice\", 25, \"NYC\")\nname, age, city = person\n\n# Swap values (elegant!)\na, b = 5, 10\na, b = b, a  # ‚úì a=10, b=5\n\n# Function returning multiple values\ndef get_coordinates():\n    return 10, 20  # Returns tuple (10, 20)\n\nx, y = get_coordinates()\n\n# Using * to capture remaining\nnumbers = (1, 2, 3, 4, 5)\nfirst, *rest = numbers  # first=1, rest=[2,3,4,5]\n*start, last = numbers  # start=[1,2,3,4], last=5\nfirst, *middle, last = numbers  # first=1, middle=[2,3,4], last=5\n\n\n\n7.3.2 Error Type 2: ValueError: too many values to unpack or not enough values to unpack\nError Message:\n&gt;&gt;&gt; coordinates = (10, 20, 30)\n&gt;&gt;&gt; x, y = coordinates\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: too many values to unpack (expected 2)\nWhat Happened: The number of variables doesn‚Äôt match the number of items in the tuple.\nWhy It Happens: - Too few variables for tuple items - Too many variables for tuple items - Wrong assumptions about tuple size - Function returns different number of values\nCode Example - WRONG:\n# Too many values in tuple\ncoordinates = (10, 20, 30)\nx, y = coordinates  # ERROR! 3 values, 2 variables\n\n# Too few values in tuple\ncoordinates = (10,)\nx, y = coordinates  # ERROR! 1 value, 2 variables\n\n# Wrong assumption about function return\ndef get_data():\n    return 1, 2, 3\n\na, b = get_data()  # ERROR! Returns 3, expecting 2\n\n# Empty tuple\ndata = ()\nx, y = data  # ERROR! No values to unpack\nCode Example - CORRECT:\n# Match number of variables to tuple size\ncoordinates = (10, 20, 30)\nx, y, z = coordinates  # ‚úì 3 values, 3 variables\n\n# Use underscore for unwanted values\nx, _, z = coordinates  # ‚úì Ignore middle value (y)\n\n# Use * to capture remaining\nfirst, *rest = coordinates  # ‚úì first=10, rest=[20,30]\n\n# Check length before unpacking\ncoordinates = (10, 20, 30)\nif len(coordinates) == 2:\n    x, y = coordinates\nelif len(coordinates) == 3:\n    x, y, z = coordinates\n\n# Safe unpacking with try/except\ntry:\n    x, y = coordinates\nexcept ValueError:\n    print(\"Wrong number of values\")\n    x, y = coordinates[0], coordinates[1]\n\n# Unpack with defaults\ndef safe_unpack(tup, count, default=None):\n    \"\"\"Safely unpack tuple with defaults\"\"\"\n    result = list(tup) + [default] * (count - len(tup))\n    return tuple(result[:count])\n\ncoordinates = (10, 20)\nx, y, z = safe_unpack(coordinates, 3, default=0)  # ‚úì x=10, y=20, z=0\n\n# Use indexing if unsure\ncoordinates = (10, 20, 30)\nx = coordinates[0] if len(coordinates) &gt; 0 else None\ny = coordinates[1] if len(coordinates) &gt; 1 else None\n\n# Unpack only what you need\ncoordinates = (10, 20, 30, 40, 50)\nx, y, *_ = coordinates  # ‚úì Get first two, ignore rest\n\n# Function with flexible return\ndef get_data():\n    return 1, 2, 3\n\n# Capture all with *\na, *rest = get_data()  # ‚úì a=1, rest=[2,3]\n\n# Or match exactly\na, b, c = get_data()  # ‚úì\nUnpacking Patterns:\n# Basic unpacking\nx, y = (10, 20)\n\n# Ignore values\nx, _ = (10, 20)  # Ignore second value\n_, y = (10, 20)  # Ignore first value\n\n# Extended unpacking (Python 3+)\nfirst, *middle, last = (1, 2, 3, 4, 5)\n# first=1, middle=[2,3,4], last=5\n\n# Nested unpacking\npoint = ((10, 20), (30, 40))\n(x1, y1), (x2, y2) = point\n# x1=10, y1=20, x2=30, y2=40\n\n# In loops\npairs = [(1, 2), (3, 4), (5, 6)]\nfor x, y in pairs:\n    print(f\"x={x}, y={y}\")\n\n# Dictionary items\nperson = {\"name\": \"Alice\", \"age\": 25}\nfor key, value in person.items():\n    print(f\"{key}: {value}\")",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#tuple-methods",
    "href": "chapter-06-tuples-immutability.html#tuple-methods",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.4 6.3 Tuple Methods",
    "text": "7.4 6.3 Tuple Methods\n\n7.4.1 Available Tuple Methods\n# Tuples have only 2 methods!\nnumbers = (1, 2, 3, 2, 4, 2, 5)\n\n# count() - count occurrences\ncount = numbers.count(2)  # 3\n\n# index() - find first occurrence\nindex = numbers.index(2)  # 1 (first occurrence)\nindex = numbers.index(4)  # 4\n\n# That's it! No other methods\n\n\n\n7.4.2 Error Type 3: AttributeError: 'tuple' object has no attribute 'X'\nError Message:\n&gt;&gt;&gt; numbers = (1, 2, 3)\n&gt;&gt;&gt; numbers.append(4)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'tuple' object has no attribute 'append'\nWhat Happened: You tried to use a list method on a tuple.\nWhy It Happens: - Confusing tuples with lists - Trying to use mutating methods - Typo in method name\nCode Example - WRONG:\nnumbers = (1, 2, 3)\n\n# List methods don't work on tuples\nnumbers.append(4)    # ERROR! No append\nnumbers.extend([4])  # ERROR! No extend\nnumbers.insert(0, 0) # ERROR! No insert\nnumbers.remove(2)    # ERROR! No remove\nnumbers.pop()        # ERROR! No pop\nnumbers.sort()       # ERROR! No sort\nnumbers.reverse()    # ERROR! No reverse\nnumbers.clear()      # ERROR! No clear\nCode Example - CORRECT:\nnumbers = (1, 2, 3)\n\n# Use the 2 available methods\ncount = numbers.count(2)  # ‚úì Returns 1\nindex = numbers.index(2)  # ‚úì Returns 1\n\n# For other operations, convert to list\nnumbers_list = list(numbers)  # [1, 2, 3]\nnumbers_list.append(4)        # ‚úì Works on list\nnumbers = tuple(numbers_list) # ‚úì Convert back (1, 2, 3, 4)\n\n# Or create new tuple\nnumbers = numbers + (4,)  # ‚úì (1, 2, 3, 4)\n\n# Sort: use sorted() function (returns list)\nnumbers = (3, 1, 4, 1, 5)\nsorted_list = sorted(numbers)    # [1, 1, 3, 4, 5]\nsorted_tuple = tuple(sorted(numbers))  # ‚úì (1, 1, 3, 4, 5)\n\n# Reverse: use reversed() or slicing\nreversed_list = list(reversed(numbers))  # [5, 1, 4, 1, 3]\nreversed_tuple = numbers[::-1]  # ‚úì (5, 1, 4, 1, 3)\n\n# Filter\nnumbers = (1, 2, 3, 4, 5)\nevens = tuple(x for x in numbers if x % 2 == 0)  # ‚úì (2, 4)\n\n# Map\ndoubled = tuple(x * 2 for x in numbers)  # ‚úì (2, 4, 6, 8, 10)\n\n# Check method exists\nif hasattr(numbers, 'count'):\n    result = numbers.count(2)  # ‚úì\nTuple vs List Methods:\n# List has many methods:\nmy_list = [1, 2, 3]\nmy_list.append(4)      # ‚úì\nmy_list.extend([5, 6]) # ‚úì\nmy_list.insert(0, 0)   # ‚úì\nmy_list.remove(2)      # ‚úì\nmy_list.pop()          # ‚úì\nmy_list.sort()         # ‚úì\nmy_list.reverse()      # ‚úì\nmy_list.clear()        # ‚úì\n\n# Tuple has only 2:\nmy_tuple = (1, 2, 3)\nmy_tuple.count(2)   # ‚úì\nmy_tuple.index(2)   # ‚úì\n# That's all!",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#when-to-use-tuples-vs-lists",
    "href": "chapter-06-tuples-immutability.html#when-to-use-tuples-vs-lists",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.5 6.4 When to Use Tuples vs Lists",
    "text": "7.5 6.4 When to Use Tuples vs Lists\n\n7.5.1 Choosing the Right Collection\n# Use TUPLES when:\n# 1. Data shouldn't change\ncoordinates = (10, 20)  # Position shouldn't change\ndate = (2025, 10, 27)   # Date is fixed\n\n# 2. Need to use as dictionary key\nlocations = {\n    (0, 0): \"Origin\",\n    (10, 20): \"Point A\"\n}\n\n# 3. Need to use in set\npoints = {(0, 0), (1, 1), (2, 2)}\n\n# 4. Returning multiple values from function\ndef get_stats():\n    return 10, 25, 5  # min, max, avg\n\n# 5. Data has fixed structure\nperson = (\"Alice\", 25, \"NYC\")  # name, age, city\n\n# Use LISTS when:\n# 1. Data will change\nscores = [85, 90, 92]\nscores.append(88)  # Need to add items\n\n# 2. Need to sort/modify\nnumbers = [3, 1, 4, 1, 5]\nnumbers.sort()  # Need to sort\n\n# 3. Collection of same type items\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nnames.remove(\"Bob\")  # May need to remove\n\n# 4. Don't need immutability\ntemperatures = [72, 75, 68, 70]\ntemperatures[0] = 73  # May need to update",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#named-tuples",
    "href": "chapter-06-tuples-immutability.html#named-tuples",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.6 6.5 Named Tuples",
    "text": "7.6 6.5 Named Tuples\n\n7.6.1 Using Named Tuples for Clarity\nfrom collections import namedtuple\n\n# Define named tuple type\nPoint = namedtuple('Point', ['x', 'y'])\n\n# Create instance\np = Point(10, 20)\n\n# Access by name (more readable)\nprint(p.x)  # 10\nprint(p.y)  # 20\n\n# Or by index (still works)\nprint(p[0])  # 10\nprint(p[1])  # 20\n\n# Still immutable\n# p.x = 15  # ERROR! Can't modify\n\n# More examples\nPerson = namedtuple('Person', ['name', 'age', 'city'])\nperson = Person('Alice', 25, 'NYC')\nprint(person.name)  # Alice\nprint(person.age)   # 25\n\n# Unpack like regular tuple\nname, age, city = person\n\n# Convert to dict\nperson_dict = person._asdict()\n# {'name': 'Alice', 'age': 25, 'city': 'NYC'}",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#mutable-objects-in-tuples",
    "href": "chapter-06-tuples-immutability.html#mutable-objects-in-tuples",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.7 6.6 Mutable Objects in Tuples",
    "text": "7.7 6.6 Mutable Objects in Tuples\n\n7.7.1 Understanding Nested Mutability\n# Tuple itself is immutable\n# But it can contain mutable objects!\n\ndata = ([1, 2, 3], [4, 5, 6])\n\n# Can't change tuple structure\n# data[0] = [7, 8, 9]  # ERROR!\n\n# But CAN modify the lists inside\ndata[0].append(4)  # ‚úì Works!\nprint(data)  # ([1, 2, 3, 4], [4, 5, 6])\n\n# Another example\nperson = (\"Alice\", 25, [\"Python\", \"Java\"])\n\n# Can't change tuple\n# person[0] = \"Bob\"  # ERROR!\n\n# But can modify the list inside\nperson[2].append(\"C++\")  # ‚úì\nprint(person)  # (\"Alice\", 25, [\"Python\", \"Java\", \"C++\"])\n\n# This is important for dictionary keys\n# Tuple with mutable objects can't be dict key\nskills = [\"Python\", \"Java\"]\n# data = {(\"Alice\", skills): \"value\"}  # ERROR if you modify skills later\n\n# Use immutable contents for dict keys\ndata = {(\"Alice\", \"Python\", \"Java\"): \"value\"}  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#practice-problems---fix-these-errors",
    "href": "chapter-06-tuples-immutability.html#practice-problems---fix-these-errors",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.8 6.7 Practice Problems - Fix These Errors!",
    "text": "7.8 6.7 Practice Problems - Fix These Errors!\n\n7.8.1 Problem 1: Tuple Modification\ncolors = (\"red\", \"green\", \"blue\")\ncolors[0] = \"yellow\"\n\n\nClick for Answer\n\nError: TypeError: 'tuple' object does not support item assignment\nWhy: Tuples are immutable\nFix:\ncolors = (\"red\", \"green\", \"blue\")\n\n# Create new tuple\ncolors = (\"yellow\", \"green\", \"blue\")  # ‚úì\n\n# Or use concatenation\ncolors = (\"yellow\",) + colors[1:]  # ‚úì\nprint(colors)  # (\"yellow\", \"green\", \"blue\")\n\n\n\n\n7.8.2 Problem 2: Wrong Unpacking\ncoordinates = (10, 20, 30)\nx, y = coordinates\n\n\nClick for Answer\n\nError: ValueError: too many values to unpack (expected 2)\nWhy: 3 values but only 2 variables\nFix:\ncoordinates = (10, 20, 30)\n\n# Match number of variables\nx, y, z = coordinates  # ‚úì\n\n# Or ignore extra values\nx, y, *_ = coordinates  # ‚úì x=10, y=20, ignore z\n\n# Or just take what you need\nx, y = coordinates[:2]  # ‚úì x=10, y=20\n\n\n\n\n7.8.3 Problem 3: Using List Method\nnumbers = (1, 2, 3)\nnumbers.append(4)\n\n\nClick for Answer\n\nError: AttributeError: 'tuple' object has no attribute 'append'\nWhy: Tuples don‚Äôt have append method\nFix:\nnumbers = (1, 2, 3)\n\n# Create new tuple with concatenation\nnumbers = numbers + (4,)  # ‚úì\nprint(numbers)  # (1, 2, 3, 4)\n\n# Or convert to list, modify, convert back\ntemp = list(numbers)\ntemp.append(4)\nnumbers = tuple(temp)  # ‚úì\n\n\n\n\n7.8.4 Problem 4: Single Element Tuple\nsingle = (5)\nprint(type(single))\nprint(len(single))\n\n\nClick for Answer\n\nIssue: This creates an int, not a tuple!\nWhy: Parentheses alone don‚Äôt make tuple, need comma\nFix:\n# Need comma for single element tuple\nsingle = (5,)  # ‚úì Notice the comma\nprint(type(single))  # &lt;class 'tuple'&gt;\nprint(len(single))   # 1\n\n# Or without parentheses\nsingle = 5,  # ‚úì Also works\nprint(type(single))  # &lt;class 'tuple'&gt;\n\n\n\n\n7.8.5 Problem 5: Empty Unpacking\ndata = ()\nx, y = data\n\n\nClick for Answer\n\nError: ValueError: not enough values to unpack (expected 2, got 0)\nWhy: Empty tuple has no values\nFix:\ndata = ()\n\n# Check before unpacking\nif len(data) &gt;= 2:\n    x, y = data\nelse:\n    x, y = None, None  # ‚úì Default values\n\n# Or use try/except\ntry:\n    x, y = data\nexcept ValueError:\n    x, y = None, None  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#key-takeaways",
    "href": "chapter-06-tuples-immutability.html#key-takeaways",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.9 6.8 Key Takeaways",
    "text": "7.9 6.8 Key Takeaways\n\n7.9.1 What You Learned\n\nTuples are immutable - Cannot be modified after creation\nOnly 2 methods - count() and index()\nComma makes tuple - (5,) not (5) for single element\nMatch unpacking variables - Same number as tuple items\nUse as dict keys - Unlike lists, tuples can be keys\nCreate new tuples - Use + or slicing instead of modifying\nNamed tuples - More readable than regular tuples\n\n\n\n7.9.2 Common Patterns\n# Pattern 1: Create new instead of modify\nold_tuple = (1, 2, 3)\nnew_tuple = old_tuple + (4,)\n\n# Pattern 2: Convert, modify, convert back\ntemp = list(my_tuple)\ntemp.append(new_item)\nmy_tuple = tuple(temp)\n\n# Pattern 3: Safe unpacking\nfirst, *rest = my_tuple\n\n# Pattern 4: Swap values\na, b = b, a\n\n# Pattern 5: Multiple return values\ndef get_data():\n    return value1, value2, value3\n\n\n7.9.3 Error Summary Table\n\n\n\n\n\n\n\n\nError Type\nCommon Cause\nPrevention\n\n\n\n\nTypeError (assignment)\nTrying to modify tuple\nCreate new tuple instead\n\n\nAttributeError\nUsing list methods\nOnly use count() and index()\n\n\nValueError (unpacking)\nWrong number of variables\nMatch count or use *\n\n\nSingle element\nMissing comma\nUse (value,) not (value)",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-06-tuples-immutability.html#moving-forward",
    "href": "chapter-06-tuples-immutability.html#moving-forward",
    "title": "7¬† Chapter 6: Tuples and Immutability - Understanding Immutable Sequences",
    "section": "7.10 6.9 Moving Forward",
    "text": "7.10 6.9 Moving Forward\nYou now understand tuples and immutability. You can: - Use tuples appropriately - Unpack values safely - Understand when to use tuples vs lists - Work with immutable data - Use tuples as dictionary keys\nIn Chapter 7, we‚Äôll explore Conditional Statements - if/elif/else and logical flow!",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Chapter 6: Tuples and Immutability - Understanding Immutable Sequences</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html",
    "href": "chapter-07-conditional-statements.html",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "",
    "text": "8.1 Introduction\nYou‚Äôve mastered data structures. Now let‚Äôs explore conditional statements - the foundation of program logic. Conditionals let your code make decisions and execute different code based on conditions.\nCommon errors: - IndentationError: Wrong indentation in Python - SyntaxError: Wrong syntax in if/elif/else - NameError: Variables not defined - Logic errors (wrong conditions)\nConditionals control program flow. Let‚Äôs master them!",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#if-statement-basics",
    "href": "chapter-07-conditional-statements.html#if-statement-basics",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.2 7.1 If Statement Basics",
    "text": "8.2 7.1 If Statement Basics\n\n8.2.1 Simple If Statements\n# Basic if statement\nage = 18\nif age &gt;= 18:\n    print(\"Adult\")\n\n# If with else\nage = 15\nif age &gt;= 18:\n    print(\"Adult\")\nelse:\n    print(\"Minor\")\n\n# If with elif\nscore = 85\nif score &gt;= 90:\n    print(\"A\")\nelif score &gt;= 80:\n    print(\"B\")\nelif score &gt;= 70:\n    print(\"C\")\nelse:\n    print(\"F\")\n\n# Multiple conditions\nage = 25\nhas_license = True\nif age &gt;= 18 and has_license:\n    print(\"Can drive\")\n\n\n\n8.2.2 Error Type 1: IndentationError: expected an indented block\nError Message:\n&gt;&gt;&gt; if True:\n... print(\"Hello\")\n  File \"&lt;stdin&gt;\", line 2\n    print(\"Hello\")\n    ^\nIndentationError: expected an indented block\nWhat Happened: Python requires indentation after if statements. The code block must be indented.\nWhy It Happens: - Missing indentation - Inconsistent indentation (tabs vs spaces) - Wrong indentation level - Copy-paste errors\nCode Example - WRONG:\n# No indentation\nif True:\nprint(\"Hello\")  # ERROR! Must be indented\n\n# Inconsistent indentation\nif True:\n    print(\"Line 1\")  # 4 spaces\n  print(\"Line 2\")    # ERROR! 2 spaces\n\n# Tab and space mixing\nif True:\n    print(\"Tab\")    # Tab character\n    print(\"Spaces\")  # ERROR! Spaces (looks same but different)\n\n# Wrong else indentation\nif True:\n    print(\"If block\")\n  else:  # ERROR! else should align with if\n    print(\"Else block\")\n\n# Empty if block\nif True:\n# ERROR! Need pass or code\n\n# Multiple levels wrong\nif True:\n    if True:\n    print(\"Wrong\")  # ERROR! Should be indented more\nCode Example - CORRECT:\n# Proper indentation (4 spaces is standard)\nif True:\n    print(\"Hello\")  # ‚úì Indented 4 spaces\n\n# Consistent indentation\nif True:\n    print(\"Line 1\")  # 4 spaces\n    print(\"Line 2\")  # 4 spaces ‚úì\n\n# Correct else alignment\nif True:\n    print(\"If block\")\nelse:  # ‚úì Aligned with if\n    print(\"Else block\")\n\n# Empty if block - use pass\nif True:\n    pass  # ‚úì Placeholder\n\n# Multiple levels\nif True:\n    print(\"Level 1\")\n    if True:\n        print(\"Level 2\")  # ‚úì Indented further\n\n# Elif alignment\nif score &gt;= 90:\n    print(\"A\")\nelif score &gt;= 80:  # ‚úì Aligned with if\n    print(\"B\")\nelse:  # ‚úì Aligned with if\n    print(\"F\")\n\n# Configure editor:\n# - Use spaces, not tabs\n# - Set indent to 4 spaces\n# - Enable \"show whitespace\" to see issues\nPython Indentation Rules:\n# Standard is 4 spaces per level\nif condition:\n    # Level 1 (4 spaces)\n    if nested_condition:\n        # Level 2 (8 spaces)\n        print(\"Nested\")\n    print(\"Level 1\")\n\n# All lines in same block must have same indentation\nif True:\n    print(\"Line 1\")  # 4 spaces\n    print(\"Line 2\")  # 4 spaces ‚úì\n    # print(\"Line 3\")  # Comment - indentation doesn't matter\n\n# Control structures need indentation\nif True:\n    print(\"If\")\nelse:\n    print(\"Else\")\n\nfor i in range(3):\n    print(i)\n\nwhile True:\n    break\n\ndef function():\n    return\n\nclass MyClass:\n    pass",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#comparison-operators",
    "href": "chapter-07-conditional-statements.html#comparison-operators",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.3 7.2 Comparison Operators",
    "text": "8.3 7.2 Comparison Operators\n\n8.3.1 Using Comparisons Correctly\n# Comparison operators\nx = 10\n\n# Equal\nx == 10  # True\n\n# Not equal\nx != 5   # True\n\n# Greater/less than\nx &gt; 5    # True\nx &lt; 20   # True\nx &gt;= 10  # True\nx &lt;= 10  # True\n\n# Chaining comparisons\n5 &lt; x &lt; 15  # True (same as: 5 &lt; x and x &lt; 15)\n\n\n\n8.3.2 Error Type 2: SyntaxError: invalid syntax (in conditions)\nError Message:\n&gt;&gt;&gt; if x = 10:\n  File \"&lt;stdin&gt;\", line 1\n    if x = 10:\n         ^\nSyntaxError: invalid syntax\nWhat Happened: Using assignment (=) instead of comparison (==) in condition.\nWhy It Happens: - Confusing = and == - Missing colon after condition - Wrong operator - Incomplete condition\nCode Example - WRONG:\nx = 10\n\n# Assignment instead of comparison\nif x = 10:  # ERROR! Use ==, not =\n    print(\"Ten\")\n\n# Missing colon\nif x == 10  # ERROR! Missing :\n    print(\"Ten\")\n\n# Wrong syntax\nif x == 10 and:  # ERROR! Incomplete condition\n    print(\"Ten\")\n\n# Chaining without variable\nif 5 &lt; x &lt; and x &lt; 15:  # ERROR! Incomplete\n    print(\"Range\")\n\n# Using 'is' for value comparison\nif x is 10:  # Wrong! Use == for values\n    print(\"Ten\")  # May not work as expected\n\n# Missing condition entirely\nif:  # ERROR! Need condition\n    print(\"Hello\")\nCode Example - CORRECT:\nx = 10\n\n# Use == for comparison\nif x == 10:  # ‚úì Comparison\n    print(\"Ten\")\n\n# Include colon\nif x == 10:  # ‚úì Colon required\n    print(\"Ten\")\n\n# Complete conditions\nif x == 10 and x &gt; 0:  # ‚úì Complete\n    print(\"Ten and positive\")\n\n# Proper chaining\nif 5 &lt; x &lt; 15:  # ‚úì\n    print(\"In range\")\n\n# Or explicit\nif x &gt; 5 and x &lt; 15:  # ‚úì Also works\n    print(\"In range\")\n\n# Use == for value comparison\nif x == 10:  # ‚úì Correct for values\n    print(\"Ten\")\n\n# Use 'is' only for None, True, False\nif x is None:  # ‚úì Correct for None\n    print(\"None\")\n\nif x is True:  # ‚úì Correct for True/False\n    print(\"True\")\n\n# Parentheses for clarity (optional but helpful)\nif (x &gt; 5) and (x &lt; 15):  # ‚úì Very clear\n    print(\"In range\")\n\n# Multiple conditions\nif x &gt; 0 and x &lt; 100 and x % 2 == 0:  # ‚úì\n    print(\"Even number between 0 and 100\")\nComparison Operators Reference:\n# All comparison operators:\n==  # Equal to\n!=  # Not equal to\n&lt;   # Less than\n&gt;   # Greater than\n&lt;=  # Less than or equal to\n&gt;=  # Greater than or equal to\n\n# Identity operators:\nis      # Same object (use for None, True, False)\nis not  # Different object\n\n# Membership operators:\nin      # Item in collection\nnot in  # Item not in collection\n\n# Examples:\nx == 5          # Value comparison\nx is None       # Identity comparison\n\"a\" in \"apple\"  # Membership test\nx not in [1,2]  # Negative membership",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#logical-operators",
    "href": "chapter-07-conditional-statements.html#logical-operators",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.4 7.3 Logical Operators",
    "text": "8.4 7.3 Logical Operators\n\n8.4.1 Combining Conditions\n# AND - both must be True\nif age &gt;= 18 and has_license:\n    print(\"Can drive\")\n\n# OR - at least one must be True\nif is_weekend or is_holiday:\n    print(\"Day off\")\n\n# NOT - reverses boolean\nif not is_raining:\n    print(\"Go outside\")\n\n# Complex combinations\nif (age &gt;= 18 and has_license) or is_instructor:\n    print(\"Can drive\")\n\n# Short-circuit evaluation\nif user is not None and user.is_active():\n    # user.is_active() only called if user is not None\n    print(\"Active user\")\n\n\n\n8.4.2 Error Type 3: Logic Errors (No Python Error)\nWhat Happened: Code runs but produces wrong results due to incorrect logic.\nCode Example - WRONG LOGIC:\n# Wrong order of checks\nscore = 85\nif score &gt;= 70:\n    print(\"C\")  # Prints \"C\" even though should be \"B\"\nelif score &gt;= 80:\n    print(\"B\")  # Never reached!\nelif score &gt;= 90:\n    print(\"A\")  # Never reached!\n\n# Wrong operator\nage = 25\nif age &gt; 18:  # Should be &gt;=\n    print(\"Adult\")  # Excludes 18-year-olds\n\n# Missing parentheses\nif x &gt; 5 and y &gt; 3 or z &gt; 10:\n    # Evaluated as: (x &gt; 5 and y &gt; 3) or z &gt; 10\n    # Might not be what you want!\n    print(\"Condition met\")\n\n# Using 'is' instead of ==\nx = 1000\ny = 1000\nif x is y:  # False (different objects)\n    print(\"Same\")  # Doesn't print (wrong!)\n\n# Comparing strings case-sensitively\nname = \"Alice\"\nif name == \"alice\":  # False due to case\n    print(\"Match\")  # Doesn't print\nCode Example - CORRECT:\n# Correct order (most specific first)\nscore = 85\nif score &gt;= 90:\n    print(\"A\")\nelif score &gt;= 80:\n    print(\"B\")  # ‚úì Prints correctly\nelif score &gt;= 70:\n    print(\"C\")\nelse:\n    print(\"F\")\n\n# Correct operator (&gt;= includes 18)\nage = 18\nif age &gt;= 18:  # ‚úì Includes 18\n    print(\"Adult\")\n\n# Use parentheses for clarity\nif (x &gt; 5 and y &gt; 3) or z &gt; 10:  # ‚úì Clear intent\n    print(\"Condition met\")\n\n# Use == for value comparison\nx = 1000\ny = 1000\nif x == y:  # ‚úì True (same value)\n    print(\"Same\")\n\n# Case-insensitive string comparison\nname = \"Alice\"\nif name.lower() == \"alice\":  # ‚úì True\n    print(\"Match\")\n\n# Handle None safely\nvalue = None\nif value is None:  # ‚úì Correct\n    print(\"No value\")\n\n# Check type and value\nif isinstance(x, int) and x &gt; 0:  # ‚úì Safe\n    print(\"Positive integer\")\n\n# Multiple conditions with clear logic\nage = 25\nhas_license = True\nhas_insurance = True\nif age &gt;= 18:\n    if has_license and has_insurance:\n        print(\"Can drive\")  # ‚úì Clear logic\n    else:\n        print(\"Need license or insurance\")\nelse:\n    print(\"Too young\")",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#truthiness-and-falsiness",
    "href": "chapter-07-conditional-statements.html#truthiness-and-falsiness",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.5 7.4 Truthiness and Falsiness",
    "text": "8.5 7.4 Truthiness and Falsiness\n\n8.5.1 Understanding Boolean Context\n# Falsy values (evaluate to False)\nif False:        pass  # False\nif None:         pass  # None\nif 0:            pass  # Zero\nif 0.0:          pass  # Zero float\nif \"\":           pass  # Empty string\nif []:           pass  # Empty list\nif {}:           pass  # Empty dict\nif set():        pass  # Empty set\nif ():           pass  # Empty tuple\n\n# Truthy values (everything else)\nif True:         pass  # ‚úì True\nif 1:            pass  # ‚úì Non-zero number\nif \"text\":       pass  # ‚úì Non-empty string\nif [1]:          pass  # ‚úì Non-empty list\nif {\"a\": 1}:     pass  # ‚úì Non-empty dict\n\n# Common patterns\n# Check if list has items\nitems = [1, 2, 3]\nif items:  # ‚úì True if not empty\n    print(\"Has items\")\n\n# Check if string is not empty\ntext = \"hello\"\nif text:  # ‚úì True if not empty\n    print(\"Has text\")\n\n# Check if variable is not None\nvalue = 10\nif value is not None:  # ‚úì Explicit None check\n    print(\"Has value\")\n\n# Be careful with zero\ncount = 0\nif count:  # False! 0 is falsy\n    print(\"Has count\")  # Won't print\n\n# Better:\nif count is not None:  # ‚úì True even if count is 0\n    print(\"Has count\")\n\n\n\n8.5.2 Error Type 4: Truthiness Pitfalls\nCode Example - WRONG LOGIC:\n# Treating zero as \"no value\"\ncount = 0\nif count:  # False - treats 0 as falsy\n    print(f\"Count: {count}\")  # Doesn't print (wrong!)\n\n# Confusing empty string with None\ntext = \"\"\nif text:  # False - empty string is falsy\n    print(text)  # Doesn't print\nelse:\n    text = \"Default\"  # Sets default even if string was intentionally empty\n\n# Not checking type\nvalue = []\nif value:  # False - empty list is falsy\n    print(\"Has value\")  # Doesn't print even though list exists\n\n# Using boolean literal comparison\nis_valid = True\nif is_valid == True:  # Works but verbose\n    print(\"Valid\")\nCode Example - CORRECT:\n# Check for None explicitly when zero is valid\ncount = 0\nif count is not None:  # ‚úì True even if count is 0\n    print(f\"Count: {count}\")  # Prints \"Count: 0\"\n\n# Or check the specific range you want\nif count &gt;= 0:  # ‚úì Explicitly check non-negative\n    print(f\"Count: {count}\")\n\n# Distinguish empty string from None\ntext = \"\"\nif text is not None:  # ‚úì True even if empty string\n    print(f\"Text: '{text}'\")  # Prints \"Text: ''\"\n\n# Check type and content separately\nvalue = []\nif value is not None:  # ‚úì List exists\n    if value:  # ‚úì List has items\n        print(\"Has items\")\n    else:\n        print(\"Empty list\")  # ‚úì\n\n# Direct boolean check (more Pythonic)\nis_valid = True\nif is_valid:  # ‚úì Cleaner\n    print(\"Valid\")\n\n# Check length explicitly\nitems = []\nif len(items) &gt; 0:  # ‚úì Explicit check\n    print(\"Has items\")\n\n# Or direct\nif items:  # ‚úì Also works for non-empty check\n    print(\"Has items\")",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#ternary-operator",
    "href": "chapter-07-conditional-statements.html#ternary-operator",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.6 7.5 Ternary Operator",
    "text": "8.6 7.5 Ternary Operator\n\n8.6.1 Conditional Expressions\n# Traditional if/else\nif x &gt; 0:\n    result = \"positive\"\nelse:\n    result = \"non-positive\"\n\n# Ternary operator (conditional expression)\nresult = \"positive\" if x &gt; 0 else \"non-positive\"\n\n# More examples\nstatus = \"adult\" if age &gt;= 18 else \"minor\"\n\nmax_value = a if a &gt; b else b\n\nmessage = \"Even\" if x % 2 == 0 else \"Odd\"\n\n# Nested ternary (avoid if too complex)\ngrade = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\"\n\n\n\n8.6.2 Error Type 5: Ternary Syntax Errors\nCode Example - WRONG:\n# Wrong order\nresult = if x &gt; 0 \"positive\" else \"negative\"  # ERROR! Syntax wrong\n\n# Missing parts\nresult = \"positive\" if x &gt; 0  # ERROR! Missing else\n\n# Wrong keyword\nresult = \"positive\" when x &gt; 0 else \"negative\"  # ERROR! Use 'if'\n\n# Too complex (hard to read)\nresult = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\" if score &gt;= 70 else \"D\" if score &gt;= 60 else \"F\"\n# Technically works but hard to read!\nCode Example - CORRECT:\n# Correct ternary syntax\nresult = \"positive\" if x &gt; 0 else \"negative\"  # ‚úì\n\n# With else (required)\nresult = \"positive\" if x &gt; 0 else \"non-positive\"  # ‚úì\n\n# Correct keyword (if, not when)\nresult = \"positive\" if x &gt; 0 else \"negative\"  # ‚úì\n\n# Complex logic - use regular if/else instead\nif score &gt;= 90:\n    grade = \"A\"\nelif score &gt;= 80:\n    grade = \"B\"\nelif score &gt;= 70:\n    grade = \"C\"\nelif score &gt;= 60:\n    grade = \"D\"\nelse:\n    grade = \"F\"\n# ‚úì Much more readable!\n\n# Good ternary uses (simple, readable)\nstatus = \"online\" if is_connected else \"offline\"  # ‚úì\nsign = \"+\" if x &gt;= 0 else \"-\"  # ‚úì\ncolor = \"red\" if temp &gt; 30 else \"blue\"  # ‚úì\n\n# Ternary with function calls\nresult = process_data() if data else default_value()  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#common-conditional-patterns",
    "href": "chapter-07-conditional-statements.html#common-conditional-patterns",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.7 7.6 Common Conditional Patterns",
    "text": "8.7 7.6 Common Conditional Patterns\n\n8.7.1 Useful Patterns\n# Check multiple conditions\nif x and y and z:\n    print(\"All true\")\n\n# Check any condition\nif x or y or z:\n    print(\"At least one true\")\n\n# Range checking\nif 0 &lt;= score &lt;= 100:\n    print(\"Valid score\")\n\n# Membership testing\nif item in collection:\n    print(\"Found\")\n\n# Type checking\nif isinstance(value, int):\n    print(\"Integer\")\n\n# None checking\nif value is None:\n    print(\"No value\")\n\n# Empty checking\nif not items:\n    print(\"Empty\")\n\n# Combining checks\nif value is not None and value &gt; 0:\n    print(\"Positive value\")\n\n# Guard clauses (early return)\ndef process(data):\n    if not data:\n        return  # Exit early\n    if not valid(data):\n        return  # Exit early\n    # Main logic here\n    return result",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#practice-problems---fix-these-errors",
    "href": "chapter-07-conditional-statements.html#practice-problems---fix-these-errors",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.8 7.7 Practice Problems - Fix These Errors!",
    "text": "8.8 7.7 Practice Problems - Fix These Errors!\n\n8.8.1 Problem 1: Indentation Error\nif True:\nprint(\"Hello\")\n\n\nClick for Answer\n\nError: IndentationError: expected an indented block\nWhy: Code after if must be indented\nFix:\nif True:\n    print(\"Hello\")  # ‚úì Indented 4 spaces\n\n\n\n\n8.8.2 Problem 2: Assignment in Condition\nx = 10\nif x = 10:\n    print(\"Ten\")\n\n\nClick for Answer\n\nError: SyntaxError: invalid syntax\nWhy: Using = (assignment) instead of == (comparison)\nFix:\nx = 10\nif x == 10:  # ‚úì Use == for comparison\n    print(\"Ten\")\n\n\n\n\n8.8.3 Problem 3: Wrong Logic Order\nscore = 85\nif score &gt;= 70:\n    grade = \"C\"\nelif score &gt;= 80:\n    grade = \"B\"\nelif score &gt;= 90:\n    grade = \"A\"\nprint(grade)\n\n\nClick for Answer\n\nIssue: Prints ‚ÄúC‚Äù instead of ‚ÄúB‚Äù (logic error)\nWhy: Checks are in wrong order (70 before 80)\nFix:\nscore = 85\n# Check highest first\nif score &gt;= 90:\n    grade = \"A\"\nelif score &gt;= 80:\n    grade = \"B\"  # ‚úì Now this is checked\nelif score &gt;= 70:\n    grade = \"C\"\nelse:\n    grade = \"F\"\nprint(grade)  # Prints \"B\"\n\n\n\n\n8.8.4 Problem 4: Truthiness Error\ncount = 0\nif count:\n    print(f\"Count is {count}\")\nelse:\n    print(\"No count\")\n\n\nClick for Answer\n\nIssue: Prints ‚ÄúNo count‚Äù even though count is 0 (a valid value)\nWhy: 0 is falsy in Python\nFix:\ncount = 0\nif count is not None:  # ‚úì Check for None explicitly\n    print(f\"Count is {count}\")  # Prints \"Count is 0\"\nelse:\n    print(\"No count\")\n\n# Or check specific range\nif count &gt;= 0:  # ‚úì Check for non-negative\n    print(f\"Count is {count}\")\n\n\n\n\n8.8.5 Problem 5: Missing Colon\nif x &gt; 5\n    print(\"Greater than 5\")\n\n\nClick for Answer\n\nError: SyntaxError: invalid syntax\nWhy: Missing colon after condition\nFix:\nif x &gt; 5:  # ‚úì Add colon\n    print(\"Greater than 5\")",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#key-takeaways",
    "href": "chapter-07-conditional-statements.html#key-takeaways",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.9 7.8 Key Takeaways",
    "text": "8.9 7.8 Key Takeaways\n\n8.9.1 What You Learned\n\nIndent code blocks - 4 spaces after if/elif/else\nUse == for comparison - Not = (assignment)\nOrder matters - Check most specific conditions first\nUse ‚Äòis‚Äô for None - Not == for None checks\nUnderstand truthiness - Empty collections are falsy\nInclude colon - After every condition\nUse parentheses - For complex conditions\n\n\n\n8.9.2 Common Patterns\n# Pattern 1: Range check\nif 0 &lt;= value &lt;= 100:\n    pass\n\n# Pattern 2: None check\nif value is not None:\n    pass\n\n# Pattern 3: Empty check\nif not items:\n    pass\n\n# Pattern 4: Safe chaining\nif user and user.is_active():\n    pass\n\n# Pattern 5: Multiple conditions\nif condition1 and condition2:\n    pass\n\n\n8.9.3 Error Summary Table\n\n\n\n\n\n\n\n\nError Type\nCommon Cause\nPrevention\n\n\n\n\nIndentationError\nMissing/wrong indentation\nUse 4 spaces consistently\n\n\nSyntaxError\nUsing = instead of ==\nUse == for comparison\n\n\nSyntaxError\nMissing colon\nAdd : after condition\n\n\nLogic errors\nWrong order/operators\nCheck most specific first",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-07-conditional-statements.html#moving-forward",
    "href": "chapter-07-conditional-statements.html#moving-forward",
    "title": "8¬† Chapter 7: Conditional Statements - Logic and Flow Control Errors",
    "section": "8.10 7.9 Moving Forward",
    "text": "8.10 7.9 Moving Forward\nYou now understand conditional statements. You can: - Write if/elif/else correctly - Use proper indentation - Compare values accurately - Handle None and empty values - Write clear logic\nIn Chapter 8, we‚Äôll explore Loops - for and while loops for iteration!",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Chapter 7: Conditional Statements - Logic and Flow Control Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html",
    "href": "chapter-08-loops.html",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "",
    "text": "9.1 Introduction\nYou‚Äôve mastered conditionals. Now let‚Äôs explore loops - repeating code multiple times. Loops are essential for processing collections, repeating tasks, and iterating over data.\nCommon errors: - IndexError: Invalid indices in loops - StopIteration: Iterator exhausted - KeyError: Dictionary iteration errors - Infinite loops - Off-by-one errors\nLet‚Äôs master loops!",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#for-loop-basics",
    "href": "chapter-08-loops.html#for-loop-basics",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.2 8.1 For Loop Basics",
    "text": "9.2 8.1 For Loop Basics\n\n9.2.1 Iterating Over Collections\n# Loop over list\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    print(num)\n\n# Loop over string\nfor char in \"hello\":\n    print(char)\n\n# Loop over dictionary keys\nperson = {\"name\": \"Alice\", \"age\": 25}\nfor key in person:\n    print(key)\n\n# Loop over dictionary items\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n\n# Loop with range\nfor i in range(5):  # 0, 1, 2, 3, 4\n    print(i)\n\n# Range with start and stop\nfor i in range(1, 6):  # 1, 2, 3, 4, 5\n    print(i)\n\n# Range with step\nfor i in range(0, 10, 2):  # 0, 2, 4, 6, 8\n    print(i)\n\n\n\n9.2.2 Error Type 1: IndexError in Loops\nError Message:\n&gt;&gt;&gt; numbers = [1, 2, 3]\n&gt;&gt;&gt; for i in range(len(numbers) + 1):\n...     print(numbers[i])\n1\n2\n3\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nIndexError: list index out of range\nWhat Happened: Loop index goes beyond list length.\nWhy It Happens: - Using range(len(list) + 1) - Off-by-one errors - Modifying list during iteration - Wrong range bounds\nCode Example - WRONG:\nnumbers = [1, 2, 3]\n\n# Loop too far\nfor i in range(len(numbers) + 1):\n    print(numbers[i])  # ERROR when i=3\n\n# Starting at wrong index\nfor i in range(1, len(numbers) + 1):\n    print(numbers[i])  # ERROR when i=3\n\n# Modifying list during iteration\nfor i in range(len(numbers)):\n    numbers.append(i)  # ERROR! Changes length during loop\n    print(numbers[i])\n\n# Wrong understanding of range\nfor i in range(5):\n    print(numbers[i])  # ERROR if list has &lt; 5 items\nCode Example - CORRECT:\nnumbers = [1, 2, 3]\n\n# Correct range (no +1)\nfor i in range(len(numbers)):  # ‚úì 0, 1, 2\n    print(numbers[i])\n\n# Better: iterate directly (no indexing)\nfor num in numbers:  # ‚úì No index errors possible\n    print(num)\n\n# With enumerate for index and value\nfor i, num in enumerate(numbers):\n    print(f\"Index {i}: {num}\")  # ‚úì\n\n# Correct start index\nfor i in range(len(numbers)):  # ‚úì Starts at 0\n    print(f\"Index {i}: {numbers[i]}\")\n\n# Don't modify during iteration\n# Instead, iterate over copy\nfor num in numbers.copy():  # ‚úì Iterate over copy\n    numbers.append(num * 2)\n\n# Or collect changes, apply later\nto_add = []\nfor num in numbers:\n    to_add.append(num * 2)\nnumbers.extend(to_add)  # ‚úì Add after loop\n\n# Check bounds\nfor i in range(min(5, len(numbers))):  # ‚úì Safe\n    print(numbers[i])\nLoop Best Practices:\nnumbers = [1, 2, 3, 4, 5]\n\n# BEST: Direct iteration (no indexing)\nfor num in numbers:\n    print(num)  # ‚úì Simplest, safest\n\n# GOOD: enumerate when you need index\nfor i, num in enumerate(numbers):\n    print(f\"{i}: {num}\")  # ‚úì\n\n# AVOID: range(len(...)) unless necessary\nfor i in range(len(numbers)):\n    print(numbers[i])  # Works but verbose\n\n# NEVER: range(len(...) + 1)\n# for i in range(len(numbers) + 1):  # ‚úó Common error",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#while-loops",
    "href": "chapter-08-loops.html#while-loops",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.3 8.2 While Loops",
    "text": "9.3 8.2 While Loops\n\n9.3.1 Condition-Based Iteration\n# Basic while loop\ncount = 0\nwhile count &lt; 5:\n    print(count)\n    count += 1\n\n# While with break\nwhile True:\n    response = input(\"Enter 'quit' to exit: \")\n    if response == \"quit\":\n        break\n\n# While with continue\ncount = 0\nwhile count &lt; 10:\n    count += 1\n    if count % 2 == 0:\n        continue  # Skip even numbers\n    print(count)\n\n\n\n9.3.2 Error Type 2: Infinite Loops\nWhat Happened: Loop never ends because condition stays True.\nWhy It Happens: - Forgetting to update condition - Wrong condition logic - Never reaching break statement\nCode Example - WRONG:\n# Forgot to update variable\ncount = 0\nwhile count &lt; 5:\n    print(count)  # Prints 0 forever!\n    # ERROR! Forgot: count += 1\n\n# Wrong condition\ncount = 0\nwhile count != 5:\n    count += 2  # 0, 2, 4, 6, 8... never equals 5!\n    print(count)  # Infinite loop!\n\n# Condition never becomes False\nwhile True:\n    print(\"Forever!\")  # ERROR! No break\n\n# Break never reached\ncount = 0\nwhile count &lt; 10:\n    print(count)\n    if count &gt; 20:  # Never true!\n        break\n    # Forgot to increment count!\nCode Example - CORRECT:\n# Update variable in loop\ncount = 0\nwhile count &lt; 5:\n    print(count)\n    count += 1  # ‚úì Updates condition variable\n\n# Use correct condition\ncount = 0\nwhile count &lt; 5:  # ‚úì Use &lt;, not !=\n    print(count)\n    count += 2\n\n# Include break for True loops\nwhile True:\n    response = input(\"Enter 'quit': \")\n    if response == \"quit\":\n        break  # ‚úì Can exit\n\n# Ensure break is reachable\ncount = 0\nwhile count &lt; 100:  # Safety limit\n    print(count)\n    if count &gt;= 10:\n        break  # ‚úì Reachable\n    count += 1\n\n# Add safety counter\ncount = 0\nmax_iterations = 1000\nwhile condition and count &lt; max_iterations:\n    # Loop body\n    count += 1  # ‚úì Safety limit\n\n# Use for loop when count is known\nfor i in range(5):  # ‚úì Better than while for fixed iterations\n    print(i)",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#break-and-continue",
    "href": "chapter-08-loops.html#break-and-continue",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.4 8.3 Break and Continue",
    "text": "9.4 8.3 Break and Continue\n\n9.4.1 Controlling Loop Flow\n# break - exit loop immediately\nfor i in range(10):\n    if i == 5:\n        break  # Exit loop when i is 5\n    print(i)  # Prints 0, 1, 2, 3, 4\n\n# continue - skip to next iteration\nfor i in range(5):\n    if i == 2:\n        continue  # Skip when i is 2\n    print(i)  # Prints 0, 1, 3, 4\n\n# break in nested loops (only exits inner loop)\nfor i in range(3):\n    for j in range(3):\n        if j == 1:\n            break  # Only exits inner loop\n        print(f\"{i},{j}\")\n\n# Using else with loops (runs if no break)\nfor i in range(5):\n    if i == 10:\n        break\nelse:\n    print(\"Loop completed\")  # Prints because no break",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#iterating-over-dictionaries",
    "href": "chapter-08-loops.html#iterating-over-dictionaries",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.5 8.4 Iterating Over Dictionaries",
    "text": "9.5 8.4 Iterating Over Dictionaries\n\n9.5.1 Dictionary Iteration Patterns\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Iterate over keys (default)\nfor key in person:\n    print(key)\n\n# Explicit keys\nfor key in person.keys():\n    print(key)\n\n# Iterate over values\nfor value in person.values():\n    print(value)\n\n# Iterate over key-value pairs (BEST)\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n\n\n\n9.5.2 Error Type 3: RuntimeError: dictionary changed size during iteration\nError Message:\n&gt;&gt;&gt; person = {\"name\": \"Alice\", \"age\": 25}\n&gt;&gt;&gt; for key in person:\n...     if key == \"age\":\n...         del person[key]\nRuntimeError: dictionary changed size during iteration\nWhat Happened: Cannot modify dictionary size while iterating.\nCode Example - WRONG:\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Deleting during iteration\nfor key in person:\n    if key == \"age\":\n        del person[key]  # ERROR!\n\n# Adding during iteration\nfor key in person:\n    if key == \"name\":\n        person[\"email\"] = \"alice@example.com\"  # ERROR!\nCode Example - CORRECT:\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Iterate over list of keys\nfor key in list(person.keys()):  # ‚úì Convert to list\n    if key == \"age\":\n        del person[key]\n\n# Collect keys to delete\nto_delete = []\nfor key in person:\n    if key == \"age\":\n        to_delete.append(key)\n\nfor key in to_delete:\n    del person[key]  # ‚úì\n\n# Dictionary comprehension\nperson = {k: v for k, v in person.items() if k != \"age\"}  # ‚úì\n\n# Modifying values is OK\nfor key in person:\n    person[key] = str(person[key]).upper()  # ‚úì Values OK",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#enumerate-and-zip",
    "href": "chapter-08-loops.html#enumerate-and-zip",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.6 8.5 Enumerate and Zip",
    "text": "9.6 8.5 Enumerate and Zip\n\n9.6.1 Advanced Iteration\n# enumerate - get index and value\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nfor i, name in enumerate(names):\n    print(f\"{i}: {name}\")\n# 0: Alice\n# 1: Bob\n# 2: Charlie\n\n# enumerate with custom start\nfor i, name in enumerate(names, start=1):\n    print(f\"{i}: {name}\")\n# 1: Alice\n# 2: Bob\n# 3: Charlie\n\n# zip - iterate over multiple lists\nnames = [\"Alice\", \"Bob\"]\nages = [25, 30]\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age}\")\n# Alice is 25\n# Bob is 30\n\n# zip with different lengths (stops at shortest)\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b']\nfor num, letter in zip(list1, list2):\n    print(num, letter)\n# 1 a\n# 2 b\n# (3 is ignored)",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#list-comprehensions-vs-loops",
    "href": "chapter-08-loops.html#list-comprehensions-vs-loops",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.7 8.6 List Comprehensions vs Loops",
    "text": "9.7 8.6 List Comprehensions vs Loops\n\n9.7.1 Comparing Approaches\n# Traditional loop\nsquares = []\nfor x in range(5):\n    squares.append(x ** 2)\n# [0, 1, 4, 9, 16]\n\n# List comprehension (better)\nsquares = [x ** 2 for x in range(5)]  # ‚úì\n\n# With condition\nevens = []\nfor x in range(10):\n    if x % 2 == 0:\n        evens.append(x)\n\n# Better\nevens = [x for x in range(10) if x % 2 == 0]  # ‚úì\n\n# When to use loops vs comprehensions:\n# Use comprehension: Simple transformations, filters\n# Use loop: Complex logic, multiple statements, side effects",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#common-loop-patterns",
    "href": "chapter-08-loops.html#common-loop-patterns",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.8 8.7 Common Loop Patterns",
    "text": "9.8 8.7 Common Loop Patterns\n\n9.8.1 Useful Patterns\n# Sum all numbers\nnumbers = [1, 2, 3, 4, 5]\ntotal = 0\nfor num in numbers:\n    total += num\n# Or: total = sum(numbers)\n\n# Find maximum\nmax_val = numbers[0]\nfor num in numbers[1:]:\n    if num &gt; max_val:\n        max_val = num\n# Or: max_val = max(numbers)\n\n# Count occurrences\nitems = [1, 2, 2, 3, 2, 4]\ncount = 0\nfor item in items:\n    if item == 2:\n        count += 1\n# Or: count = items.count(2)\n\n# Build string\nwords = [\"Hello\", \"World\"]\nresult = \"\"\nfor word in words:\n    result += word + \" \"\n# Better: result = \" \".join(words)\n\n# Filter items\nnumbers = [1, 2, 3, 4, 5, 6]\nevens = []\nfor num in numbers:\n    if num % 2 == 0:\n        evens.append(num)\n# Better: evens = [x for x in numbers if x % 2 == 0]",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#practice-problems",
    "href": "chapter-08-loops.html#practice-problems",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.9 8.8 Practice Problems",
    "text": "9.9 8.8 Practice Problems\n\n9.9.1 Problem 1: Index Error\nnumbers = [1, 2, 3]\nfor i in range(len(numbers) + 1):\n    print(numbers[i])\n\n\nClick for Answer\n\nError: IndexError: list index out of range\nFix:\nnumbers = [1, 2, 3]\nfor i in range(len(numbers)):  # ‚úì Remove +1\n    print(numbers[i])\n\n# Or better:\nfor num in numbers:  # ‚úì No indexing\n    print(num)\n\n\n\n\n9.9.2 Problem 2: Infinite Loop\ncount = 0\nwhile count &lt; 5:\n    print(count)\n\n\nClick for Answer\n\nIssue: Infinite loop - count never increments\nFix:\ncount = 0\nwhile count &lt; 5:\n    print(count)\n    count += 1  # ‚úì Update condition variable\n\n\n\n\n9.9.3 Problem 3: Dictionary Modification\ndata = {\"a\": 1, \"b\": 2, \"c\": 3}\nfor key in data:\n    if key == \"b\":\n        del data[key]\n\n\nClick for Answer\n\nError: RuntimeError: dictionary changed size during iteration\nFix:\ndata = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n# Convert keys to list\nfor key in list(data.keys()):  # ‚úì\n    if key == \"b\":\n        del data[key]\n\n# Or use dict comprehension\ndata = {k: v for k, v in data.items() if k != \"b\"}  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#key-takeaways",
    "href": "chapter-08-loops.html#key-takeaways",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.10 8.9 Key Takeaways",
    "text": "9.10 8.9 Key Takeaways\n\n9.10.1 What You Learned\n\nIterate directly - for item in list (avoid indexing)\nUse enumerate - When you need both index and value\nUpdate while conditions - Prevent infinite loops\nDon‚Äôt modify during iteration - Use list(dict.keys())\nUse break/continue - Control loop flow\nList comprehensions - For simple transformations\nrange(len()) - Usually not needed\n\n\n\n9.10.2 Common Patterns\n# Pattern 1: Direct iteration\nfor item in collection:\n    process(item)\n\n# Pattern 2: With index\nfor i, item in enumerate(collection):\n    print(f\"{i}: {item}\")\n\n# Pattern 3: Multiple lists\nfor x, y in zip(list1, list2):\n    print(x, y)\n\n# Pattern 4: Dictionary items\nfor key, value in dict.items():\n    print(f\"{key}: {value}\")\n\n# Pattern 5: Break on condition\nfor item in items:\n    if condition:\n        break\n\n\n9.10.3 Error Summary\n\n\n\nError\nCause\nPrevention\n\n\n\n\nIndexError\nrange(len()+1)\nUse range(len()) or iterate directly\n\n\nInfinite loop\nNo update\nUpdate condition variable\n\n\nRuntimeError\nModify dict\nUse list(dict.keys())",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-08-loops.html#moving-forward",
    "href": "chapter-08-loops.html#moving-forward",
    "title": "9¬† Chapter 8: Loops - Iteration Errors",
    "section": "9.11 8.10 Moving Forward",
    "text": "9.11 8.10 Moving Forward\nYou now understand loops! In Chapter 9, we‚Äôll explore Functions!",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Chapter 8: Loops - Iteration Errors</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html",
    "href": "chapter-09-functions.html",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "",
    "text": "10.1 Introduction\nYou‚Äôve mastered loops and conditionals. Now let‚Äôs explore functions - reusable blocks of code that perform specific tasks. Functions are fundamental to organizing and structuring programs.\nCommon errors: - TypeError: Wrong number or type of arguments - NameError: Function not defined or wrong scope - UnboundLocalError: Variable scope issues - RecursionError: Infinite recursion - Return value errors\nLet‚Äôs master functions!",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#function-basics",
    "href": "chapter-09-functions.html#function-basics",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.2 9.1 Function Basics",
    "text": "10.2 9.1 Function Basics\n\n10.2.1 Defining and Calling Functions\n# Basic function definition\ndef greet():\n    print(\"Hello!\")\n\n# Call the function\ngreet()  # Prints: Hello!\n\n# Function with parameters\ndef greet_person(name):\n    print(f\"Hello, {name}!\")\n\ngreet_person(\"Alice\")  # Prints: Hello, Alice!\n\n# Function with return value\ndef add(a, b):\n    return a + b\n\nresult = add(5, 3)  # result = 8\n\n# Function with multiple parameters\ndef calculate(x, y, operation):\n    if operation == \"add\":\n        return x + y\n    elif operation == \"multiply\":\n        return x * y\n\nresult = calculate(5, 3, \"add\")  # 8\n\n\n\n10.2.2 Error Type 1: TypeError: function() takes X positional arguments but Y were given\nError Message:\n&gt;&gt;&gt; def greet(name):\n...     print(f\"Hello, {name}!\")\n&gt;&gt;&gt; greet()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: greet() missing 1 required positional argument: 'name'\nWhat Happened: Called function with wrong number of arguments.\nWhy It Happens: - Missing required arguments - Too many arguments - Forgetting self in methods - Wrong parameter count\nCode Example - WRONG:\n# Missing argument\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet()  # ERROR! Missing 'name'\n\n# Too many arguments\ndef add(a, b):\n    return a + b\n\nresult = add(1, 2, 3)  # ERROR! Too many arguments\n\n# Wrong number of arguments\ndef calculate(x, y, z):\n    return x + y + z\n\nresult = calculate(1, 2)  # ERROR! Missing z\n\n# Mixing positional and keyword wrong\ndef process(a, b, c):\n    return a + b + c\n\nresult = process(1, c=3)  # ERROR! Missing b\nCode Example - CORRECT:\n# Provide all required arguments\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")  # ‚úì Correct\n\n# Match parameter count\ndef add(a, b):\n    return a + b\n\nresult = add(1, 2)  # ‚úì Correct\n\n# Use default parameters for optional arguments\ndef greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ngreet(\"Alice\")  # ‚úì Uses default: \"Hello, Alice!\"\ngreet(\"Bob\", \"Hi\")  # ‚úì Custom: \"Hi, Bob!\"\n\n# Use *args for variable arguments\ndef add_all(*numbers):\n    return sum(numbers)\n\nresult = add_all(1, 2)  # ‚úì Works\nresult = add_all(1, 2, 3, 4, 5)  # ‚úì Also works\n\n# Use **kwargs for keyword arguments\ndef print_info(**info):\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=25)  # ‚úì\n\n# Mix positional, default, *args, **kwargs\ndef complex_function(required, optional=\"default\", *args, **kwargs):\n    print(f\"Required: {required}\")\n    print(f\"Optional: {optional}\")\n    print(f\"Args: {args}\")\n    print(f\"Kwargs: {kwargs}\")\n\ncomplex_function(\"test\")  # ‚úì\ncomplex_function(\"test\", \"custom\", 1, 2, key=\"value\")  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#return-values",
    "href": "chapter-09-functions.html#return-values",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.3 9.2 Return Values",
    "text": "10.3 9.2 Return Values\n\n10.3.1 Understanding Returns\n# Function with return\ndef add(a, b):\n    return a + b\n\nresult = add(3, 5)  # result = 8\n\n# Function without return (returns None)\ndef greet(name):\n    print(f\"Hello, {name}!\")\n    # No return statement\n\nresult = greet(\"Alice\")  # result = None\n\n# Multiple return values (returns tuple)\ndef get_stats(numbers):\n    return min(numbers), max(numbers), sum(numbers)\n\nmin_val, max_val, total = get_stats([1, 2, 3, 4, 5])\n\n# Early return\ndef check_age(age):\n    if age &lt; 0:\n        return \"Invalid\"\n    if age &lt; 18:\n        return \"Minor\"\n    return \"Adult\"\n\n\n\n10.3.2 Error Type 2: TypeError: 'NoneType' object is not...\nError Message:\n&gt;&gt;&gt; def add(a, b):\n...     result = a + b\n...     # Forgot return!\n&gt;&gt;&gt; total = add(3, 5)\n&gt;&gt;&gt; print(total + 10)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'int'\nWhat Happened: Function returns None (no return statement), trying to use it.\nWhy It Happens: - Forgetting return statement - Return in wrong place - Conditional return missing else\nCode Example - WRONG:\n# Forgot return\ndef add(a, b):\n    result = a + b\n    # ERROR! No return\n\ntotal = add(3, 5)  # None\nprint(total + 10)  # ERROR! None + 10\n\n# Return in wrong place\ndef calculate(x):\n    if x &gt; 0:\n        return x * 2\n    # ERROR! No return for x &lt;= 0\n\nresult = calculate(-5)  # None\n\n# Indentation error\ndef multiply(a, b):\n    result = a * b\nreturn result  # ERROR! Wrong indentation\n\n# After return is unreachable\ndef process():\n    return \"done\"\n    print(\"After\")  # Never executes\nCode Example - CORRECT:\n# Include return statement\ndef add(a, b):\n    result = a + b\n    return result  # ‚úì\n\ntotal = add(3, 5)  # 8\nprint(total + 10)  # ‚úì 18\n\n# Return in all branches\ndef calculate(x):\n    if x &gt; 0:\n        return x * 2\n    else:\n        return 0  # ‚úì Return for all cases\n\n# Or single return at end\ndef calculate(x):\n    if x &gt; 0:\n        result = x * 2\n    else:\n        result = 0\n    return result  # ‚úì\n\n# Correct indentation\ndef multiply(a, b):\n    result = a * b\n    return result  # ‚úì Indented\n\n# Check for None before using\ndef get_value():\n    return None\n\nvalue = get_value()\nif value is not None:  # ‚úì Check first\n    print(value + 10)\nelse:\n    print(\"No value returned\")\n\n# Return default value\ndef safe_divide(a, b):\n    if b == 0:\n        return None\n    return a / b\n\nresult = safe_divide(10, 0)  # None\nif result is not None:  # ‚úì Safe\n    print(result)",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#variable-scope",
    "href": "chapter-09-functions.html#variable-scope",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.4 9.3 Variable Scope",
    "text": "10.4 9.3 Variable Scope\n\n10.4.1 Understanding Scope\n# Global variable\nglobal_var = \"I'm global\"\n\ndef function():\n    # Local variable\n    local_var = \"I'm local\"\n    print(global_var)  # ‚úì Can read global\n    print(local_var)   # ‚úì Can read local\n\nfunction()\n# print(local_var)  # ERROR! local_var not accessible\n\n# Modifying global (need 'global' keyword)\ncounter = 0\n\ndef increment():\n    global counter  # Declare as global\n    counter += 1\n\nincrement()\nprint(counter)  # 1\n\n\n\n10.4.2 Error Type 3: UnboundLocalError: local variable 'X' referenced before assignment\nError Message:\n&gt;&gt;&gt; count = 0\n&gt;&gt;&gt; def increment():\n...     count = count + 1\n&gt;&gt;&gt; increment()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 2, in increment\nUnboundLocalError: local variable 'count' referenced before assignment\nWhat Happened: Trying to modify global variable without declaring it as global.\nWhy It Happens: - Modifying global without ‚Äòglobal‚Äô keyword - Variable shadowing - Accessing before assignment in same scope\nCode Example - WRONG:\n# Modifying global without 'global'\ncount = 0\n\ndef increment():\n    count = count + 1  # ERROR! UnboundLocalError\n    return count\n\n# Reading then modifying\nvalue = 10\n\ndef update():\n    print(value)  # Would work...\n    value = 20    # ERROR! But this makes 'value' local\n    \n# Nested scope issue\ndef outer():\n    x = 10\n    def inner():\n        x = x + 1  # ERROR! UnboundLocalError\n        return x\n    return inner()\nCode Example - CORRECT:\n# Use 'global' keyword\ncount = 0\n\ndef increment():\n    global count  # ‚úì Declare as global\n    count = count + 1\n    return count\n\nincrement()  # count is now 1\n\n# Or pass as parameter (better)\ndef increment(count):\n    return count + 1\n\ncount = 0\ncount = increment(count)  # ‚úì Better approach\n\n# Return new value instead\nvalue = 10\n\ndef update(val):\n    return val + 10\n\nvalue = update(value)  # ‚úì Functional approach\n\n# Use nonlocal for nested functions\ndef outer():\n    x = 10\n    def inner():\n        nonlocal x  # ‚úì For nested scope\n        x = x + 1\n        return x\n    return inner()\n\n# Avoid global when possible\n# Instead, use class or pass parameters\nclass Counter:\n    def __init__(self):\n        self.count = 0\n    \n    def increment(self):\n        self.count += 1  # ‚úì No global needed\n\ncounter = Counter()\ncounter.increment()\nScope Best Practices:\n# BEST: Avoid global variables\n# Use parameters and return values\ndef add(x, y):\n    return x + y\n\n# GOOD: Use class for state\nclass Calculator:\n    def __init__(self):\n        self.total = 0\n    \n    def add(self, value):\n        self.total += value\n\n# AVOID: Global variables\n# global_count = 0\n# def increment():\n#     global global_count\n#     global_count += 1",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#default-arguments",
    "href": "chapter-09-functions.html#default-arguments",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.5 9.4 Default Arguments",
    "text": "10.5 9.4 Default Arguments\n\n10.5.1 Using Default Parameters\n# Simple default\ndef greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ngreet(\"Alice\")  # Uses default: \"Hello, Alice!\"\ngreet(\"Bob\", \"Hi\")  # Custom: \"Hi, Bob!\"\n\n# Multiple defaults\ndef create_user(name, age=None, city=\"Unknown\"):\n    print(f\"{name}, {age}, {city}\")\n\ncreate_user(\"Alice\")  # Alice, None, Unknown\ncreate_user(\"Bob\", 25)  # Bob, 25, Unknown\ncreate_user(\"Charlie\", 30, \"NYC\")  # Charlie, 30, NYC\n\n\n\n10.5.2 Error Type 4: Mutable Default Arguments\nWhat Happened: Using mutable objects (list, dict) as default arguments causes unexpected behavior.\nCode Example - WRONG:\n# DANGEROUS: Mutable default\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\nlist1 = add_item(\"apple\")  # ['apple']\nlist2 = add_item(\"banana\")  # ['apple', 'banana'] - Unexpected!\nlist3 = add_item(\"cherry\")  # ['apple', 'banana', 'cherry'] - Wrong!\n# All share the same list!\n\n# Same with dictionaries\ndef add_key(key, value, data={}):\n    data[key] = value\n    return data\n\ndict1 = add_key(\"a\", 1)  # {'a': 1}\ndict2 = add_key(\"b\", 2)  # {'a': 1, 'b': 2} - Unexpected!\nCode Example - CORRECT:\n# Use None as default, create new inside\ndef add_item(item, items=None):\n    if items is None:\n        items = []  # ‚úì Create new list each time\n    items.append(item)\n    return items\n\nlist1 = add_item(\"apple\")  # ['apple'] ‚úì\nlist2 = add_item(\"banana\")  # ['banana'] ‚úì\nlist3 = add_item(\"cherry\")  # ['cherry'] ‚úì\n\n# Same pattern for dictionaries\ndef add_key(key, value, data=None):\n    if data is None:\n        data = {}  # ‚úì Create new dict each time\n    data[key] = value\n    return data\n\ndict1 = add_key(\"a\", 1)  # {'a': 1} ‚úì\ndict2 = add_key(\"b\", 2)  # {'b': 2} ‚úì\n\n# Or explicitly pass new object\ndef add_item(item, items=None):\n    items = items if items is not None else []\n    items.append(item)\n    return items\n\n# Immutable defaults are safe\ndef process(value, multiplier=2):  # ‚úì int is immutable\n    return value * multiplier\n\ndef greet(name, prefix=\"Hello\"):  # ‚úì string is immutable\n    return f\"{prefix}, {name}!\"",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#args-and-kwargs",
    "href": "chapter-09-functions.html#args-and-kwargs",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.6 9.5 *args and **kwargs",
    "text": "10.6 9.5 *args and **kwargs\n\n10.6.1 Variable Arguments\n# *args - variable positional arguments\ndef add_all(*numbers):\n    return sum(numbers)\n\nadd_all(1, 2)  # 3\nadd_all(1, 2, 3, 4, 5)  # 15\n\n# **kwargs - variable keyword arguments\ndef print_info(**info):\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=25, city=\"NYC\")\n\n# Combining all parameter types\ndef complex_func(required, *args, optional=\"default\", **kwargs):\n    print(f\"Required: {required}\")\n    print(f\"Args: {args}\")\n    print(f\"Optional: {optional}\")\n    print(f\"Kwargs: {kwargs}\")\n\ncomplex_func(\"test\", 1, 2, 3, optional=\"custom\", key=\"value\")\n# Required: test\n# Args: (1, 2, 3)\n# Optional: custom\n# Kwargs: {'key': 'value'}",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#lambda-functions",
    "href": "chapter-09-functions.html#lambda-functions",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.7 9.6 Lambda Functions",
    "text": "10.7 9.6 Lambda Functions\n\n10.7.1 Anonymous Functions\n# Regular function\ndef square(x):\n    return x ** 2\n\n# Lambda equivalent\nsquare = lambda x: x ** 2\n\n# Lambda with multiple parameters\nadd = lambda x, y: x + y\n\n# Lambda in sorting\npairs = [(1, 'one'), (3, 'three'), (2, 'two')]\npairs.sort(key=lambda pair: pair[0])\n# [(1, 'one'), (2, 'two'), (3, 'three')]\n\n# Lambda in map\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\n# [1, 4, 9, 16, 25]\n\n# Lambda in filter\nevens = list(filter(lambda x: x % 2 == 0, numbers))\n# [2, 4]",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#recursion",
    "href": "chapter-09-functions.html#recursion",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.8 9.7 Recursion",
    "text": "10.8 9.7 Recursion\n\n10.8.1 Recursive Functions\n# Basic recursion\ndef countdown(n):\n    if n &lt;= 0:  # Base case\n        print(\"Done!\")\n        return\n    print(n)\n    countdown(n - 1)  # Recursive call\n\ncountdown(5)  # 5, 4, 3, 2, 1, Done!\n\n# Factorial\ndef factorial(n):\n    if n &lt;= 1:  # Base case\n        return 1\n    return n * factorial(n - 1)\n\nfactorial(5)  # 120\n\n# Fibonacci\ndef fibonacci(n):\n    if n &lt;= 1:  # Base case\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nfibonacci(6)  # 8\n\n\n\n10.8.2 Error Type 5: RecursionError: maximum recursion depth exceeded\nError Message:\n&gt;&gt;&gt; def infinite():\n...     return infinite()\n&gt;&gt;&gt; infinite()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 2, in infinite\n  [Previous line repeated 996 more times]\nRecursionError: maximum recursion depth exceeded\nWhat Happened: Recursive function never reaches base case.\nWhy It Happens: - Missing base case - Base case never reached - Wrong recursive logic\nCode Example - WRONG:\n# Missing base case\ndef countdown(n):\n    print(n)\n    countdown(n - 1)  # ERROR! Never stops\n\n# Base case never reached\ndef countdown(n):\n    if n == 0:  # Only checks equality\n        return\n    countdown(n - 2)  # ERROR! Skips 0 if n is odd\n\n# Wrong direction\ndef countdown(n):\n    if n == 0:\n        return\n    countdown(n + 1)  # ERROR! Goes up, not down\nCode Example - CORRECT:\n# Include base case\ndef countdown(n):\n    if n &lt;= 0:  # ‚úì Base case\n        return\n    print(n)\n    countdown(n - 1)\n\n# Ensure base case is reachable\ndef countdown(n):\n    if n &lt;= 0:  # ‚úì Uses &lt;= not ==\n        return\n    print(n)\n    countdown(n - 1)\n\n# Add safety limit\ndef countdown(n, depth=0, max_depth=1000):\n    if n &lt;= 0 or depth &gt;= max_depth:  # ‚úì Safety\n        return\n    print(n)\n    countdown(n - 1, depth + 1, max_depth)\n\n# Use iteration when appropriate\ndef countdown(n):\n    while n &gt; 0:  # ‚úì Often better than recursion\n        print(n)\n        n -= 1",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#practice-problems",
    "href": "chapter-09-functions.html#practice-problems",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.9 9.8 Practice Problems",
    "text": "10.9 9.8 Practice Problems\n\n10.9.1 Problem 1: Missing Argument\ndef greet(name, age):\n    print(f\"{name} is {age}\")\n\ngreet(\"Alice\")\n\n\nClick for Answer\n\nError: TypeError: greet() missing 1 required positional argument: 'age'\nFix:\ndef greet(name, age):\n    print(f\"{name} is {age}\")\n\ngreet(\"Alice\", 25)  # ‚úì Provide both arguments\n\n# Or use default\ndef greet(name, age=0):\n    print(f\"{name} is {age}\")\n\ngreet(\"Alice\")  # ‚úì Uses default age\n\n\n\n\n10.9.2 Problem 2: Missing Return\ndef add(a, b):\n    result = a + b\n\ntotal = add(3, 5)\nprint(total * 2)\n\n\nClick for Answer\n\nError: TypeError: unsupported operand type(s) for *: 'NoneType' and 'int'\nWhy: Function returns None (no return statement)\nFix:\ndef add(a, b):\n    result = a + b\n    return result  # ‚úì Add return\n\ntotal = add(3, 5)\nprint(total * 2)  # ‚úì Works: 16\n\n\n\n\n10.9.3 Problem 3: Global Variable\ncount = 0\n\ndef increment():\n    count = count + 1\n\nincrement()\n\n\nClick for Answer\n\nError: UnboundLocalError: local variable 'count' referenced before assignment\nFix:\ncount = 0\n\ndef increment():\n    global count  # ‚úì Declare as global\n    count = count + 1\n\nincrement()\nprint(count)  # 1\n\n# Or better - use parameter\ndef increment(n):\n    return n + 1\n\ncount = 0\ncount = increment(count)  # ‚úì Better",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#key-takeaways",
    "href": "chapter-09-functions.html#key-takeaways",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.10 9.9 Key Takeaways",
    "text": "10.10 9.9 Key Takeaways\n\n10.10.1 What You Learned\n\nMatch argument count - Provide all required arguments\nAlways return values - Don‚Äôt forget return statement\nUse ‚Äòglobal‚Äô for global variables - Or avoid globals\nDon‚Äôt use mutable defaults - Use None, create inside\nInclude base case in recursion - Prevent infinite recursion\nPass parameters instead of globals - Better design\nCheck return values for None - Before using\n\n\n\n10.10.2 Common Patterns\n# Pattern 1: Function with defaults\ndef greet(name, greeting=\"Hello\"):\n    return f\"{greeting}, {name}!\"\n\n# Pattern 2: Safe mutable default\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\n# Pattern 3: Multiple returns\ndef get_stats(numbers):\n    return min(numbers), max(numbers)\n\n# Pattern 4: Variable arguments\ndef add_all(*numbers):\n    return sum(numbers)\n\n\n10.10.3 Error Summary\n\n\n\n\n\n\n\n\nError\nCause\nPrevention\n\n\n\n\nTypeError (args)\nWrong argument count\nMatch function signature\n\n\nTypeError (NoneType)\nMissing return\nAdd return statement\n\n\nUnboundLocalError\nGlobal without declaration\nUse ‚Äòglobal‚Äô or parameters\n\n\nRecursionError\nNo base case\nInclude termination condition",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-09-functions.html#moving-forward",
    "href": "chapter-09-functions.html#moving-forward",
    "title": "10¬† Chapter 9: Functions - Defining and Calling Functions",
    "section": "10.11 9.10 Moving Forward",
    "text": "10.11 9.10 Moving Forward\nYou now understand functions! In Chapter 10, we‚Äôll explore File I/O - reading and writing files!",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Chapter 9: Functions - Defining and Calling Functions</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html",
    "href": "chapter-10-file-io.html",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "",
    "text": "11.1 Introduction\nYou‚Äôve mastered functions. Now let‚Äôs explore File I/O (Input/Output) - reading from and writing to files. Working with files is essential for data persistence, configuration, logging, and data processing.\nCommon errors: - FileNotFoundError: File doesn‚Äôt exist - PermissionError: No access to file - IsADirectoryError: Path is directory, not file - IOError: Input/output errors - Encoding issues\nLet‚Äôs master file operations!",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#reading-files",
    "href": "chapter-10-file-io.html#reading-files",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.2 10.1 Reading Files",
    "text": "11.2 10.1 Reading Files\n\n11.2.1 Basic File Reading\n# Read entire file\nwith open('file.txt', 'r') as file:\n    content = file.read()\n    print(content)\n\n# Read line by line\nwith open('file.txt', 'r') as file:\n    for line in file:\n        print(line.strip())  # strip() removes \\n\n\n# Read all lines into list\nwith open('file.txt', 'r') as file:\n    lines = file.readlines()  # List of lines\n\n# Read specific number of characters\nwith open('file.txt', 'r') as file:\n    chunk = file.read(100)  # First 100 characters\n\n\n\n11.2.2 Error Type 1: FileNotFoundError: No such file or directory\nError Message:\n&gt;&gt;&gt; with open('nonexistent.txt', 'r') as file:\n...     content = file.read()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFileNotFoundError: [Errno 2] No such file or directory: 'nonexistent.txt'\nWhat Happened: Trying to open a file that doesn‚Äôt exist.\nWhy It Happens: - File doesn‚Äôt exist at path - Wrong file name or path - Working directory confusion - Typo in filename\nCode Example - WRONG:\n# File doesn't exist\nwith open('nonexistent.txt', 'r') as file:\n    content = file.read()  # ERROR!\n\n# Wrong path\nwith open('/wrong/path/file.txt', 'r') as file:\n    content = file.read()  # ERROR!\n\n# Typo in filename\nwith open('flie.txt', 'r') as file:  # Typo: flie\n    content = file.read()  # ERROR!\n\n# Case sensitivity on Linux/Mac\nwith open('File.txt', 'r') as file:  # file.txt exists\n    content = file.read()  # ERROR on case-sensitive systems\nCode Example - CORRECT:\nimport os\n\n# Check if file exists first\nif os.path.exists('file.txt'):\n    with open('file.txt', 'r') as file:\n        content = file.read()  # ‚úì\nelse:\n    print(\"File not found\")\n\n# Use try/except\ntry:\n    with open('file.txt', 'r') as file:\n        content = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")  # ‚úì\n    content = \"\"  # Default value\n\n# Use absolute path\nfile_path = '/home/user/documents/file.txt'\nif os.path.exists(file_path):\n    with open(file_path, 'r') as file:\n        content = file.read()\n\n# Check current directory\nprint(\"Current directory:\", os.getcwd())\nprint(\"Files:\", os.listdir())  # List files\n\n# Use os.path.join for cross-platform paths\nfile_path = os.path.join('data', 'file.txt')\nif os.path.exists(file_path):\n    with open(file_path, 'r') as file:\n        content = file.read()\n\n# Create file if doesn't exist (for writing)\nwith open('file.txt', 'a') as file:  # 'a' creates if needed\n    file.write(\"Content\")",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#writing-files",
    "href": "chapter-10-file-io.html#writing-files",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.3 10.2 Writing Files",
    "text": "11.3 10.2 Writing Files\n\n11.3.1 Basic File Writing\n# Write to file (overwrites)\nwith open('output.txt', 'w') as file:\n    file.write(\"Hello, World!\")\n\n# Append to file\nwith open('output.txt', 'a') as file:\n    file.write(\"\\nNew line\")\n\n# Write multiple lines\nlines = [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\\n\"]\nwith open('output.txt', 'w') as file:\n    file.writelines(lines)\n\n# Write with print (adds newline)\nwith open('output.txt', 'w') as file:\n    print(\"Hello\", file=file)\n    print(\"World\", file=file)\n\n\n\n11.3.2 Error Type 2: PermissionError: Permission denied\nError Message:\n&gt;&gt;&gt; with open('/root/file.txt', 'w') as file:\n...     file.write(\"Content\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nPermissionError: [Errno 13] Permission denied: '/root/file.txt'\nWhat Happened: No permission to read/write file.\nWhy It Happens: - Insufficient permissions - File is read-only - Directory doesn‚Äôt allow writes - File is locked by another program\nCode Example - WRONG:\n# No permission to write\nwith open('/root/file.txt', 'w') as file:\n    file.write(\"Content\")  # ERROR!\n\n# File is read-only\nwith open('readonly.txt', 'w') as file:\n    file.write(\"Content\")  # ERROR!\n\n# Directory doesn't exist\nwith open('/nonexistent/dir/file.txt', 'w') as file:\n    file.write(\"Content\")  # ERROR!\nCode Example - CORRECT:\nimport os\n\n# Check write permission\nfile_path = 'file.txt'\ntry:\n    with open(file_path, 'w') as file:\n        file.write(\"Content\")\nexcept PermissionError:\n    print(\"No permission to write\")  # ‚úì\n\n# Check if directory is writable\ndir_path = '/some/directory'\nif os.access(dir_path, os.W_OK):\n    file_path = os.path.join(dir_path, 'file.txt')\n    with open(file_path, 'w') as file:\n        file.write(\"Content\")\nelse:\n    print(\"Directory not writable\")\n\n# Create directory if needed\ndir_path = 'data'\nos.makedirs(dir_path, exist_ok=True)  # ‚úì Creates if needed\nfile_path = os.path.join(dir_path, 'file.txt')\nwith open(file_path, 'w') as file:\n    file.write(\"Content\")\n\n# Write to user's home directory (usually writable)\nimport os.path\nhome = os.path.expanduser('~')\nfile_path = os.path.join(home, 'file.txt')\nwith open(file_path, 'w') as file:\n    file.write(\"Content\")  # ‚úì\n\n# Write to temp directory\nimport tempfile\nwith tempfile.NamedTemporaryFile(mode='w', delete=False) as file:\n    file.write(\"Content\")\n    temp_path = file.name  # ‚úì Always writable",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#context-managers-with-statement",
    "href": "chapter-10-file-io.html#context-managers-with-statement",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.4 10.3 Context Managers (with statement)",
    "text": "11.4 10.3 Context Managers (with statement)\n\n11.4.1 Understanding ‚Äòwith‚Äô\n# WITHOUT 'with' (manual close)\nfile = open('file.txt', 'r')\ntry:\n    content = file.read()\nfinally:\n    file.close()  # Must close manually\n\n# WITH 'with' (automatic close)\nwith open('file.txt', 'r') as file:\n    content = file.read()\n# File automatically closed ‚úì\n\n# Multiple files\nwith open('input.txt', 'r') as infile, \\\n     open('output.txt', 'w') as outfile:\n    content = infile.read()\n    outfile.write(content)\n# Both files closed automatically ‚úì\n\n\n\n11.4.2 Error Type 3: Forgetting to Close Files\nWhat Happened: Not closing files can lead to data loss and resource leaks.\nCode Example - WRONG:\n# Not closing file\nfile = open('file.txt', 'w')\nfile.write(\"Content\")\n# ERROR! File not closed, data might not be saved\n\n# Exception prevents close\nfile = open('file.txt', 'r')\ncontent = file.read()\nprocess(content)  # If this raises exception...\nfile.close()  # ...this never runs\n\n# Closing in wrong place\nfile = open('file.txt', 'r')\nfor line in file:\n    print(line)\n    file.close()  # ERROR! Closes after first line\nCode Example - CORRECT:\n# Use 'with' statement (BEST)\nwith open('file.txt', 'w') as file:\n    file.write(\"Content\")\n# File automatically closed ‚úì\n\n# Use try/finally if not using 'with'\nfile = open('file.txt', 'r')\ntry:\n    content = file.read()\n    process(content)\nfinally:\n    file.close()  # ‚úì Always closes\n\n# Correct loop\nwith open('file.txt', 'r') as file:\n    for line in file:\n        print(line)\n# File closed after loop ‚úì\n\n# Flush to ensure write\nwith open('file.txt', 'w') as file:\n    file.write(\"Important data\")\n    file.flush()  # ‚úì Forces write to disk",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#file-modes",
    "href": "chapter-10-file-io.html#file-modes",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.5 10.4 File Modes",
    "text": "11.5 10.4 File Modes\n\n11.5.1 Understanding File Modes\n# Read modes\n'r'   # Read (default) - error if doesn't exist\n'rb'  # Read binary\n'r+'  # Read and write\n\n# Write modes\n'w'   # Write - creates new or overwrites\n'wb'  # Write binary\n'w+'  # Write and read\n\n# Append modes\n'a'   # Append - creates if doesn't exist\n'ab'  # Append binary\n'a+'  # Append and read\n\n# Exclusive creation\n'x'   # Create new - error if exists\n\n\n\n11.5.2 Error Type 4: FileExistsError: File exists\nError Message:\n&gt;&gt;&gt; with open('existing.txt', 'x') as file:\n...     file.write(\"Content\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFileExistsError: [Errno 17] File exists: 'existing.txt'\nWhat Happened: Using ‚Äòx‚Äô mode on existing file.\nCode Example - WRONG:\n# 'x' mode with existing file\nwith open('existing.txt', 'x') as file:\n    file.write(\"Content\")  # ERROR if file exists\n\n# Wrong mode for operation\nwith open('file.txt', 'r') as file:\n    file.write(\"Content\")  # ERROR! Can't write in 'r' mode\n\n# Binary mode with string\nwith open('file.txt', 'wb') as file:\n    file.write(\"Hello\")  # ERROR! Need bytes, not string\nCode Example - CORRECT:\n# Check before using 'x'\nif not os.path.exists('file.txt'):\n    with open('file.txt', 'x') as file:\n        file.write(\"Content\")  # ‚úì\nelse:\n    print(\"File already exists\")\n\n# Use appropriate mode\nwith open('file.txt', 'w') as file:  # ‚úì For writing\n    file.write(\"Content\")\n\nwith open('file.txt', 'r') as file:  # ‚úì For reading\n    content = file.read()\n\n# Binary mode with bytes\nwith open('file.txt', 'wb') as file:\n    file.write(b\"Hello\")  # ‚úì Bytes object\n\n# Or encode string\nwith open('file.txt', 'wb') as file:\n    file.write(\"Hello\".encode('utf-8'))  # ‚úì\n\n# Text mode (default)\nwith open('file.txt', 'w') as file:\n    file.write(\"Hello\")  # ‚úì String\n\n# Safe overwrite pattern\nimport shutil\nif os.path.exists('file.txt'):\n    shutil.copy('file.txt', 'file.txt.bak')  # Backup\nwith open('file.txt', 'w') as file:\n    file.write(\"New content\")  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#working-with-paths",
    "href": "chapter-10-file-io.html#working-with-paths",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.6 10.5 Working with Paths",
    "text": "11.6 10.5 Working with Paths\n\n11.6.1 Path Operations\nimport os\n\n# Current directory\ncurrent = os.getcwd()\n\n# Change directory\nos.chdir('/path/to/directory')\n\n# Join paths (cross-platform)\npath = os.path.join('data', 'files', 'document.txt')\n# Windows: data\\files\\document.txt\n# Unix: data/files/document.txt\n\n# Split path\ndirectory, filename = os.path.split('/path/to/file.txt')\n# directory: '/path/to'\n# filename: 'file.txt'\n\n# Get filename and extension\nfilename, ext = os.path.splitext('document.txt')\n# filename: 'document'\n# ext: '.txt'\n\n# Check existence\nos.path.exists('file.txt')      # File or directory\nos.path.isfile('file.txt')      # File only\nos.path.isdir('directory')      # Directory only\n\n# Get absolute path\nabs_path = os.path.abspath('file.txt')\n\n# List directory contents\nfiles = os.listdir('directory')\n\n# Create directory\nos.makedirs('path/to/directory', exist_ok=True)",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#common-file-patterns",
    "href": "chapter-10-file-io.html#common-file-patterns",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.7 10.6 Common File Patterns",
    "text": "11.7 10.6 Common File Patterns\n\n11.7.1 Useful Patterns\n# Read file safely\ndef read_file(filename):\n    try:\n        with open(filename, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return None\n\n# Write file safely\ndef write_file(filename, content):\n    try:\n        with open(filename, 'w') as file:\n            file.write(content)\n        return True\n    except (PermissionError, IOError):\n        return False\n\n# Copy file\ndef copy_file(source, destination):\n    with open(source, 'r') as infile:\n        with open(destination, 'w') as outfile:\n            outfile.write(infile.read())\n\n# Process file line by line\ndef process_large_file(filename):\n    with open(filename, 'r') as file:\n        for line in file:  # Memory efficient\n            process_line(line.strip())\n\n# Read CSV\ndef read_csv(filename):\n    data = []\n    with open(filename, 'r') as file:\n        for line in file:\n            data.append(line.strip().split(','))\n    return data\n\n# Write CSV\ndef write_csv(filename, data):\n    with open(filename, 'w') as file:\n        for row in data:\n            file.write(','.join(str(x) for x in row) + '\\n')",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#practice-problems",
    "href": "chapter-10-file-io.html#practice-problems",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.8 10.7 Practice Problems",
    "text": "11.8 10.7 Practice Problems\n\n11.8.1 Problem 1: File Not Found\nwith open('data.txt', 'r') as file:\n    content = file.read()\n\n\nClick for Answer\n\nError: FileNotFoundError: No such file or directory: 'data.txt'\nFix:\nimport os\n\n# Check first\nif os.path.exists('data.txt'):\n    with open('data.txt', 'r') as file:\n        content = file.read()\nelse:\n    print(\"File not found\")  # ‚úì\n\n# Or use try/except\ntry:\n    with open('data.txt', 'r') as file:\n        content = file.read()\nexcept FileNotFoundError:\n    content = \"\"  # ‚úì Default\n\n\n\n\n11.8.2 Problem 2: Not Closing File\nfile = open('output.txt', 'w')\nfile.write(\"Content\")\n\n\nClick for Answer\n\nIssue: File not closed, data might not be saved\nFix:\n# Use 'with' statement\nwith open('output.txt', 'w') as file:\n    file.write(\"Content\")\n# File automatically closed ‚úì\n\n\n\n\n11.8.3 Problem 3: Wrong Mode\nwith open('file.txt', 'r') as file:\n    file.write(\"New content\")\n\n\nClick for Answer\n\nError: io.UnsupportedOperation: not writable\nFix:\n# Use write mode\nwith open('file.txt', 'w') as file:  # ‚úì Use 'w'\n    file.write(\"New content\")\n\n# Or append mode\nwith open('file.txt', 'a') as file:  # ‚úì Use 'a'\n    file.write(\"New content\")",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#key-takeaways",
    "href": "chapter-10-file-io.html#key-takeaways",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.9 10.8 Key Takeaways",
    "text": "11.9 10.8 Key Takeaways\n\n11.9.1 What You Learned\n\nCheck file exists - Before opening for reading\nUse ‚Äòwith‚Äô statement - Automatically closes files\nHandle exceptions - FileNotFoundError, PermissionError\nUse correct mode - ‚Äòr‚Äô for read, ‚Äòw‚Äô for write, ‚Äòa‚Äô for append\nUse os.path.join - Cross-platform paths\nClose files - Or use ‚Äòwith‚Äô to auto-close\nCheck permissions - Before writing\n\n\n\n11.9.2 Common Patterns\n# Pattern 1: Safe read\ntry:\n    with open('file.txt', 'r') as file:\n        content = file.read()\nexcept FileNotFoundError:\n    content = \"\"\n\n# Pattern 2: Safe write\nwith open('file.txt', 'w') as file:\n    file.write(content)\n\n# Pattern 3: Check exists\nif os.path.exists('file.txt'):\n    # Process file\n\n# Pattern 4: Create path\nos.makedirs('path/to/dir', exist_ok=True)\n\n\n11.9.3 Error Summary\n\n\n\n\n\n\n\n\nError\nCause\nPrevention\n\n\n\n\nFileNotFoundError\nFile doesn‚Äôt exist\nCheck with os.path.exists()\n\n\nPermissionError\nNo access rights\nCheck permissions or use try/except\n\n\nNot closing\nForgot to close\nUse ‚Äòwith‚Äô statement\n\n\nWrong mode\nIncorrect r/w/a\nChoose correct mode",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#congratulations",
    "href": "chapter-10-file-io.html#congratulations",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.10 10.9 Congratulations!",
    "text": "11.10 10.9 Congratulations!\n\n11.10.1 üéâ You Completed Part I: Python Fundamentals!\nYou‚Äôve mastered: - ‚úÖ Variables and Data Types (Chapter 1) - ‚úÖ Operators and Expressions (Chapter 2) - ‚úÖ Strings and String Methods (Chapter 3) - ‚úÖ Lists and List Methods (Chapter 4) - ‚úÖ Dictionaries and Sets (Chapter 5) - ‚úÖ Tuples and Immutability (Chapter 6) - ‚úÖ Conditional Statements (Chapter 7) - ‚úÖ Loops (Chapter 8) - ‚úÖ Functions (Chapter 9) - ‚úÖ File I/O (Chapter 10)",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-10-file-io.html#moving-forward",
    "href": "chapter-10-file-io.html#moving-forward",
    "title": "11¬† Chapter 10: File I/O - Reading and Writing Files",
    "section": "11.11 10.10 Moving Forward",
    "text": "11.11 10.10 Moving Forward\nPart I Complete! You now have a solid foundation in Python fundamentals.\nWhat‚Äôs Next?\n\n11.11.1 Part II: Libraries and Data (Chapters 11-15)\n\nChapter 11: Regular Expressions\nChapter 12: Pandas Basics\nChapter 13: Pandas Advanced\nChapter 14: NumPy\nChapter 15: Matplotlib\n\n\n\n11.11.2 Part III: Advanced Topics (Chapters 16-20)\n\nChapter 16: Object-Oriented Programming\nChapter 17: Modules and Imports\nChapter 18: Exception Handling\nChapter 19: Debugging Techniques\nChapter 20: Testing and Code Quality",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Chapter 10: File I/O - Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html",
    "href": "chapter-11-regular-expressions.html",
    "title": "12¬† Wrong escape",
    "section": "",
    "text": "12.1 11.2 Common Regex Patterns\npattern = ‚Äò‚Äô # Should be raw string re.search(pattern, text) # Might not work as expected\nRegex Special Characters:",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#common-regex-patterns",
    "href": "chapter-11-regular-expressions.html#common-regex-patterns",
    "title": "12¬† Wrong escape",
    "section": "",
    "text": "12.1.1 Useful Patterns\nimport re\n\n# Digits\npattern = r'\\d'     # Any digit [0-9]\npattern = r'\\d+'    # One or more digits\npattern = r'\\d{3}'  # Exactly 3 digits\n\n# Letters\npattern = r'[a-z]'  # Lowercase letter\npattern = r'[A-Z]'  # Uppercase letter\npattern = r'[a-zA-Z]'  # Any letter\n\n# Whitespace\npattern = r'\\s'     # Any whitespace\npattern = r'\\s+'    # One or more whitespace\n\n# Word characters\npattern = r'\\w'     # Letter, digit, or underscore\npattern = r'\\w+'    # One or more word characters\n\n# Beginning and end\npattern = r'^hello' # Starts with \"hello\"\npattern = r'world$' # Ends with \"world\"\n\n# Email pattern\nemail_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n\n# Phone pattern (US)\nphone_pattern = r'\\d{3}-\\d{3}-\\d{4}'\n\n# URL pattern\nurl_pattern = r'https?://[^\\s]+'",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#match-vs-search-vs-findall",
    "href": "chapter-11-regular-expressions.html#match-vs-search-vs-findall",
    "title": "12¬† Wrong escape",
    "section": "12.2 11.3 Match vs Search vs Findall",
    "text": "12.2 11.3 Match vs Search vs Findall\n\n12.2.1 Understanding Different Methods\nimport re\n\ntext = \"The cat and the bat sat on the mat\"\n\n# match() - checks beginning only\nmatch = re.match(r'cat', text)\nprint(match)  # None - doesn't start with 'cat'\n\nmatch = re.match(r'The', text)\nprint(match)  # &lt;Match object&gt; - starts with 'The'\n\n# search() - finds first occurrence anywhere\nmatch = re.search(r'cat', text)\nprint(match.group())  # 'cat' - found it\n\n# findall() - finds all occurrences\nmatches = re.findall(r'at', text)\nprint(matches)  # ['at', 'at', 'at', 'at']\n\n# finditer() - iterator of match objects\nfor match in re.finditer(r'at', text):\n    print(f\"Found at position {match.start()}: {match.group()}\")\n\n\n\n12.2.2 Error Type 2: AttributeError: 'NoneType' object has no attribute 'group'\nError Message:\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; match = re.search(r'xyz', 'abc')\n&gt;&gt;&gt; print(match.group())\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'NoneType' object has no attribute 'group'\nWhat Happened: Pattern not found, match is None, trying to call .group().\nWhy It Happens: - Pattern doesn‚Äôt exist in text - Wrong pattern - Not checking if match succeeded\nCode Example - WRONG:\nimport re\n\n# Not checking if match found\ntext = \"Hello World\"\nmatch = re.search(r'xyz', text)\nprint(match.group())  # ERROR! match is None\n\n# Using wrong method result\nmatches = re.findall(r'world', text)\nprint(matches.group())  # ERROR! findall returns list, not match object\n\n# Assuming match always succeeds\nemail = \"not-an-email\"\nmatch = re.search(r'[\\w.]+@[\\w.]+', email)\ndomain = match.group()  # ERROR if no match\nCode Example - CORRECT:\nimport re\n\n# Check if match exists\ntext = \"Hello World\"\nmatch = re.search(r'xyz', text)\nif match:\n    print(match.group())\nelse:\n    print(\"Not found\")  # ‚úì\n\n# Use findall correctly (returns list)\nmatches = re.findall(r'World', text)\nif matches:\n    print(matches[0])  # ‚úì Access list element\n\n# Safe pattern with default\nemail = \"not-an-email\"\nmatch = re.search(r'[\\w.]+@[\\w.]+', email)\ndomain = match.group() if match else \"invalid\"  # ‚úì\n\n# Use try/except\ntry:\n    match = re.search(r'pattern', text)\n    result = match.group()\nexcept AttributeError:\n    result = None  # ‚úì\n\n# Helper function\ndef safe_search(pattern, text, default=\"\"):\n    \"\"\"Safely search with default\"\"\"\n    match = re.search(pattern, text)\n    return match.group() if match else default\n\nresult = safe_search(r'xyz', text, default=\"not found\")  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#groups-and-capturing",
    "href": "chapter-11-regular-expressions.html#groups-and-capturing",
    "title": "12¬† Wrong escape",
    "section": "12.3 11.4 Groups and Capturing",
    "text": "12.3 11.4 Groups and Capturing\n\n12.3.1 Extracting Parts\nimport re\n\n# Basic grouping\ntext = \"John: 30\"\nmatch = re.search(r'(\\w+): (\\d+)', text)\nif match:\n    name = match.group(1)  # \"John\"\n    age = match.group(2)   # \"30\"\n    full = match.group(0)  # \"John: 30\" (entire match)\n\n# Named groups\nmatch = re.search(r'(?P&lt;name&gt;\\w+): (?P&lt;age&gt;\\d+)', text)\nif match:\n    name = match.group('name')  # \"John\"\n    age = match.group('age')    # \"30\"\n\n# Extract email parts\nemail = \"user@example.com\"\nmatch = re.search(r'(?P&lt;user&gt;[\\w.]+)@(?P&lt;domain&gt;[\\w.]+)', email)\nif match:\n    user = match.group('user')      # \"user\"\n    domain = match.group('domain')  # \"example.com\"\n\n# Multiple matches with groups\ntext = \"John:30, Jane:25, Bob:35\"\nmatches = re.findall(r'(\\w+):(\\d+)', text)\nfor name, age in matches:\n    print(f\"{name} is {age}\")",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#greedy-vs-non-greedy",
    "href": "chapter-11-regular-expressions.html#greedy-vs-non-greedy",
    "title": "12¬† Wrong escape",
    "section": "12.4 11.5 Greedy vs Non-Greedy",
    "text": "12.4 11.5 Greedy vs Non-Greedy\n\n12.4.1 Understanding Quantifiers\nimport re\n\ntext = \"&lt;div&gt;content&lt;/div&gt;\"\n\n# Greedy (default) - matches as much as possible\nmatch = re.search(r'&lt;.*&gt;', text)\nprint(match.group())  # \"&lt;div&gt;content&lt;/div&gt;\" - entire string\n\n# Non-greedy - matches as little as possible\nmatch = re.search(r'&lt;.*?&gt;', text)\nprint(match.group())  # \"&lt;div&gt;\" - stops at first &gt;\n\n# Examples\ntext = \"aaa\"\nre.findall(r'a+', text)   # ['aaa'] - greedy\nre.findall(r'a+?', text)  # ['a', 'a', 'a'] - non-greedy\n\ntext = '123'\nre.findall(r'\\d{2,4}', text)   # ['123'] - greedy (max 4)\nre.findall(r'\\d{2,4}?', text)  # ['12'] - non-greedy (min 2)\n\n# Practical example - extract HTML tags\nhtml = \"&lt;p&gt;First&lt;/p&gt;&lt;p&gt;Second&lt;/p&gt;\"\nre.findall(r'&lt;p&gt;.*?&lt;/p&gt;', html)  # ‚úì ['&lt;p&gt;First&lt;/p&gt;', '&lt;p&gt;Second&lt;/p&gt;']\nre.findall(r'&lt;p&gt;.*&lt;/p&gt;', html)   # ['&lt;p&gt;First&lt;/p&gt;&lt;p&gt;Second&lt;/p&gt;'] - greedy",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#substitution",
    "href": "chapter-11-regular-expressions.html#substitution",
    "title": "12¬† Wrong escape",
    "section": "12.5 11.6 Substitution",
    "text": "12.5 11.6 Substitution\n\n12.5.1 Replacing Patterns\nimport re\n\n# Simple replacement\ntext = \"Hello World\"\nresult = re.sub(r'World', 'Python', text)\nprint(result)  # \"Hello Python\"\n\n# Replace with function\ndef uppercase(match):\n    return match.group().upper()\n\ntext = \"hello world\"\nresult = re.sub(r'\\w+', uppercase, text)\nprint(result)  # \"HELLO WORLD\"\n\n# Replace using groups\ntext = \"John Doe\"\nresult = re.sub(r'(\\w+) (\\w+)', r'\\2, \\1', text)\nprint(result)  # \"Doe, John\"\n\n# Replace with named groups\nresult = re.sub(r'(?P&lt;first&gt;\\w+) (?P&lt;last&gt;\\w+)', \n                r'\\g&lt;last&gt;, \\g&lt;first&gt;', text)\nprint(result)  # \"Doe, John\"\n\n# Limit replacements\ntext = \"cat bat cat rat\"\nresult = re.sub(r'cat', 'dog', text, count=1)\nprint(result)  # \"dog bat cat rat\"\n\n# Case-insensitive replacement\nresult = re.sub(r'WORLD', 'Python', 'Hello WORLD', flags=re.IGNORECASE)\nprint(result)  # \"Hello Python\"",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#flags",
    "href": "chapter-11-regular-expressions.html#flags",
    "title": "12¬† Wrong escape",
    "section": "12.6 11.7 Flags",
    "text": "12.6 11.7 Flags\n\n12.6.1 Regex Modifiers\nimport re\n\n# Case-insensitive\ntext = \"Hello WORLD\"\nmatch = re.search(r'world', text, re.IGNORECASE)\n# Or: re.IGNORECASE, re.I\n\n# Multiline - ^ and $ match line boundaries\ntext = \"line1\\nline2\\nline3\"\nmatches = re.findall(r'^line', text, re.MULTILINE)\n# Matches: ['line', 'line', 'line']\n\n# Dotall - . matches newlines\ntext = \"first\\nsecond\"\nmatch = re.search(r'first.second', text, re.DOTALL)\n# Matches across newline\n\n# Verbose - allows comments and whitespace\npattern = r'''\n    \\d{3}  # Area code\n    -      # Separator\n    \\d{3}  # Prefix\n    -      # Separator\n    \\d{4}  # Line number\n'''\nmatch = re.search(pattern, '555-123-4567', re.VERBOSE)\n\n# Combine flags\nmatch = re.search(r'pattern', text, re.IGNORECASE | re.MULTILINE)",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#common-patterns-and-use-cases",
    "href": "chapter-11-regular-expressions.html#common-patterns-and-use-cases",
    "title": "12¬† Wrong escape",
    "section": "12.7 11.8 Common Patterns and Use Cases",
    "text": "12.7 11.8 Common Patterns and Use Cases\n\n12.7.1 Practical Examples\nimport re\n\n# Validate email\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\n# Validate phone number (US)\ndef is_valid_phone(phone):\n    pattern = r'^\\d{3}-\\d{3}-\\d{4}$'\n    return re.match(pattern, phone) is not None\n\n# Extract URLs from text\ndef extract_urls(text):\n    pattern = r'https?://[^\\s]+'\n    return re.findall(pattern, text)\n\n# Remove HTML tags\ndef remove_html_tags(html):\n    pattern = r'&lt;[^&gt;]+&gt;'\n    return re.sub(pattern, '', html)\n\n# Extract numbers from string\ndef extract_numbers(text):\n    pattern = r'\\d+'\n    return [int(x) for x in re.findall(pattern, text)]\n\n# Validate password (8+ chars, letter, number)\ndef is_strong_password(password):\n    if len(password) &lt; 8:\n        return False\n    if not re.search(r'[a-zA-Z]', password):\n        return False\n    if not re.search(r'\\d', password):\n        return False\n    return True\n\n# Parse log line\ndef parse_log_line(line):\n    pattern = r'(?P&lt;date&gt;\\S+) (?P&lt;time&gt;\\S+) (?P&lt;level&gt;\\w+) (?P&lt;message&gt;.*)'\n    match = re.match(pattern, line)\n    if match:\n        return match.groupdict()\n    return None",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#practice-problems",
    "href": "chapter-11-regular-expressions.html#practice-problems",
    "title": "12¬† Wrong escape",
    "section": "12.8 11.9 Practice Problems",
    "text": "12.8 11.9 Practice Problems\n\n12.8.1 Problem 1: Invalid Pattern\nimport re\npattern = '(hello'\nre.search(pattern, 'hello world')\n\n\nClick for Answer\n\nError: re.error: missing ), unterminated subpattern\nFix:\nimport re\npattern = r'(hello)'  # ‚úì Close parentheses\nmatch = re.search(pattern, 'hello world')\n\n\n\n\n12.8.2 Problem 2: NoneType Error\nimport re\ntext = \"Hello World\"\nmatch = re.search(r'xyz', text)\nprint(match.group())\n\n\nClick for Answer\n\nError: AttributeError: 'NoneType' object has no attribute 'group'\nFix:\nimport re\ntext = \"Hello World\"\nmatch = re.search(r'xyz', text)\nif match:  # ‚úì Check if found\n    print(match.group())\nelse:\n    print(\"Not found\")\n\n\n\n\n12.8.3 Problem 3: Greedy Match\nimport re\nhtml = \"&lt;p&gt;First&lt;/p&gt;&lt;p&gt;Second&lt;/p&gt;\"\nmatches = re.findall(r'&lt;p&gt;.*&lt;/p&gt;', html)\nprint(matches)\n\n\nClick for Answer\n\nIssue: Returns entire string (greedy)\nFix:\nimport re\nhtml = \"&lt;p&gt;First&lt;/p&gt;&lt;p&gt;Second&lt;/p&gt;\"\nmatches = re.findall(r'&lt;p&gt;.*?&lt;/p&gt;', html)  # ‚úì Non-greedy\nprint(matches)  # ['&lt;p&gt;First&lt;/p&gt;', '&lt;p&gt;Second&lt;/p&gt;']",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#key-takeaways",
    "href": "chapter-11-regular-expressions.html#key-takeaways",
    "title": "12¬† Wrong escape",
    "section": "12.9 11.10 Key Takeaways",
    "text": "12.9 11.10 Key Takeaways\n\n12.9.1 What You Learned\n\nUse raw strings - r‚Äô‚Äô for regex patterns\nCheck match results - Before calling .group()\nEscape special characters - . $ ( etc.\nUse non-greedy - .*? for minimal matching\nValidate patterns - Test with re.compile()\nUse named groups - (?P‚Ä¶) for clarity\nChoose right method - match/search/findall/sub\n\n\n\n12.9.2 Common Patterns\n# Pattern 1: Safe search\nmatch = re.search(pattern, text)\nif match:\n    result = match.group()\n\n# Pattern 2: Extract all\nmatches = re.findall(pattern, text)\n\n# Pattern 3: Replace\nresult = re.sub(pattern, replacement, text)\n\n# Pattern 4: Validate\ndef is_valid(text):\n    return re.match(pattern, text) is not None\n\n\n12.9.3 Error Summary\n\n\n\n\n\n\n\n\nError\nCause\nPrevention\n\n\n\n\nre.error\nInvalid pattern syntax\nUse raw strings, close brackets\n\n\nAttributeError\nmatch is None\nCheck if match before .group()\n\n\nGreedy issues\nUsing .*\nUse .*? for non-greedy",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-11-regular-expressions.html#moving-forward",
    "href": "chapter-11-regular-expressions.html#moving-forward",
    "title": "12¬† Wrong escape",
    "section": "12.10 11.11 Moving Forward",
    "text": "12.10 11.11 Moving Forward\nYou now understand regular expressions! In Chapter 12, we‚Äôll explore Pandas Basics - data analysis with DataFrames!",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Wrong escape</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html",
    "href": "chapter-12-pandas-basics.html",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "",
    "text": "13.1 Introduction\nWelcome to Pandas - Python‚Äôs powerful data analysis library! Pandas provides DataFrames for working with structured data (like spreadsheets or SQL tables). It‚Äôs essential for data science and analysis.\nCommon errors: - KeyError: Column/index doesn‚Äôt exist - ValueError: Wrong shape or values - AttributeError: Wrong method for operation - TypeError: Wrong data types - Index alignment issues\nLet‚Äôs master Pandas!",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#creating-dataframes",
    "href": "chapter-12-pandas-basics.html#creating-dataframes",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.2 12.1 Creating DataFrames",
    "text": "13.2 12.1 Creating DataFrames\n\n13.2.1 Basic DataFrame Creation\nimport pandas as pd\n\n# From dictionary\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35],\n    'city': ['NYC', 'LA', 'Chicago']\n}\ndf = pd.DataFrame(data)\n\n# From list of lists\ndata = [\n    ['Alice', 25, 'NYC'],\n    ['Bob', 30, 'LA'],\n    ['Charlie', 35, 'Chicago']\n]\ndf = pd.DataFrame(data, columns=['name', 'age', 'city'])\n\n# From list of dictionaries\ndata = [\n    {'name': 'Alice', 'age': 25, 'city': 'NYC'},\n    {'name': 'Bob', 'age': 30, 'city': 'LA'}\n]\ndf = pd.DataFrame(data)\n\n# Read from CSV\ndf = pd.read_csv('data.csv')\n\n# Basic info\nprint(df.head())      # First 5 rows\nprint(df.tail())      # Last 5 rows\nprint(df.shape)       # (rows, columns)\nprint(df.columns)     # Column names\nprint(df.dtypes)      # Data types\nprint(df.info())      # Overview\n\n\n\n13.2.2 Error Type 1: KeyError: 'column_name'\nError Message:\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({'name': ['Alice', 'Bob'], 'age': [25, 30]})\n&gt;&gt;&gt; df['salary']\nTraceback (most recent call last):\n  ...\nKeyError: 'salary'\nWhat Happened: Trying to access a column that doesn‚Äôt exist.\nWhy It Happens: - Column doesn‚Äôt exist in DataFrame - Typo in column name - Case sensitivity - Using wrong accessor\nCode Example - WRONG:\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob'],\n    'age': [25, 30]\n})\n\n# Non-existent column\nsalary = df['salary']  # ERROR! Column doesn't exist\n\n# Typo\nname = df['nane']  # ERROR! Typo\n\n# Case sensitivity\nage = df['Age']  # ERROR! Column is 'age' not 'Age'\n\n# Wrong bracket type\nname = df('name')  # ERROR! Use [] not ()\n\n# Multiple columns with typo\nsubset = df[['name', 'salary']]  # ERROR! 'salary' doesn't exist\nCode Example - CORRECT:\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob'],\n    'age': [25, 30]\n})\n\n# Check if column exists\nif 'salary' in df.columns:\n    salary = df['salary']\nelse:\n    print(\"Column doesn't exist\")  # ‚úì\n\n# Use .get() for Series (doesn't work for DataFrame columns)\n# But can use try/except\ntry:\n    salary = df['salary']\nexcept KeyError:\n    salary = None  # ‚úì\n\n# Check available columns\nprint(df.columns.tolist())  # ['name', 'age']\n\n# Correct spelling\nname = df['name']  # ‚úì\n\n# Match case exactly\nage = df['age']  # ‚úì\n\n# Use correct brackets\nname = df['name']  # ‚úì\n\n# Safe column selection\ncolumns_to_select = ['name', 'age']\nexisting_cols = [col for col in columns_to_select if col in df.columns]\nsubset = df[existing_cols]  # ‚úì\n\n# Add missing column with default\nif 'salary' not in df.columns:\n    df['salary'] = 0  # ‚úì Add with default value\n\n# Use .loc for safe access\ntry:\n    data = df.loc[:, 'salary']\nexcept KeyError:\n    df['salary'] = 0\n    data = df.loc[:, 'salary']  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#selecting-data",
    "href": "chapter-12-pandas-basics.html#selecting-data",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.3 12.2 Selecting Data",
    "text": "13.3 12.2 Selecting Data\n\n13.3.1 Accessing Rows and Columns\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35],\n    'city': ['NYC', 'LA', 'Chicago']\n})\n\n# Select column (returns Series)\nages = df['age']\n\n# Select multiple columns (returns DataFrame)\nsubset = df[['name', 'age']]\n\n# Select rows by index position (.iloc)\nfirst_row = df.iloc[0]           # First row\nfirst_three = df.iloc[0:3]       # First 3 rows\nlast_row = df.iloc[-1]           # Last row\n\n# Select rows by label (.loc)\ndf_indexed = df.set_index('name')\nalice = df_indexed.loc['Alice']\n\n# Select specific cells\nvalue = df.loc[0, 'age']         # Row 0, column 'age'\nvalue = df.iloc[0, 1]            # Row 0, column 1\n\n# Boolean indexing\nadults = df[df['age'] &gt;= 30]\nin_nyc = df[df['city'] == 'NYC']\n\n# Multiple conditions\nresult = df[(df['age'] &gt;= 30) & (df['city'] == 'LA')]\n\n\n\n13.3.2 Error Type 2: ValueError: Location based indexing can only have [integer, integer slice, listlike of integers, boolean array] types\nError Message:\n&gt;&gt;&gt; df = pd.DataFrame({'name': ['Alice', 'Bob'], 'age': [25, 30]})\n&gt;&gt;&gt; df.iloc['Alice']\nTraceback (most recent call last):\n  ...\nValueError: Location based indexing can only have [integer, integer slice...\nWhat Happened: Using wrong indexing method (.iloc vs .loc).\nWhy It Happens: - Using labels with .iloc (needs integers) - Using integers with .loc on non-integer index - Confusing .iloc and .loc - Wrong indexing syntax\nCode Example - WRONG:\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35]\n})\n\n# Using label with .iloc\nrow = df.iloc['Alice']  # ERROR! .iloc needs integer\n\n# Using column name with .iloc\nages = df.iloc[:, 'age']  # ERROR! Use column index or .loc\n\n# Wrong syntax\nrow = df.iloc['name' == 'Alice']  # ERROR! Wrong method\nCode Example - CORRECT:\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35]\n})\n\n# Use .iloc with integers\nfirst_row = df.iloc[0]  # ‚úì Integer index\nfirst_three = df.iloc[0:3]  # ‚úì Integer slice\n\n# Use .loc with labels/conditions\n# First, set index if you want to use labels\ndf_indexed = df.set_index('name')\nalice = df_indexed.loc['Alice']  # ‚úì Label index\n\n# Or use .loc with column names\nvalue = df.loc[0, 'age']  # ‚úì Row by position, column by name\n\n# Use .iloc for column by position\nages = df.iloc[:, 1]  # ‚úì All rows, second column\n\n# Boolean indexing (use direct or .loc)\nadults = df[df['age'] &gt;= 30]  # ‚úì\n# Or\nadults = df.loc[df['age'] &gt;= 30]  # ‚úì\n\n# Remember:\n# .loc[row_label, column_label]  - uses labels\n# .iloc[row_position, column_position]  - uses integers\n\n# Examples:\ndf.loc[0, 'age']      # ‚úì Row 0, column 'age'\ndf.iloc[0, 1]         # ‚úì Row 0, column 1\ndf.loc[0:2, ['name', 'age']]  # ‚úì Rows 0-2, specific columns\ndf.iloc[0:2, 0:2]     # ‚úì First 2 rows, first 2 columns",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#data-types",
    "href": "chapter-12-pandas-basics.html#data-types",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.4 12.3 Data Types",
    "text": "13.4 12.3 Data Types\n\n13.4.1 Understanding dtypes\nimport pandas as pd\n\n# Check data types\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob'],\n    'age': [25, 30],\n    'salary': [50000.0, 60000.0],\n    'hired': ['2020-01-01', '2021-06-15']\n})\n\nprint(df.dtypes)\n# name       object\n# age        int64\n# salary     float64\n# hired      object\n\n# Convert types\ndf['age'] = df['age'].astype(float)\ndf['hired'] = pd.to_datetime(df['hired'])\n\n# Check for missing values\nprint(df.isnull())\nprint(df.isnull().sum())  # Count per column\n\n# Fill missing values\ndf['age'].fillna(0, inplace=True)\ndf['name'].fillna('Unknown', inplace=True)\n\n# Drop missing values\ndf_clean = df.dropna()  # Drop rows with any NaN\ndf_clean = df.dropna(subset=['age'])  # Drop rows with NaN in 'age'\n\n\n\n13.4.2 Error Type 3: TypeError: cannot concatenate object of type\nError Message:\n&gt;&gt;&gt; df = pd.DataFrame({'age': ['25', '30']})\n&gt;&gt;&gt; df['age'].mean()\nTraceback (most recent call last):\n  ...\nTypeError: Could not convert 25 30 to numeric\nWhat Happened: Trying to perform numeric operations on non-numeric data.\nWhy It Happens: - Column contains strings not numbers - Mixed types in column - Wrong data type - Not converting before operation\nCode Example - WRONG:\nimport pandas as pd\n\n# Numeric operations on strings\ndf = pd.DataFrame({'age': ['25', '30', '35']})\naverage = df['age'].mean()  # ERROR! Strings not numbers\n\n# Mixed types\ndf = pd.DataFrame({'value': [1, 2, '3', 4]})\ntotal = df['value'].sum()  # ERROR! Mixed types\n\n# String operations on numbers\ndf = pd.DataFrame({'code': [101, 102, 103]})\nupper = df['code'].str.upper()  # ERROR! Not strings\nCode Example - CORRECT:\nimport pandas as pd\n\n# Convert to numeric first\ndf = pd.DataFrame({'age': ['25', '30', '35']})\ndf['age'] = pd.to_numeric(df['age'])  # ‚úì Convert\naverage = df['age'].mean()  # ‚úì Works now\n\n# Handle errors in conversion\ndf = pd.DataFrame({'value': ['1', '2', 'invalid', '4']})\ndf['value'] = pd.to_numeric(df['value'], errors='coerce')  # ‚úì NaN for invalid\n# value: [1.0, 2.0, NaN, 4.0]\n\n# Check dtype before operations\nif pd.api.types.is_numeric_dtype(df['age']):\n    average = df['age'].mean()  # ‚úì\nelse:\n    print(\"Not numeric\")\n\n# Convert on creation\ndf = pd.DataFrame({\n    'age': [25, 30, 35]  # ‚úì Use numbers not strings\n})\n\n# Convert to string for string operations\ndf = pd.DataFrame({'code': [101, 102, 103]})\ndf['code'] = df['code'].astype(str)  # ‚úì Convert to string\nupper = df['code'].str.upper()  # ‚úì Now works\n\n# Specify dtypes when reading CSV\ndf = pd.read_csv('data.csv', dtype={'age': int, 'name': str})  # ‚úì\n\n# Handle mixed types\ndf = pd.DataFrame({'value': [1, 2, '3', 4]})\ndf['value'] = df['value'].apply(lambda x: int(x) if isinstance(x, str) else x)  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#adding-and-modifying-data",
    "href": "chapter-12-pandas-basics.html#adding-and-modifying-data",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.5 12.4 Adding and Modifying Data",
    "text": "13.5 12.4 Adding and Modifying Data\n\n13.5.1 Creating and Changing Columns\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob'],\n    'age': [25, 30]\n})\n\n# Add new column\ndf['city'] = 'NYC'  # Same value for all\ndf['salary'] = [50000, 60000]  # Different values\n\n# Create from calculation\ndf['age_in_months'] = df['age'] * 12\n\n# Modify existing column\ndf['age'] = df['age'] + 1\n\n# Conditional creation\ndf['is_adult'] = df['age'] &gt;= 18\n\n# Using .loc for modification\ndf.loc[df['age'] &gt; 30, 'category'] = 'senior'\ndf.loc[df['age'] &lt;= 30, 'category'] = 'junior'\n\n# Apply function\ndf['name_upper'] = df['name'].apply(lambda x: x.upper())\n\n# Rename columns\ndf.rename(columns={'age': 'years'}, inplace=True)\n\n# Drop columns\ndf.drop('city', axis=1, inplace=True)\n# Or\ndf = df.drop(columns=['city'])\n\n\n\n13.5.2 Error Type 4: ValueError: Length of values does not match length of index\nError Message:\n&gt;&gt;&gt; df = pd.DataFrame({'name': ['Alice', 'Bob', 'Charlie']})\n&gt;&gt;&gt; df['age'] = [25, 30]\nTraceback (most recent call last):\n  ...\nValueError: Length of values (2) does not match length of index (3)\nWhat Happened: Trying to assign list with wrong length to column.\nWhy It Happens: - List length doesn‚Äôt match DataFrame rows - Wrong number of values - Off-by-one error\nCode Example - WRONG:\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie']\n})\n\n# Too few values\ndf['age'] = [25, 30]  # ERROR! 2 values, 3 rows\n\n# Too many values\ndf['city'] = ['NYC', 'LA', 'Chicago', 'Boston']  # ERROR! 4 values, 3 rows\nCode Example - CORRECT:\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie']\n})\n\n# Match number of rows\ndf['age'] = [25, 30, 35]  # ‚úì 3 values for 3 rows\n\n# Use single value (broadcasts)\ndf['country'] = 'USA'  # ‚úì Same value for all rows\n\n# Check length first\nages = [25, 30]\nif len(ages) == len(df):\n    df['age'] = ages\nelse:\n    print(f\"Wrong length: need {len(df)}, got {len(ages)}\")\n\n# Pad with default if needed\nages = [25, 30]\nwhile len(ages) &lt; len(df):\n    ages.append(0)  # Pad with 0\ndf['age'] = ages  # ‚úì\n\n# Use .loc for conditional assignment\ndf['age'] = 0  # Initialize\ndf.loc[0, 'age'] = 25\ndf.loc[1, 'age'] = 30\ndf.loc[2, 'age'] = 35  # ‚úì\n\n# Create from Series (index-aligned)\nages = pd.Series([25, 30, 35], index=[0, 1, 2])\ndf['age'] = ages  # ‚úì Aligns by index",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#filtering-data",
    "href": "chapter-12-pandas-basics.html#filtering-data",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.6 12.5 Filtering Data",
    "text": "13.6 12.5 Filtering Data\n\n13.6.1 Boolean Indexing\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'age': [25, 30, 35, 40],\n    'city': ['NYC', 'LA', 'NYC', 'Chicago']\n})\n\n# Single condition\nadults_30plus = df[df['age'] &gt;= 30]\n\n# Multiple conditions (AND)\nresult = df[(df['age'] &gt;= 30) & (df['city'] == 'NYC')]\n\n# Multiple conditions (OR)\nresult = df[(df['age'] &lt; 25) | (df['age'] &gt; 35)]\n\n# NOT condition\nnot_nyc = df[~(df['city'] == 'NYC')]\n# Or\nnot_nyc = df[df['city'] != 'NYC']\n\n# String contains\nin_name = df[df['name'].str.contains('a', case=False)]\n\n# isin() for multiple values\ncities = df[df['city'].isin(['NYC', 'LA'])]\n\n# Between\nage_range = df[df['age'].between(25, 35)]\n\n# Query method (alternative)\nresult = df.query('age &gt;= 30 and city == \"NYC\"')",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#common-operations",
    "href": "chapter-12-pandas-basics.html#common-operations",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.7 12.6 Common Operations",
    "text": "13.7 12.6 Common Operations\n\n13.7.1 Useful DataFrame Operations\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35],\n    'salary': [50000, 60000, 70000]\n})\n\n# Sort\ndf_sorted = df.sort_values('age')\ndf_sorted = df.sort_values('age', ascending=False)\ndf_sorted = df.sort_values(['age', 'salary'])\n\n# Group by\ngrouped = df.groupby('city')['salary'].mean()\ngrouped = df.groupby('city').agg({\n    'age': 'mean',\n    'salary': 'sum'\n})\n\n# Reset index\ndf_reset = df.reset_index(drop=True)\n\n# Set index\ndf_indexed = df.set_index('name')\n\n# Drop duplicates\ndf_unique = df.drop_duplicates()\ndf_unique = df.drop_duplicates(subset=['name'])\n\n# Value counts\ncounts = df['city'].value_counts()\n\n# Unique values\nunique = df['city'].unique()\n\n# Replace values\ndf['city'] = df['city'].replace('NYC', 'New York')\n\n# Map values\ncity_map = {'NYC': 'New York', 'LA': 'Los Angeles'}\ndf['city_full'] = df['city'].map(city_map)",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#practice-problems",
    "href": "chapter-12-pandas-basics.html#practice-problems",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.8 12.7 Practice Problems",
    "text": "13.8 12.7 Practice Problems\n\n13.8.1 Problem 1: KeyError\nimport pandas as pd\ndf = pd.DataFrame({'name': ['Alice'], 'age': [25]})\nprint(df['salary'])\n\n\nClick for Answer\n\nError: KeyError: 'salary'\nFix:\nimport pandas as pd\ndf = pd.DataFrame({'name': ['Alice'], 'age': [25]})\n\n# Check first\nif 'salary' in df.columns:\n    print(df['salary'])\nelse:\n    print(\"Column doesn't exist\")  # ‚úì\n\n# Or add with default\ndf['salary'] = 0\nprint(df['salary'])  # ‚úì\n\n\n\n\n13.8.2 Problem 2: Wrong Indexer\nimport pandas as pd\ndf = pd.DataFrame({'name': ['Alice', 'Bob'], 'age': [25, 30]})\nprint(df.iloc[:, 'age'])\n\n\nClick for Answer\n\nError: ValueError: Location based indexing can only have...\nFix:\nimport pandas as pd\ndf = pd.DataFrame({'name': ['Alice', 'Bob'], 'age': [25, 30]})\n\n# Use .loc for column names\nprint(df.loc[:, 'age'])  # ‚úì\n\n# Or use .iloc with column position\nprint(df.iloc[:, 1])  # ‚úì\n\n# Or direct column access\nprint(df['age'])  # ‚úì\n\n\n\n\n13.8.3 Problem 3: Length Mismatch\nimport pandas as pd\ndf = pd.DataFrame({'name': ['Alice', 'Bob', 'Charlie']})\ndf['age'] = [25, 30]\n\n\nClick for Answer\n\nError: ValueError: Length of values does not match length of index\nFix:\nimport pandas as pd\ndf = pd.DataFrame({'name': ['Alice', 'Bob', 'Charlie']})\n\n# Match number of rows\ndf['age'] = [25, 30, 35]  # ‚úì 3 values\n\n# Or use single value\ndf['age'] = 25  # ‚úì Same for all",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#key-takeaways",
    "href": "chapter-12-pandas-basics.html#key-takeaways",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.9 12.8 Key Takeaways",
    "text": "13.9 12.8 Key Takeaways\n\n13.9.1 What You Learned\n\nCheck columns exist - Use in df.columns\nUse .loc for labels - .iloc for positions\nConvert data types - pd.to_numeric(), .astype()\nMatch lengths - Values must match row count\nUse boolean indexing - For filtering\nHandle missing values - .fillna(), .dropna()\nCheck dtypes - Before operations\n\n\n\n13.9.2 Common Patterns\n# Pattern 1: Safe column access\nif 'column' in df.columns:\n    data = df['column']\n\n# Pattern 2: Convert types\ndf['col'] = pd.to_numeric(df['col'], errors='coerce')\n\n# Pattern 3: Filter data\nfiltered = df[df['age'] &gt;= 30]\n\n# Pattern 4: Add column safely\ndf['new'] = df['old'] * 2\n\n\n13.9.3 Error Summary\n\n\n\n\n\n\n\n\nError\nCause\nPrevention\n\n\n\n\nKeyError\nColumn doesn‚Äôt exist\nCheck with in df.columns\n\n\nValueError (indexing)\nWrong indexer (.iloc vs .loc)\nUse .loc for labels, .iloc for positions\n\n\nTypeError\nWrong data type\nConvert with pd.to_numeric()\n\n\nValueError (length)\nWrong number of values\nMatch DataFrame length",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-12-pandas-basics.html#moving-forward",
    "href": "chapter-12-pandas-basics.html#moving-forward",
    "title": "13¬† Chapter 12: Pandas Basics - DataFrame Errors",
    "section": "13.10 12.9 Moving Forward",
    "text": "13.10 12.9 Moving Forward\nYou now understand Pandas basics! In Chapter 13, we‚Äôll explore Pandas Advanced - merging, pivoting, and complex operations!",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Chapter 12: Pandas Basics - DataFrame Errors</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html",
    "href": "chapter-13-pandas-advanced.html",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "",
    "text": "14.1 Introduction\nYou‚Äôve learned Pandas basics. Now let‚Äôs explore advanced Pandas - merging, joining, pivoting, grouping, and complex data transformations. These skills are essential for real-world data analysis.\nCommon errors: - MergeError: Wrong merge keys - ValueError: Shape mismatches - KeyError: Index/column issues - Memory errors with large datasets\nLet‚Äôs master advanced Pandas!",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#merging-dataframes",
    "href": "chapter-13-pandas-advanced.html#merging-dataframes",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.2 13.1 Merging DataFrames",
    "text": "14.2 13.1 Merging DataFrames\n\n14.2.1 Combining DataFrames\nimport pandas as pd\n\n# Sample data\ndf1 = pd.DataFrame({\n    'id': [1, 2, 3],\n    'name': ['Alice', 'Bob', 'Charlie']\n})\n\ndf2 = pd.DataFrame({\n    'id': [1, 2, 4],\n    'salary': [50000, 60000, 70000]\n})\n\n# Inner join (default)\nmerged = pd.merge(df1, df2, on='id')\n# Only keeps matching rows (id 1, 2)\n\n# Left join\nmerged = pd.merge(df1, df2, on='id', how='left')\n# Keeps all df1 rows, fills NaN for missing df2\n\n# Right join\nmerged = pd.merge(df1, df2, on='id', how='right')\n# Keeps all df2 rows\n\n# Outer join\nmerged = pd.merge(df1, df2, on='id', how='outer')\n# Keeps all rows from both\n\n# Merge on different column names\ndf1 = pd.DataFrame({'emp_id': [1, 2], 'name': ['Alice', 'Bob']})\ndf2 = pd.DataFrame({'employee_id': [1, 2], 'salary': [50000, 60000]})\nmerged = pd.merge(df1, df2, left_on='emp_id', right_on='employee_id')\n\n# Merge on index\nmerged = pd.merge(df1, df2, left_index=True, right_index=True)\n\n\n\n14.2.2 Error Type 1: MergeError or Wrong Results\nWhat Happened: Merge produces unexpected results or errors.\nWhy It Happens: - Wrong merge key - Duplicate keys - Missing values in key columns - Wrong merge type\nCode Example - WRONG:\nimport pandas as pd\n\ndf1 = pd.DataFrame({\n    'id': [1, 2, 3],\n    'name': ['Alice', 'Bob', 'Charlie']\n})\n\ndf2 = pd.DataFrame({\n    'employee_id': [1, 2, 4],  # Different column name!\n    'salary': [50000, 60000, 70000]\n})\n\n# Wrong: merging on non-existent 'id' in df2\nmerged = pd.merge(df1, df2, on='id')  # ERROR or empty result\n\n# Duplicate keys without handling\ndf1 = pd.DataFrame({\n    'id': [1, 1, 2],  # Duplicate id=1\n    'name': ['Alice', 'Alice2', 'Bob']\n})\ndf2 = pd.DataFrame({\n    'id': [1, 1, 2],  # Duplicate id=1\n    'salary': [50000, 55000, 60000]\n})\nmerged = pd.merge(df1, df2, on='id')  # Creates cartesian product!\nCode Example - CORRECT:\nimport pandas as pd\n\ndf1 = pd.DataFrame({\n    'id': [1, 2, 3],\n    'name': ['Alice', 'Bob', 'Charlie']\n})\n\ndf2 = pd.DataFrame({\n    'employee_id': [1, 2, 4],\n    'salary': [50000, 60000, 70000]\n})\n\n# Use left_on and right_on for different names\nmerged = pd.merge(df1, df2, \n                  left_on='id', \n                  right_on='employee_id')  # ‚úì\n\n# Check for duplicates before merging\nprint(\"Duplicates in df1:\", df1['id'].duplicated().sum())\nprint(\"Duplicates in df2:\", df2['employee_id'].duplicated().sum())\n\n# Remove duplicates if needed\ndf1 = df1.drop_duplicates(subset=['id'])  # ‚úì\n\n# Specify how to handle many-to-many\nmerged = pd.merge(df1, df2, on='id', how='left', validate='1:1')  # ‚úì\n# validate options: '1:1', '1:m', 'm:1', 'm:m'\n\n# Check result\nprint(f\"df1 rows: {len(df1)}, df2 rows: {len(df2)}, merged rows: {len(merged)}\")\n\n# Handle missing keys\nmerged = pd.merge(df1, df2, on='id', how='outer', indicator=True)  # ‚úì\n# indicator shows where each row came from",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#concatenating-dataframes",
    "href": "chapter-13-pandas-advanced.html#concatenating-dataframes",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.3 13.2 Concatenating DataFrames",
    "text": "14.3 13.2 Concatenating DataFrames\n\n14.3.1 Stacking DataFrames\nimport pandas as pd\n\ndf1 = pd.DataFrame({\n    'name': ['Alice', 'Bob'],\n    'age': [25, 30]\n})\n\ndf2 = pd.DataFrame({\n    'name': ['Charlie', 'David'],\n    'age': [35, 40]\n})\n\n# Concatenate vertically (stack rows)\ncombined = pd.concat([df1, df2], ignore_index=True)\n\n# Concatenate horizontally (side by side)\ncombined = pd.concat([df1, df2], axis=1)\n\n# With keys to identify source\ncombined = pd.concat([df1, df2], keys=['first', 'second'])\n\n# Only keep common columns\ncombined = pd.concat([df1, df2], join='inner')\n\n\n\n14.3.2 Error Type 2: ValueError: Shape mismatch in concat\nWhat Happened: Concatenating DataFrames with incompatible shapes.\nCode Example - WRONG:\nimport pandas as pd\n\ndf1 = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6]\n})\n\ndf2 = pd.DataFrame({\n    'A': [7, 8],  # Only 2 rows!\n    'C': [9, 10]  # Different column!\n})\n\n# Horizontal concat with different row counts\ncombined = pd.concat([df1, df2], axis=1)  # Fills NaN but might be unexpected\nCode Example - CORRECT:\nimport pandas as pd\n\ndf1 = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6]\n})\n\ndf2 = pd.DataFrame({\n    'A': [7, 8],\n    'C': [9, 10]\n})\n\n# Vertical concat (rows) - works with different columns\ncombined = pd.concat([df1, df2], ignore_index=True)  # ‚úì\n# Fills NaN for missing columns\n\n# Check shapes before concat\nprint(f\"df1: {df1.shape}, df2: {df2.shape}\")\n\n# Reset index if needed\ndf1_reset = df1.reset_index(drop=True)\ndf2_reset = df2.reset_index(drop=True)\ncombined = pd.concat([df1_reset, df2_reset], ignore_index=True)  # ‚úì\n\n# Only keep matching columns for horizontal concat\ncommon_cols = list(set(df1.columns) & set(df2.columns))\nif common_cols:\n    combined = pd.concat([df1[common_cols], df2[common_cols]], axis=1)  # ‚úì\n\n# Use merge instead if you have a key\ncombined = pd.merge(df1, df2, on='A', how='outer')  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#pivot-tables",
    "href": "chapter-13-pandas-advanced.html#pivot-tables",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.4 13.3 Pivot Tables",
    "text": "14.4 13.3 Pivot Tables\n\n14.4.1 Reshaping Data\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'date': ['2024-01', '2024-01', '2024-02', '2024-02'],\n    'city': ['NYC', 'LA', 'NYC', 'LA'],\n    'sales': [100, 150, 200, 175]\n})\n\n# Create pivot table\npivot = df.pivot_table(\n    values='sales',\n    index='date',\n    columns='city',\n    aggfunc='sum'\n)\n#         LA   NYC\n# 2024-01 150  100\n# 2024-02 175  200\n\n# Multiple aggregations\npivot = df.pivot_table(\n    values='sales',\n    index='date',\n    columns='city',\n    aggfunc=['sum', 'mean', 'count']\n)\n\n# Fill missing values\npivot = df.pivot_table(\n    values='sales',\n    index='date',\n    columns='city',\n    aggfunc='sum',\n    fill_value=0\n)\n\n# Melt (reverse of pivot)\nmelted = pivot.reset_index().melt(\n    id_vars=['date'],\n    value_vars=['NYC', 'LA'],\n    var_name='city',\n    value_name='sales'\n)",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#groupby-operations",
    "href": "chapter-13-pandas-advanced.html#groupby-operations",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.5 13.4 GroupBy Operations",
    "text": "14.5 13.4 GroupBy Operations\n\n14.5.1 Aggregating Data\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'city': ['NYC', 'NYC', 'LA', 'LA', 'Chicago'],\n    'year': [2023, 2024, 2023, 2024, 2023],\n    'sales': [100, 150, 200, 175, 90]\n})\n\n# Simple groupby\ngrouped = df.groupby('city')['sales'].sum()\n\n# Multiple columns\ngrouped = df.groupby(['city', 'year'])['sales'].sum()\n\n# Multiple aggregations\ngrouped = df.groupby('city').agg({\n    'sales': ['sum', 'mean', 'count']\n})\n\n# Custom aggregation\ngrouped = df.groupby('city')['sales'].agg(\n    total='sum',\n    average='mean',\n    maximum='max'\n)\n\n# Transform (keep original shape)\ndf['sales_pct'] = df.groupby('city')['sales'].transform(\n    lambda x: x / x.sum() * 100\n)\n\n# Filter groups\nfiltered = df.groupby('city').filter(\n    lambda x: x['sales'].sum() &gt; 200\n)\n\n# Apply custom function\ndef custom_func(group):\n    return group['sales'].max() - group['sales'].min()\n\nresult = df.groupby('city').apply(custom_func)\n\n\n\n14.5.2 Error Type 3: KeyError in GroupBy\nWhat Happened: Column doesn‚Äôt exist in grouped result.\nCode Example - WRONG:\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'city': ['NYC', 'LA'],\n    'sales': [100, 200]\n})\n\n# Groupby returns Series not DataFrame\ngrouped = df.groupby('city')['sales'].sum()\n# Now grouped is a Series\n\n# Trying to access like DataFrame\nresult = grouped['city']  # ERROR! Series doesn't have 'city' column\nCode Example - CORRECT:\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'city': ['NYC', 'LA'],\n    'sales': [100, 200]\n})\n\n# Keep as DataFrame\ngrouped = df.groupby('city')[['sales']].sum()  # ‚úì Double brackets\n# Or\ngrouped = df.groupby('city').sum()  # ‚úì\n\n# Reset index to access groupby column\ngrouped = df.groupby('city')['sales'].sum().reset_index()  # ‚úì\nprint(grouped['city'])  # ‚úì Now works\n\n# Access index directly\ngrouped = df.groupby('city')['sales'].sum()\ncities = grouped.index  # ‚úì Get city names from index\n\n# Use .agg() for DataFrame result\ngrouped = df.groupby('city').agg({'sales': 'sum'})  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#working-with-dates",
    "href": "chapter-13-pandas-advanced.html#working-with-dates",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.6 13.5 Working with Dates",
    "text": "14.6 13.5 Working with Dates\n\n14.6.1 DateTime Operations\nimport pandas as pd\n\n# Create datetime column\ndf = pd.DataFrame({\n    'date_str': ['2024-01-15', '2024-02-20', '2024-03-10']\n})\n\n# Convert to datetime\ndf['date'] = pd.to_datetime(df['date_str'])\n\n# Extract components\ndf['year'] = df['date'].dt.year\ndf['month'] = df['date'].dt.month\ndf['day'] = df['date'].dt.day\ndf['day_of_week'] = df['date'].dt.day_name()\ndf['quarter'] = df['date'].dt.quarter\n\n# Date arithmetic\ndf['next_week'] = df['date'] + pd.Timedelta(days=7)\ndf['last_month'] = df['date'] - pd.DateOffset(months=1)\n\n# Date range\ndates = pd.date_range('2024-01-01', '2024-12-31', freq='D')\n\n# Resample time series\ndf = df.set_index('date')\nmonthly = df.resample('M').sum()\n\n# Rolling windows\ndf['rolling_mean'] = df['sales'].rolling(window=7).mean()",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#apply-and-transform",
    "href": "chapter-13-pandas-advanced.html#apply-and-transform",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.7 13.6 Apply and Transform",
    "text": "14.7 13.6 Apply and Transform\n\n14.7.1 Custom Functions\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'name': ['alice', 'bob', 'charlie'],\n    'age': [25, 30, 35]\n})\n\n# Apply to column (Series)\ndf['name_upper'] = df['name'].apply(lambda x: x.upper())\n\n# Apply to multiple columns\ndf['age_category'] = df['age'].apply(\n    lambda x: 'young' if x &lt; 30 else 'old'\n)\n\n# Apply to DataFrame (row-wise)\ndef categorize(row):\n    if row['age'] &lt; 30:\n        return 'junior'\n    return 'senior'\n\ndf['category'] = df.apply(categorize, axis=1)\n\n# Apply element-wise (applymap) - deprecated, use .map()\ndf_numeric = df[['age']]\ndf_numeric = df_numeric.map(lambda x: x * 2)\n\n# Vectorized operations (FASTER)\ndf['age_doubled'] = df['age'] * 2  # ‚úì Better than apply\ndf['is_adult'] = df['age'] &gt;= 18   # ‚úì Vectorized",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#memory-optimization",
    "href": "chapter-13-pandas-advanced.html#memory-optimization",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.8 13.7 Memory Optimization",
    "text": "14.8 13.7 Memory Optimization\n\n14.8.1 Handling Large DataFrames\nimport pandas as pd\n\n# Read in chunks\nchunk_size = 10000\nchunks = []\nfor chunk in pd.read_csv('large_file.csv', chunksize=chunk_size):\n    # Process chunk\n    processed = chunk[chunk['age'] &gt; 18]\n    chunks.append(processed)\n\ndf = pd.concat(chunks, ignore_index=True)\n\n# Optimize dtypes\ndf['age'] = df['age'].astype('int8')  # Instead of int64\ndf['category'] = df['category'].astype('category')\n\n# Check memory usage\nprint(df.memory_usage(deep=True))\nprint(df.info(memory_usage='deep'))\n\n# Use appropriate dtypes when reading\ndf = pd.read_csv('data.csv', dtype={\n    'age': 'int8',\n    'category': 'category'\n})\n\n# Select columns\ndf = pd.read_csv('data.csv', usecols=['name', 'age'])",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#practice-problems",
    "href": "chapter-13-pandas-advanced.html#practice-problems",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.9 13.8 Practice Problems",
    "text": "14.9 13.8 Practice Problems\n\n14.9.1 Problem 1: Merge Error\nimport pandas as pd\ndf1 = pd.DataFrame({'id': [1, 2], 'name': ['Alice', 'Bob']})\ndf2 = pd.DataFrame({'emp_id': [1, 2], 'salary': [50000, 60000]})\nmerged = pd.merge(df1, df2, on='id')\n\n\nClick for Answer\n\nIssue: Column ‚Äòid‚Äô doesn‚Äôt exist in df2\nFix:\nimport pandas as pd\ndf1 = pd.DataFrame({'id': [1, 2], 'name': ['Alice', 'Bob']})\ndf2 = pd.DataFrame({'emp_id': [1, 2], 'salary': [50000, 60000]})\n\n# Use left_on and right_on\nmerged = pd.merge(df1, df2, left_on='id', right_on='emp_id')  # ‚úì\n\n\n\n\n14.9.2 Problem 2: GroupBy KeyError\nimport pandas as pd\ndf = pd.DataFrame({'city': ['NYC', 'LA'], 'sales': [100, 200]})\ngrouped = df.groupby('city')['sales'].sum()\nprint(grouped['city'])\n\n\nClick for Answer\n\nError: KeyError: 'city'\nWhy: GroupBy result is Series, ‚Äòcity‚Äô is index\nFix:\nimport pandas as pd\ndf = pd.DataFrame({'city': ['NYC', 'LA'], 'sales': [100, 200]})\ngrouped = df.groupby('city')['sales'].sum()\n\n# Reset index\ngrouped = grouped.reset_index()  # ‚úì\nprint(grouped['city'])  # ‚úì Works now\n\n# Or access index\ncities = grouped.index  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#key-takeaways",
    "href": "chapter-13-pandas-advanced.html#key-takeaways",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.10 13.9 Key Takeaways",
    "text": "14.10 13.9 Key Takeaways\n\n14.10.1 What You Learned\n\nSpecify merge keys - Use left_on/right_on\nCheck for duplicates - Before merging\nUse ignore_index - When concatenating\nReset index - After groupby to access columns\nOptimize dtypes - For memory efficiency\nUse vectorized ops - Faster than apply\nProcess in chunks - For large files\n\n\n\n14.10.2 Common Patterns\n# Pattern 1: Safe merge\nmerged = pd.merge(df1, df2, \n                  left_on='id1', \n                  right_on='id2',\n                  how='left')\n\n# Pattern 2: Concat with reset\ncombined = pd.concat([df1, df2], ignore_index=True)\n\n# Pattern 3: GroupBy with reset\nresult = df.groupby('col')['val'].sum().reset_index()\n\n# Pattern 4: Vectorized operations\ndf['new'] = df['old'] * 2  # Better than apply",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-13-pandas-advanced.html#moving-forward",
    "href": "chapter-13-pandas-advanced.html#moving-forward",
    "title": "14¬† Chapter 13: Pandas Advanced - Complex Operations",
    "section": "14.11 13.10 Moving Forward",
    "text": "14.11 13.10 Moving Forward\nYou now understand advanced Pandas! In Chapter 14, we‚Äôll explore NumPy - numerical computing!",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Chapter 13: Pandas Advanced - Complex Operations</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html",
    "href": "chapter-14-numpy.html",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "",
    "text": "15.1 Introduction\nWelcome to NumPy - the foundation of scientific computing in Python! NumPy provides powerful array operations and is the backbone of Pandas, SciPy, and most data science libraries.\nCommon errors: - ValueError: Shape mismatches - IndexError: Array index out of bounds - TypeError: Wrong data types - Broadcasting errors\nLet‚Äôs master NumPy!",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html#creating-arrays",
    "href": "chapter-14-numpy.html#creating-arrays",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "15.2 14.1 Creating Arrays",
    "text": "15.2 14.1 Creating Arrays\n\n15.2.1 Basic Array Creation\nimport numpy as np\n\n# From list\narr = np.array([1, 2, 3, 4, 5])\n\n# 2D array\narr_2d = np.array([[1, 2, 3], [4, 5, 6]])\n\n# Zeros\nzeros = np.zeros(5)          # [0. 0. 0. 0. 0.]\nzeros_2d = np.zeros((3, 4))  # 3x4 matrix of zeros\n\n# Ones\nones = np.ones(3)            # [1. 1. 1.]\nones_2d = np.ones((2, 3))    # 2x3 matrix of ones\n\n# Range\narr = np.arange(0, 10, 2)    # [0 2 4 6 8]\n\n# Linspace\narr = np.linspace(0, 1, 5)   # [0. 0.25 0.5 0.75 1.]\n\n# Random\nrandom = np.random.rand(5)    # 5 random numbers [0, 1)\nrandom = np.random.randint(0, 10, 5)  # 5 random ints\n\n# Identity matrix\nidentity = np.eye(3)          # 3x3 identity matrix\n\n# Array info\nprint(arr.shape)    # Dimensions\nprint(arr.dtype)    # Data type\nprint(arr.size)     # Total elements\nprint(arr.ndim)     # Number of dimensions\n\n\n\n15.2.2 Error Type 1: ValueError: setting an array element with a sequence\nError Message:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([1, 2, [3, 4]])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: setting an array element with a sequence.\nWhat Happened: Trying to create array with inconsistent dimensions.\nWhy It Happens: - Nested lists of different lengths - Mixed types in nested structure - Jagged arrays\nCode Example - WRONG:\nimport numpy as np\n\n# Inconsistent lengths\narr = np.array([[1, 2, 3], [4, 5]])  # ERROR! Different lengths\n\n# Mixed nesting\narr = np.array([1, 2, [3, 4]])  # ERROR! Inconsistent depth\n\n# Jagged array\ndata = [[1, 2], [3, 4, 5], [6]]\narr = np.array(data)  # ERROR or unexpected result\nCode Example - CORRECT:\nimport numpy as np\n\n# Consistent dimensions\narr = np.array([[1, 2, 3], [4, 5, 6]])  # ‚úì 2x3 array\n\n# Same nesting level\narr = np.array([1, 2, 3, 4])  # ‚úì 1D array\narr = np.array([[1, 2], [3, 4]])  # ‚úì 2D array\n\n# For jagged arrays, use dtype=object\ndata = [[1, 2], [3, 4, 5], [6]]\narr = np.array(data, dtype=object)  # ‚úì Array of lists\n\n# Or pad to same length\nmax_len = max(len(row) for row in data)\npadded = [row + [0] * (max_len - len(row)) for row in data]\narr = np.array(padded)  # ‚úì\n\n# Check before creating\ndata = [[1, 2, 3], [4, 5, 6]]\nlengths = [len(row) for row in data]\nif len(set(lengths)) == 1:\n    arr = np.array(data)  # ‚úì All same length\nelse:\n    print(\"Inconsistent lengths\")",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html#array-indexing-and-slicing",
    "href": "chapter-14-numpy.html#array-indexing-and-slicing",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "15.3 14.2 Array Indexing and Slicing",
    "text": "15.3 14.2 Array Indexing and Slicing\n\n15.3.1 Accessing Elements\nimport numpy as np\n\narr = np.array([10, 20, 30, 40, 50])\n\n# Single element\nprint(arr[0])    # 10\nprint(arr[-1])   # 50\n\n# Slicing\nprint(arr[1:4])  # [20 30 40]\nprint(arr[:3])   # [10 20 30]\nprint(arr[2:])   # [30 40 50]\n\n# 2D array\narr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n# Single element\nprint(arr_2d[0, 0])     # 1\nprint(arr_2d[1, 2])     # 6\n\n# Row\nprint(arr_2d[0])        # [1 2 3]\nprint(arr_2d[0, :])     # [1 2 3]\n\n# Column\nprint(arr_2d[:, 0])     # [1 4 7]\n\n# Subarray\nprint(arr_2d[0:2, 1:3]) # [[2 3]\n                        #  [5 6]]\n\n# Boolean indexing\narr = np.array([1, 2, 3, 4, 5])\nmask = arr &gt; 2\nprint(arr[mask])        # [3 4 5]\nprint(arr[arr &gt; 2])     # [3 4 5]\n\n# Fancy indexing\nindices = [0, 2, 4]\nprint(arr[indices])     # [1 3 5]\n\n\n\n15.3.2 Error Type 2: IndexError: index out of bounds\nError Message:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([1, 2, 3])\n&gt;&gt;&gt; print(arr[5])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: index 5 is out of bounds for axis 0 with size 3\nWhat Happened: Index exceeds array bounds.\nCode Example - WRONG:\nimport numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\n# Index too large\nvalue = arr[10]  # ERROR! Only indices 0-4 exist\n\n# Wrong dimension count\narr_2d = np.array([[1, 2], [3, 4]])\nvalue = arr_2d[0, 5]  # ERROR! Column 5 doesn't exist\n\n# Negative index too large\nvalue = arr[-10]  # ERROR! Only -1 to -5 valid\nCode Example - CORRECT:\nimport numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\n# Check bounds\nif index &lt; len(arr):\n    value = arr[index]  # ‚úì\nelse:\n    print(\"Index out of bounds\")\n\n# Use .shape for multi-dimensional\narr_2d = np.array([[1, 2, 3], [4, 5, 6]])\nrows, cols = arr_2d.shape\nif row &lt; rows and col &lt; cols:\n    value = arr_2d[row, col]  # ‚úì\n\n# Use try/except\ntry:\n    value = arr[index]\nexcept IndexError:\n    value = None  # ‚úì\n\n# Safe indexing with clip\nsafe_index = np.clip(index, 0, len(arr) - 1)\nvalue = arr[safe_index]  # ‚úì\n\n# Use take with mode\nvalue = arr.take(index, mode='clip')  # ‚úì Clips to valid range\nvalue = arr.take(index, mode='wrap')  # ‚úì Wraps around",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html#array-operations",
    "href": "chapter-14-numpy.html#array-operations",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "15.4 14.3 Array Operations",
    "text": "15.4 14.3 Array Operations\n\n15.4.1 Mathematical Operations\nimport numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\n# Element-wise operations\nprint(arr + 10)      # [11 12 13 14 15]\nprint(arr * 2)       # [2 4 6 8 10]\nprint(arr ** 2)      # [1 4 9 16 25]\n\n# Array operations\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\nprint(arr1 + arr2)   # [5 7 9]\nprint(arr1 * arr2)   # [4 10 18]\n\n# Aggregations\nprint(arr.sum())     # 15\nprint(arr.mean())    # 3.0\nprint(arr.std())     # Standard deviation\nprint(arr.min())     # 1\nprint(arr.max())     # 5\n\n# Along axis\narr_2d = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr_2d.sum(axis=0))  # [5 7 9] column sums\nprint(arr_2d.sum(axis=1))  # [6 15] row sums\n\n# Universal functions\nprint(np.sqrt(arr))    # Square root\nprint(np.exp(arr))     # Exponential\nprint(np.log(arr))     # Natural log\nprint(np.sin(arr))     # Sine\n\n\n\n15.4.2 Error Type 3: ValueError: operands could not be broadcast together\nError Message:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr1 = np.array([1, 2, 3])\n&gt;&gt;&gt; arr2 = np.array([1, 2])\n&gt;&gt;&gt; result = arr1 + arr2\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,) (2,)\nWhat Happened: Trying to operate on arrays with incompatible shapes.\nWhy It Happens: - Different array sizes - Incompatible dimensions - Wrong broadcasting\nCode Example - WRONG:\nimport numpy as np\n\n# Different lengths\narr1 = np.array([1, 2, 3])\narr2 = np.array([1, 2])\nresult = arr1 + arr2  # ERROR! Shapes (3,) and (2,)\n\n# Incompatible 2D shapes\narr1 = np.array([[1, 2, 3], [4, 5, 6]])  # 2x3\narr2 = np.array([[1, 2], [3, 4]])        # 2x2\nresult = arr1 + arr2  # ERROR! Incompatible\n\n# Wrong dimension operations\narr1 = np.array([[1, 2], [3, 4]])  # 2x2\narr2 = np.array([1, 2, 3])         # 3 elements\nresult = arr1 + arr2  # ERROR! Can't broadcast\nCode Example - CORRECT:\nimport numpy as np\n\n# Match array sizes\narr1 = np.array([1, 2, 3])\narr2 = np.array([1, 2, 3])  # ‚úì Same size\nresult = arr1 + arr2\n\n# Broadcasting with scalar\narr = np.array([1, 2, 3])\nresult = arr + 10  # ‚úì Scalar broadcasts to all elements\n\n# Broadcasting with compatible shapes\narr1 = np.array([[1, 2, 3], [4, 5, 6]])  # 2x3\narr2 = np.array([10, 20, 30])            # 3 elements\nresult = arr1 + arr2  # ‚úì Broadcasts arr2 to each row\n# [[11 22 33]\n#  [14 25 36]]\n\n# Reshape for broadcasting\narr1 = np.array([[1, 2], [3, 4]])  # 2x2\narr2 = np.array([10, 20])          # 2 elements\nresult = arr1 + arr2  # ‚úì Broadcasts across columns\n\n# Make compatible with reshape\narr1 = np.array([[1, 2], [3, 4]])    # 2x2\narr2 = np.array([10, 20])            # 2 elements\narr2_reshaped = arr2.reshape(2, 1)   # 2x1\nresult = arr1 + arr2_reshaped  # ‚úì\n# [[11 12]\n#  [23 24]]\n\n# Check shapes before operation\nif arr1.shape == arr2.shape:\n    result = arr1 + arr2  # ‚úì\nelse:\n    print(f\"Incompatible: {arr1.shape} vs {arr2.shape}\")\n\n# Pad shorter array\narr1 = np.array([1, 2, 3])\narr2 = np.array([1, 2])\narr2_padded = np.pad(arr2, (0, len(arr1) - len(arr2)))  # ‚úì\nresult = arr1 + arr2_padded\nBroadcasting Rules:\n# Arrays broadcast when:\n# 1. They have same shape\n# 2. One dimension is 1\n# 3. One array has fewer dimensions\n\n# Examples:\n# (3, 4) + (3, 4)     ‚úì Same shape\n# (3, 4) + (4,)       ‚úì Broadcasts to (3, 4)\n# (3, 4) + (3, 1)     ‚úì Broadcasts to (3, 4)\n# (3, 4) + (1, 4)     ‚úì Broadcasts to (3, 4)\n# (3, 4) + (3, 5)     ‚úó Incompatible",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html#reshaping-arrays",
    "href": "chapter-14-numpy.html#reshaping-arrays",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "15.5 14.4 Reshaping Arrays",
    "text": "15.5 14.4 Reshaping Arrays\n\n15.5.1 Changing Array Shape\nimport numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6])\n\n# Reshape\narr_2d = arr.reshape(2, 3)  # 2x3\n# [[1 2 3]\n#  [4 5 6]]\n\n# Flatten\narr_flat = arr_2d.flatten()  # [1 2 3 4 5 6]\narr_flat = arr_2d.ravel()    # Same but returns view\n\n# Transpose\narr_t = arr_2d.T\n# [[1 4]\n#  [2 5]\n#  [3 6]]\n\n# Add dimension\narr_3d = arr[np.newaxis, :]    # (1, 6)\narr_3d = arr[:, np.newaxis]    # (6, 1)\n\n# Squeeze (remove single dimensions)\narr = np.array([[[1, 2, 3]]])  # (1, 1, 3)\narr_squeezed = arr.squeeze()   # (3,)\n\n\n\n15.5.2 Error Type 4: ValueError: cannot reshape array\nError Message:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([1, 2, 3, 4, 5])\n&gt;&gt;&gt; arr.reshape(2, 3)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot reshape array of size 5 into shape (2,3)\nWhat Happened: New shape doesn‚Äôt match total number of elements.\nCode Example - WRONG:\nimport numpy as np\n\n# Wrong total elements\narr = np.array([1, 2, 3, 4, 5])  # 5 elements\narr_2d = arr.reshape(2, 3)  # ERROR! 2*3=6 ‚â† 5\n\n# Incompatible shape\narr = np.array([1, 2, 3, 4])  # 4 elements\narr_2d = arr.reshape(3, 2)  # ERROR! 3*2=6 ‚â† 4\nCode Example - CORRECT:\nimport numpy as np\n\n# Matching total elements\narr = np.array([1, 2, 3, 4, 5, 6])  # 6 elements\narr_2d = arr.reshape(2, 3)  # ‚úì 2*3=6\narr_2d = arr.reshape(3, 2)  # ‚úì 3*2=6\n\n# Use -1 to infer dimension\narr = np.array([1, 2, 3, 4, 5, 6])\narr_2d = arr.reshape(2, -1)  # ‚úì Auto-calculates 3\narr_2d = arr.reshape(-1, 3)  # ‚úì Auto-calculates 2\n\n# Check if reshapeable\nif arr.size % 3 == 0:\n    arr_2d = arr.reshape(-1, 3)  # ‚úì\nelse:\n    print(\"Cannot reshape to 3 columns\")\n\n# Pad to make reshapeable\narr = np.array([1, 2, 3, 4, 5])  # 5 elements\ntarget_size = 6\narr_padded = np.pad(arr, (0, target_size - arr.size))  # ‚úì\narr_2d = arr_padded.reshape(2, 3)\n\n# Use resize (changes size)\narr = np.array([1, 2, 3, 4, 5])\narr.resize((2, 3))  # ‚úì Pads with zeros\n# [[1 2 3]\n#  [4 5 0]]",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html#common-patterns",
    "href": "chapter-14-numpy.html#common-patterns",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "15.6 14.5 Common Patterns",
    "text": "15.6 14.5 Common Patterns\n\n15.6.1 Useful Operations\nimport numpy as np\n\n# Stacking arrays\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\nstacked_v = np.vstack([arr1, arr2])  # Vertical\n# [[1 2 3]\n#  [4 5 6]]\nstacked_h = np.hstack([arr1, arr2])  # Horizontal\n# [1 2 3 4 5 6]\n\n# Where (conditional selection)\narr = np.array([1, 2, 3, 4, 5])\nresult = np.where(arr &gt; 2, arr, 0)  # [0 0 3 4 5]\n\n# Unique values\narr = np.array([1, 2, 2, 3, 3, 3])\nunique = np.unique(arr)  # [1 2 3]\n\n# Sorting\narr = np.array([3, 1, 4, 1, 5])\nsorted_arr = np.sort(arr)  # [1 1 3 4 5]\nindices = np.argsort(arr)  # [1 3 0 2 4]\n\n# Finding elements\narr = np.array([1, 2, 3, 4, 5])\nindices = np.where(arr &gt; 3)  # (array([3, 4]),)",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html#practice-problems",
    "href": "chapter-14-numpy.html#practice-problems",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "15.7 14.6 Practice Problems",
    "text": "15.7 14.6 Practice Problems\n\n15.7.1 Problem 1: Shape Mismatch\nimport numpy as np\narr1 = np.array([1, 2, 3])\narr2 = np.array([1, 2])\nresult = arr1 + arr2\n\n\nClick for Answer\n\nError: ValueError: operands could not be broadcast together\nFix:\nimport numpy as np\narr1 = np.array([1, 2, 3])\narr2 = np.array([1, 2, 3])  # ‚úì Match sizes\nresult = arr1 + arr2\n\n\n\n\n15.7.2 Problem 2: Reshape Error\nimport numpy as np\narr = np.array([1, 2, 3, 4, 5])\narr_2d = arr.reshape(2, 3)\n\n\nClick for Answer\n\nError: ValueError: cannot reshape array of size 5 into shape (2,3)\nFix:\nimport numpy as np\narr = np.array([1, 2, 3, 4, 5, 6])  # ‚úì 6 elements\narr_2d = arr.reshape(2, 3)  # ‚úì 2*3=6\n\n# Or use -1\narr = np.array([1, 2, 3, 4, 5, 6])\narr_2d = arr.reshape(2, -1)  # ‚úì Auto-calculates 3",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html#key-takeaways",
    "href": "chapter-14-numpy.html#key-takeaways",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "15.8 14.7 Key Takeaways",
    "text": "15.8 14.7 Key Takeaways\n\n15.8.1 What You Learned\n\nMatch array dimensions - For operations\nCheck shapes - Before reshaping\nUse broadcasting - For efficient operations\nValidate indices - Before accessing\nConsistent nesting - For array creation\nUse -1 in reshape - To infer dimension\nVectorize operations - Avoid loops",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-14-numpy.html#moving-forward",
    "href": "chapter-14-numpy.html#moving-forward",
    "title": "15¬† Chapter 14: NumPy - Array Computing Errors",
    "section": "15.9 14.8 Moving Forward",
    "text": "15.9 14.8 Moving Forward\nYou now understand NumPy! In Chapter 15, we‚Äôll explore Matplotlib - data visualization!",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Chapter 14: NumPy - Array Computing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html",
    "href": "chapter-15-matplotlib.html",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "",
    "text": "16.1 Introduction\nWelcome to Matplotlib - Python‚Äôs primary plotting library! Matplotlib creates publication-quality figures and is the foundation for many other visualization libraries.\nCommon errors: - ValueError: Invalid data shapes - TypeError: Wrong data types for plots - AttributeError: Wrong method or property - Figure/axis confusion\nLet‚Äôs master Matplotlib!",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#basic-plotting",
    "href": "chapter-15-matplotlib.html#basic-plotting",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.2 15.1 Basic Plotting",
    "text": "16.2 15.1 Basic Plotting\n\n16.2.1 Creating Simple Plots\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Line plot\nx = [1, 2, 3, 4, 5]\ny = [2, 4, 6, 8, 10]\nplt.plot(x, y)\nplt.xlabel('X axis')\nplt.ylabel('Y axis')\nplt.title('Simple Line Plot')\nplt.show()\n\n# Multiple lines\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\nplt.plot(x, y1, label='sin(x)')\nplt.plot(x, y2, label='cos(x)')\nplt.legend()\nplt.show()\n\n# Scatter plot\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\nplt.scatter(x, y)\nplt.show()\n\n# Bar plot\ncategories = ['A', 'B', 'C', 'D']\nvalues = [4, 7, 2, 9]\nplt.bar(categories, values)\nplt.show()\n\n# Histogram\ndata = np.random.randn(1000)\nplt.hist(data, bins=30)\nplt.show()\n\n\n\n16.2.2 Error Type 1: ValueError: x and y must have same first dimension\nError Message:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; y = [1, 2]\n&gt;&gt;&gt; plt.plot(x, y)\nTraceback (most recent call last):\n  ...\nValueError: x and y must have same first dimension, but have shapes (3,) and (2,)\nWhat Happened: X and Y arrays have different lengths.\nWhy It Happens: - Different array sizes - Data mismatch - Missing values\nCode Example - WRONG:\nimport matplotlib.pyplot as plt\n\n# Different lengths\nx = [1, 2, 3, 4, 5]\ny = [2, 4, 6]  # Only 3 values\nplt.plot(x, y)  # ERROR! 5 vs 3\n\n# Accidental truncation\nx = range(10)\ny = [i**2 for i in range(5)]  # Only 5 values\nplt.plot(x, y)  # ERROR!\nCode Example - CORRECT:\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Match lengths\nx = [1, 2, 3, 4, 5]\ny = [2, 4, 6, 8, 10]  # ‚úì 5 values\nplt.plot(x, y)\nplt.show()\n\n# Check lengths before plotting\nif len(x) == len(y):\n    plt.plot(x, y)  # ‚úì\nelse:\n    print(f\"Length mismatch: {len(x)} vs {len(y)}\")\n\n# Generate matching arrays\nx = np.linspace(0, 10, 100)\ny = x ** 2  # ‚úì Automatically same length\nplt.plot(x, y)\n\n# Truncate to shorter length\nmin_len = min(len(x), len(y))\nplt.plot(x[:min_len], y[:min_len])  # ‚úì\n\n# Fill missing values\nx = [1, 2, 3, 4, 5]\ny = [2, 4, 6]\nwhile len(y) &lt; len(x):\n    y.append(0)  # ‚úì Pad with zeros\nplt.plot(x, y)",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#subplots",
    "href": "chapter-15-matplotlib.html#subplots",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.3 15.2 Subplots",
    "text": "16.3 15.2 Subplots\n\n16.3.1 Multiple Plots\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create figure with subplots\nfig, axes = plt.subplots(2, 2, figsize=(10, 8))\n\nx = np.linspace(0, 10, 100)\n\n# Access subplots\naxes[0, 0].plot(x, np.sin(x))\naxes[0, 0].set_title('Sine')\n\naxes[0, 1].plot(x, np.cos(x))\naxes[0, 1].set_title('Cosine')\n\naxes[1, 0].plot(x, x**2)\naxes[1, 0].set_title('Square')\n\naxes[1, 1].plot(x, np.exp(x/10))\naxes[1, 1].set_title('Exponential')\n\nplt.tight_layout()\nplt.show()\n\n# Single row\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\nfor i, ax in enumerate(axes):\n    ax.plot(x, x**i)\n    ax.set_title(f'x^{i}')\nplt.show()\n\n\n\n16.3.2 Error Type 2: AttributeError: 'numpy.ndarray' object has no attribute 'plot'\nError Message:\n&gt;&gt;&gt; fig, axes = plt.subplots(2, 2)\n&gt;&gt;&gt; axes.plot([1, 2, 3])\nTraceback (most recent call last):\n  ...\nAttributeError: 'numpy.ndarray' object has no attribute 'plot'\nWhat Happened: Calling plot() on axes array instead of individual axis.\nWhy It Happens: - Confusing axes array with single axis - Wrong indexing - Not understanding subplots return type\nCode Example - WRONG:\nimport matplotlib.pyplot as plt\n\n# Multiple subplots - axes is array\nfig, axes = plt.subplots(2, 2)\naxes.plot([1, 2, 3])  # ERROR! axes is array\n\n# Wrong method on figure\nfig = plt.figure()\nfig.plot([1, 2, 3])  # ERROR! Use ax, not fig\nCode Example - CORRECT:\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Single subplot - axes is single axis\nfig, ax = plt.subplots()\nax.plot([1, 2, 3])  # ‚úì ax is single axis\nplt.show()\n\n# Multiple subplots - index into array\nfig, axes = plt.subplots(2, 2)\naxes[0, 0].plot([1, 2, 3])  # ‚úì Index specific axis\naxes[0, 1].plot([1, 4, 9])  # ‚úì\nplt.show()\n\n# Flatten for easy iteration\nfig, axes = plt.subplots(2, 2)\naxes_flat = axes.flatten()\nfor i, ax in enumerate(axes_flat):\n    ax.plot([1, 2, 3])  # ‚úì\nplt.show()\n\n# Use plt.subplot (different approach)\nplt.subplot(2, 2, 1)\nplt.plot([1, 2, 3])  # ‚úì\nplt.subplot(2, 2, 2)\nplt.plot([1, 4, 9])  # ‚úì\nplt.show()\n\n# Check type\nfig, axes = plt.subplots(2, 2)\nif isinstance(axes, np.ndarray):\n    for ax in axes.flat:\n        ax.plot([1, 2, 3])  # ‚úì\nelse:\n    axes.plot([1, 2, 3])  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#customizing-plots",
    "href": "chapter-15-matplotlib.html#customizing-plots",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.4 15.3 Customizing Plots",
    "text": "16.4 15.3 Customizing Plots\n\n16.4.1 Styling and Formatting\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\n# Line style and color\nplt.plot(x, y, \n         color='red',       # or 'r', '#FF0000', (1, 0, 0)\n         linestyle='--',    # or ':', '-.', '-'\n         linewidth=2,\n         marker='o',\n         markersize=5,\n         label='sin(x)')\n\n# Grid\nplt.grid(True, alpha=0.3)\n\n# Limits\nplt.xlim(0, 10)\nplt.ylim(-1.5, 1.5)\n\n# Labels\nplt.xlabel('Time', fontsize=12)\nplt.ylabel('Value', fontsize=12)\nplt.title('Sine Wave', fontsize=14, fontweight='bold')\n\n# Legend\nplt.legend(loc='upper right')\n\n# Save figure\nplt.savefig('plot.png', dpi=300, bbox_inches='tight')\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#different-plot-types",
    "href": "chapter-15-matplotlib.html#different-plot-types",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.5 15.4 Different Plot Types",
    "text": "16.5 15.4 Different Plot Types\n\n16.5.1 Common Visualizations\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Scatter with colors\nx = np.random.rand(50)\ny = np.random.rand(50)\ncolors = np.random.rand(50)\nsizes = 1000 * np.random.rand(50)\nplt.scatter(x, y, c=colors, s=sizes, alpha=0.5, cmap='viridis')\nplt.colorbar()\nplt.show()\n\n# Bar plot\ncategories = ['A', 'B', 'C', 'D', 'E']\nvalues = [23, 45, 56, 78, 32]\nplt.bar(categories, values, color='steelblue')\nplt.xticks(rotation=45)\nplt.show()\n\n# Horizontal bar\nplt.barh(categories, values, color='coral')\nplt.show()\n\n# Histogram\ndata = np.random.randn(1000)\nplt.hist(data, bins=30, color='skyblue', edgecolor='black')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\nplt.show()\n\n# Box plot\ndata = [np.random.normal(0, std, 100) for std in range(1, 4)]\nplt.boxplot(data, labels=['Group 1', 'Group 2', 'Group 3'])\nplt.show()\n\n# Pie chart\nsizes = [30, 25, 20, 25]\nlabels = ['A', 'B', 'C', 'D']\nplt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)\nplt.axis('equal')\nplt.show()\n\n# Heatmap\ndata = np.random.rand(10, 10)\nplt.imshow(data, cmap='hot', interpolation='nearest')\nplt.colorbar()\nplt.show()\n\n\n\n16.5.2 Error Type 3: TypeError: Image data of dtype object cannot be converted to float\nWhat Happened: Wrong data type for plot.\nCode Example - WRONG:\nimport matplotlib.pyplot as plt\n\n# String data for numerical plot\ndata = ['a', 'b', 'c']\nplt.plot(data)  # ERROR! Can't plot strings\n\n# Mixed types\nx = [1, 2, '3', 4]\ny = [1, 4, 9, 16]\nplt.plot(x, y)  # ERROR! Mixed types\nCode Example - CORRECT:\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Convert to numbers\ndata = ['1', '2', '3', '4']\ndata_numeric = [float(x) for x in data]  # ‚úì\nplt.plot(data_numeric)\n\n# Use categorical plot for strings\ncategories = ['A', 'B', 'C', 'D']\nvalues = [1, 3, 2, 4]\nplt.bar(categories, values)  # ‚úì\n\n# Handle missing/invalid data\ndata = [1, 2, None, 4, 5]\ndata_clean = [x for x in data if x is not None]  # ‚úì\nplt.plot(data_clean)\n\n# Use pandas for automatic handling\nimport pandas as pd\ndf = pd.DataFrame({'x': [1, 2, 3], 'y': [1, 4, 9]})\ndf.plot(x='x', y='y')  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#common-patterns",
    "href": "chapter-15-matplotlib.html#common-patterns",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.6 15.5 Common Patterns",
    "text": "16.6 15.5 Common Patterns\n\n16.6.1 Useful Techniques\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Multiple y-axes\nfig, ax1 = plt.subplots()\nax2 = ax1.twinx()\n\nx = np.linspace(0, 10, 100)\nax1.plot(x, np.sin(x), 'b-')\nax2.plot(x, x**2, 'r-')\nax1.set_ylabel('sin(x)', color='b')\nax2.set_ylabel('x^2', color='r')\n\n# Annotations\nplt.plot([1, 2, 3, 4], [1, 4, 9, 16])\nplt.annotate('Peak', xy=(4, 16), xytext=(3, 12),\n             arrowprops=dict(arrowstyle='-&gt;'))\n\n# Fill between\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\nplt.plot(x, y1)\nplt.plot(x, y2)\nplt.fill_between(x, y1, y2, alpha=0.3)\n\n# Log scale\nplt.plot(x, np.exp(x))\nplt.yscale('log')\n\n# Style sheets\nplt.style.use('seaborn')  # or 'ggplot', 'dark_background'",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#practice-problems",
    "href": "chapter-15-matplotlib.html#practice-problems",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.7 15.6 Practice Problems",
    "text": "16.7 15.6 Practice Problems\n\n16.7.1 Problem 1: Length Mismatch\nimport matplotlib.pyplot as plt\nx = [1, 2, 3, 4, 5]\ny = [1, 4, 9]\nplt.plot(x, y)\n\n\nClick for Answer\n\nError: ValueError: x and y must have same first dimension\nFix:\nimport matplotlib.pyplot as plt\nx = [1, 2, 3, 4, 5]\ny = [1, 4, 9, 16, 25]  # ‚úì Match length\nplt.plot(x, y)\nplt.show()\n\n\n\n\n16.7.2 Problem 2: Wrong Axes Access\nimport matplotlib.pyplot as plt\nfig, axes = plt.subplots(2, 2)\naxes.plot([1, 2, 3])\n\n\nClick for Answer\n\nError: AttributeError: 'numpy.ndarray' object has no attribute 'plot'\nFix:\nimport matplotlib.pyplot as plt\nfig, axes = plt.subplots(2, 2)\naxes[0, 0].plot([1, 2, 3])  # ‚úì Index specific axis\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#key-takeaways",
    "href": "chapter-15-matplotlib.html#key-takeaways",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.8 15.7 Key Takeaways",
    "text": "16.8 15.7 Key Takeaways\n\n16.8.1 What You Learned\n\nMatch array lengths - X and Y must be same size\nIndex subplot axes - axes[i, j] for multiple plots\nUse ax methods - Not plt when using subplots\nCheck data types - Convert strings to numbers\nUse tight_layout() - Prevent overlapping\nSave before show() - Or figure won‚Äôt save\nClose figures - plt.close() to free memory\n\n\n\n16.8.2 Common Patterns\n# Pattern 1: Basic plot\nplt.plot(x, y)\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('Title')\nplt.show()\n\n# Pattern 2: Subplots\nfig, axes = plt.subplots(2, 2)\naxes[0, 0].plot(x, y)\nplt.tight_layout()\nplt.show()\n\n# Pattern 3: Save figure\nplt.plot(x, y)\nplt.savefig('plot.png', dpi=300)\nplt.show()\n\n\n16.8.3 Error Summary\n\n\n\n\n\n\n\n\nError\nCause\nPrevention\n\n\n\n\nValueError (dimension)\nX and Y different lengths\nMatch array sizes\n\n\nAttributeError\nWrong axes access\nIndex axes array properly\n\n\nTypeError\nWrong data type\nConvert to numeric",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#congratulations---part-ii-complete",
    "href": "chapter-15-matplotlib.html#congratulations---part-ii-complete",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.9 15.8 Congratulations - Part II Complete!",
    "text": "16.9 15.8 Congratulations - Part II Complete!\n\n16.9.1 üéâ You Completed Part II: Libraries and Data!\nYou‚Äôve mastered: - ‚úÖ Regular Expressions (Chapter 11) - ‚úÖ Pandas Basics (Chapter 12) - ‚úÖ Pandas Advanced (Chapter 13) - ‚úÖ NumPy (Chapter 14) - ‚úÖ Matplotlib (Chapter 15)\nTotal Progress: 15/20 chapters (75%) complete!",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-15-matplotlib.html#moving-forward",
    "href": "chapter-15-matplotlib.html#moving-forward",
    "title": "16¬† Chapter 15: Matplotlib - Data Visualization Errors",
    "section": "16.10 15.9 Moving Forward",
    "text": "16.10 15.9 Moving Forward\nWhat‚Äôs Next: Part III - Advanced Topics (Chapters 16-20) - Chapter 16: Object-Oriented Programming - Chapter 17: Modules and Imports - Chapter 18: Exception Handling - Chapter 19: Debugging Techniques - Chapter 20: Testing and Code Quality",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Chapter 15: Matplotlib - Data Visualization Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html",
    "href": "chapter-16-oop.html",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "",
    "text": "17.1 Introduction\nWelcome to Object-Oriented Programming (OOP) - organizing code into classes and objects. OOP is fundamental to Python and most modern programming. Understanding OOP errors is essential for building robust applications.\nCommon errors: - AttributeError: Missing attributes or methods - TypeError: Wrong initialization or method calls - NameError: Class/method not defined - Inheritance issues\nLet‚Äôs master OOP!",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#classes-and-objects",
    "href": "chapter-16-oop.html#classes-and-objects",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.2 16.1 Classes and Objects",
    "text": "17.2 16.1 Classes and Objects\n\n17.2.1 Basic Class Definition\n# Define a class\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name  # Instance attribute\n        self.age = age\n    \n    def bark(self):\n        return f\"{self.name} says woof!\"\n    \n    def get_age(self):\n        return self.age\n\n# Create objects (instances)\ndog1 = Dog(\"Buddy\", 5)\ndog2 = Dog(\"Max\", 3)\n\n# Access attributes\nprint(dog1.name)  # \"Buddy\"\nprint(dog2.age)   # 3\n\n# Call methods\nprint(dog1.bark())  # \"Buddy says woof!\"\n\n# Class attributes (shared by all instances)\nclass Cat:\n    species = \"Felis catus\"  # Class attribute\n    \n    def __init__(self, name):\n        self.name = name  # Instance attribute\n\ncat1 = Cat(\"Whiskers\")\ncat2 = Cat(\"Mittens\")\nprint(cat1.species)  # \"Felis catus\"\nprint(cat2.species)  # \"Felis catus\"\n\n\n\n17.2.2 Error Type 1: TypeError: __init__() missing required positional argument\nError Message:\n&gt;&gt;&gt; class Dog:\n...     def __init__(self, name, age):\n...         self.name = name\n...         self.age = age\n&gt;&gt;&gt; dog = Dog(\"Buddy\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: __init__() missing 1 required positional argument: 'age'\nWhat Happened: Creating object without providing all required parameters.\nWhy It Happens: - Missing arguments in initialization - Wrong number of arguments - Forgetting self parameter\nCode Example - WRONG:\nclass Person:\n    def __init__(self, name, age, city):\n        self.name = name\n        self.age = age\n        self.city = city\n\n# Missing arguments\nperson = Person(\"Alice\")  # ERROR! Missing age and city\n\n# Too many arguments\nperson = Person(\"Alice\", 25, \"NYC\", \"USA\")  # ERROR! Too many\n\n# Wrong argument order\nperson = Person(25, \"Alice\", \"NYC\")  # Wrong but no error (logic issue)\n\n# Forgetting to pass arguments\nclass Car:\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n\ncar = Car()  # ERROR! Missing make and model\nCode Example - CORRECT:\nclass Person:\n    def __init__(self, name, age, city):\n        self.name = name\n        self.age = age\n        self.city = city\n\n# Provide all arguments\nperson = Person(\"Alice\", 25, \"NYC\")  # ‚úì\n\n# Use default parameters\nclass Person:\n    def __init__(self, name, age=0, city=\"Unknown\"):\n        self.name = name\n        self.age = age\n        self.city = city\n\nperson = Person(\"Alice\")  # ‚úì Uses defaults\nperson = Person(\"Bob\", 30)  # ‚úì Partial defaults\nperson = Person(\"Charlie\", 35, \"LA\")  # ‚úì All specified\n\n# Use keyword arguments\nperson = Person(name=\"Alice\", age=25, city=\"NYC\")  # ‚úì Clear\n\n# Flexible initialization with *args, **kwargs\nclass FlexiblePerson:\n    def __init__(self, name, **kwargs):\n        self.name = name\n        self.age = kwargs.get('age', 0)\n        self.city = kwargs.get('city', 'Unknown')\n\nperson = FlexiblePerson(\"Alice\")  # ‚úì\nperson = FlexiblePerson(\"Bob\", age=30)  # ‚úì\nperson = FlexiblePerson(\"Charlie\", age=35, city=\"LA\")  # ‚úì\n\n# Validate arguments\nclass Person:\n    def __init__(self, name, age):\n        if not name:\n            raise ValueError(\"Name cannot be empty\")\n        if age &lt; 0:\n            raise ValueError(\"Age cannot be negative\")\n        self.name = name\n        self.age = age  # ‚úì Validated",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#instance-vs-class-attributes",
    "href": "chapter-16-oop.html#instance-vs-class-attributes",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.3 16.2 Instance vs Class Attributes",
    "text": "17.3 16.2 Instance vs Class Attributes\n\n17.3.1 Understanding Attribute Scope\nclass Counter:\n    # Class attribute (shared)\n    total_count = 0\n    \n    def __init__(self, name):\n        # Instance attribute (unique to each object)\n        self.name = name\n        self.count = 0\n        Counter.total_count += 1\n    \n    def increment(self):\n        self.count += 1\n\n# Create instances\nc1 = Counter(\"Counter1\")\nc2 = Counter(\"Counter2\")\n\nprint(Counter.total_count)  # 2 (class attribute)\nprint(c1.count)  # 0 (instance attribute)\nprint(c2.count)  # 0 (instance attribute)\n\nc1.increment()\nprint(c1.count)  # 1\nprint(c2.count)  # 0 (unchanged)\n\n\n\n17.3.2 Error Type 2: AttributeError: 'ClassName' object has no attribute 'attribute_name'\nError Message:\n&gt;&gt;&gt; class Dog:\n...     def __init__(self, name):\n...         self.name = name\n&gt;&gt;&gt; dog = Dog(\"Buddy\")\n&gt;&gt;&gt; print(dog.age)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'Dog' object has no attribute 'age'\nWhat Happened: Accessing attribute that doesn‚Äôt exist.\nWhy It Happens: - Attribute not defined in init - Typo in attribute name - Conditional attribute creation - Accessing before assignment\nCode Example - WRONG:\nclass Person:\n    def __init__(self, name):\n        self.name = name\n        # age not defined!\n\nperson = Person(\"Alice\")\nprint(person.age)  # ERROR! age doesn't exist\n\n# Typo\nclass Car:\n    def __init__(self, make):\n        self.make = make\n\ncar = Car(\"Toyota\")\nprint(car.maker)  # ERROR! Typo: maker vs make\n\n# Conditional creation\nclass Student:\n    def __init__(self, name, graduated=False):\n        self.name = name\n        if graduated:\n            self.graduation_year = 2024\n\nstudent = Student(\"Alice\")\nprint(student.graduation_year)  # ERROR! Not created\n\n# Accessing class attribute on instance incorrectly\nclass MyClass:\n    class_var = \"class\"\n\nobj = MyClass()\nprint(MyClass.instance_var)  # ERROR! Doesn't exist\nCode Example - CORRECT:\nclass Person:\n    def __init__(self, name, age=None):\n        self.name = name\n        self.age = age  # ‚úì Always defined\n\nperson = Person(\"Alice\")\nprint(person.age)  # None (but defined)\n\n# Check attribute exists\nif hasattr(person, 'age'):\n    print(person.age)  # ‚úì\nelse:\n    print(\"No age attribute\")\n\n# Use getattr with default\nage = getattr(person, 'age', 0)  # ‚úì Returns 0 if not exists\n\n# Always initialize attributes\nclass Student:\n    def __init__(self, name, graduated=False):\n        self.name = name\n        self.graduation_year = 2024 if graduated else None  # ‚úì\n\nstudent = Student(\"Alice\")\nprint(student.graduation_year)  # None (but defined)\n\n# Use property with getter\nclass Person:\n    def __init__(self, name):\n        self.name = name\n        self._age = None\n    \n    @property\n    def age(self):\n        return self._age if self._age is not None else 0  # ‚úì\n    \n    @age.setter\n    def age(self, value):\n        if value &lt; 0:\n            raise ValueError(\"Age cannot be negative\")\n        self._age = value\n\nperson = Person(\"Alice\")\nprint(person.age)  # 0 (property returns default)\n\n# Try/except for optional attributes\ntry:\n    print(person.optional_attr)\nexcept AttributeError:\n    print(\"Attribute doesn't exist\")  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#methods",
    "href": "chapter-16-oop.html#methods",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.4 16.3 Methods",
    "text": "17.4 16.3 Methods\n\n17.4.1 Instance, Class, and Static Methods\nclass MyClass:\n    class_var = \"class variable\"\n    \n    def __init__(self, value):\n        self.value = value\n    \n    # Instance method (accesses self)\n    def instance_method(self):\n        return f\"Instance: {self.value}\"\n    \n    # Class method (accesses class, not instance)\n    @classmethod\n    def class_method(cls):\n        return f\"Class: {cls.class_var}\"\n    \n    # Static method (no access to class or instance)\n    @staticmethod\n    def static_method(x, y):\n        return x + y\n\nobj = MyClass(10)\n\n# Call methods\nprint(obj.instance_method())      # \"Instance: 10\"\nprint(MyClass.class_method())     # \"Class: class variable\"\nprint(MyClass.static_method(5, 3)) # 8\n\n\n\n17.4.2 Error Type 3: TypeError: method() takes 1 positional argument but 2 were given\nError Message:\n&gt;&gt;&gt; class Dog:\n...     def bark():\n...         return \"Woof!\"\n&gt;&gt;&gt; dog = Dog()\n&gt;&gt;&gt; dog.bark()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: bark() takes 0 positional arguments but 1 was given\nWhat Happened: Forgetting self parameter in method definition.\nWhy It Happens: - Missing self parameter - Wrong method type - Calling method incorrectly\nCode Example - WRONG:\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n    \n    # Missing self\n    def bark():  # ERROR! Missing self\n        return \"Woof!\"\n\ndog = Dog(\"Buddy\")\ndog.bark()  # ERROR! Python passes self automatically\n\n# Wrong static method\nclass Calculator:\n    @staticmethod\n    def add(self, x, y):  # ERROR! Static methods don't use self\n        return x + y\n\n# Calling instance method on class\nclass Cat:\n    def meow(self):\n        return \"Meow!\"\n\nCat.meow()  # ERROR! Need instance\nCode Example - CORRECT:\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n    \n    # Include self\n    def bark(self):  # ‚úì self parameter\n        return f\"{self.name} says Woof!\"\n\ndog = Dog(\"Buddy\")\nprint(dog.bark())  # ‚úì\n\n# Static method (no self)\nclass Calculator:\n    @staticmethod\n    def add(x, y):  # ‚úì No self\n        return x + y\n\nprint(Calculator.add(5, 3))  # ‚úì\n\n# Call instance method on instance\nclass Cat:\n    def meow(self):\n        return \"Meow!\"\n\ncat = Cat()\nprint(cat.meow())  # ‚úì\n\n# Or pass instance explicitly\nprint(Cat.meow(cat))  # ‚úì Explicit self\n\n# Class method uses cls\nclass Counter:\n    count = 0\n    \n    @classmethod\n    def increment(cls):  # ‚úì cls parameter\n        cls.count += 1\n\nCounter.increment()  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#inheritance",
    "href": "chapter-16-oop.html#inheritance",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.5 16.4 Inheritance",
    "text": "17.5 16.4 Inheritance\n\n17.5.1 Extending Classes\n# Base class\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        return \"Some sound\"\n\n# Derived class\nclass Dog(Animal):\n    def speak(self):  # Override\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):  # Override\n        return \"Meow!\"\n\n# Use inheritance\ndog = Dog(\"Buddy\")\nprint(dog.name)    # \"Buddy\" (from Animal)\nprint(dog.speak()) # \"Woof!\" (from Dog)\n\n# Call parent method\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)  # Call parent __init__\n        self.breed = breed\n    \n    def speak(self):\n        parent_sound = super().speak()\n        return f\"{parent_sound} and Woof!\"\n\n# Multiple inheritance\nclass Flyable:\n    def fly(self):\n        return \"Flying\"\n\nclass Bird(Animal, Flyable):\n    def speak(self):\n        return \"Tweet!\"\n\nbird = Bird(\"Tweety\")\nprint(bird.speak())  # \"Tweet!\"\nprint(bird.fly())    # \"Flying\"\n\n\n\n17.5.2 Error Type 4: TypeError: super() argument 1 must be type, not classobj\nWhat Happened: Issues with super() or inheritance.\nCode Example - WRONG:\n# Forgetting to call parent __init__\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\nclass Dog(Animal):\n    def __init__(self, breed):\n        # ERROR! Not calling parent __init__\n        self.breed = breed\n\ndog = Dog(\"Labrador\")\nprint(dog.name)  # AttributeError! name not set\n\n# Wrong super() syntax (Python 2 style)\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super(Dog, self).__init__(name)  # Works but verbose\n        self.breed = breed\n\n# Circular inheritance\nclass A(B):\n    pass\n\nclass B(A):  # ERROR! Circular\n    pass\nCode Example - CORRECT:\n# Call parent __init__\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)  # ‚úì Python 3 syntax\n        self.breed = breed\n\ndog = Dog(\"Buddy\", \"Labrador\")\nprint(dog.name)   # ‚úì \"Buddy\"\nprint(dog.breed)  # ‚úì \"Labrador\"\n\n# Check inheritance\nprint(isinstance(dog, Dog))     # True\nprint(isinstance(dog, Animal))  # True\nprint(issubclass(Dog, Animal))  # True\n\n# Multiple inheritance - Method Resolution Order (MRO)\nclass A:\n    def method(self):\n        return \"A\"\n\nclass B(A):\n    def method(self):\n        return \"B\"\n\nclass C(A):\n    def method(self):\n        return \"C\"\n\nclass D(B, C):  # ‚úì B before C\n    pass\n\nd = D()\nprint(d.method())  # \"B\" (follows MRO)\nprint(D.__mro__)   # Shows method resolution order\n\n# Use super() in multiple inheritance\nclass B(A):\n    def method(self):\n        result = super().method()\n        return f\"B &gt; {result}\"\n\nclass C(A):\n    def method(self):\n        result = super().method()\n        return f\"C &gt; {result}\"\n\nclass D(B, C):\n    def method(self):\n        result = super().method()\n        return f\"D &gt; {result}\"  # ‚úì Calls through MRO",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#special-methods-dunder-methods",
    "href": "chapter-16-oop.html#special-methods-dunder-methods",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.6 16.5 Special Methods (Dunder Methods)",
    "text": "17.6 16.5 Special Methods (Dunder Methods)\n\n17.6.1 Magic Methods\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    # String representation\n    def __str__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    def __repr__(self):\n        return f\"Point(x={self.x}, y={self.y})\"\n    \n    # Arithmetic operations\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n    \n    # Comparison\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n    \n    # Length/bool\n    def __len__(self):\n        return int((self.x**2 + self.y**2)**0.5)\n    \n    def __bool__(self):\n        return self.x != 0 or self.y != 0\n\n# Usage\np1 = Point(1, 2)\np2 = Point(3, 4)\n\nprint(p1)           # \"Point(1, 2)\" (uses __str__)\nprint(p1 + p2)      # \"Point(4, 6)\" (uses __add__)\nprint(p1 == p2)     # False (uses __eq__)\nprint(len(p1))      # Length\nprint(bool(p1))     # True\n\n# Container methods\nclass MyList:\n    def __init__(self):\n        self.items = []\n    \n    def __getitem__(self, index):\n        return self.items[index]\n    \n    def __setitem__(self, index, value):\n        self.items[index] = value\n    \n    def __len__(self):\n        return len(self.items)\n    \n    def __contains__(self, item):\n        return item in self.items\n\nmy_list = MyList()\nmy_list.items = [1, 2, 3]\nprint(my_list[0])      # 1 (uses __getitem__)\nprint(2 in my_list)    # True (uses __contains__)",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#properties",
    "href": "chapter-16-oop.html#properties",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.7 16.6 Properties",
    "text": "17.7 16.6 Properties\n\n17.7.1 Using @property\nclass Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n    \n    @property\n    def celsius(self):\n        \"\"\"Get temperature in Celsius\"\"\"\n        return self._celsius\n    \n    @celsius.setter\n    def celsius(self, value):\n        \"\"\"Set temperature in Celsius\"\"\"\n        if value &lt; -273.15:\n            raise ValueError(\"Temperature below absolute zero\")\n        self._celsius = value\n    \n    @property\n    def fahrenheit(self):\n        \"\"\"Get temperature in Fahrenheit\"\"\"\n        return self._celsius * 9/5 + 32\n    \n    @fahrenheit.setter\n    def fahrenheit(self, value):\n        \"\"\"Set temperature in Fahrenheit\"\"\"\n        self.celsius = (value - 32) * 5/9\n\n# Usage\ntemp = Temperature(25)\nprint(temp.celsius)     # 25\nprint(temp.fahrenheit)  # 77.0\n\ntemp.celsius = 30\nprint(temp.fahrenheit)  # 86.0\n\ntemp.fahrenheit = 100\nprint(temp.celsius)     # 37.77...",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#practice-problems",
    "href": "chapter-16-oop.html#practice-problems",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.8 16.7 Practice Problems",
    "text": "17.8 16.7 Practice Problems\n\n17.8.1 Problem 1: Missing init Argument\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nperson = Person(\"Alice\")\n\n\nClick for Answer\n\nError: TypeError: __init__() missing 1 required positional argument: 'age'\nFix:\nclass Person:\n    def __init__(self, name, age=0):  # ‚úì Default value\n        self.name = name\n        self.age = age\n\nperson = Person(\"Alice\")  # ‚úì\n\n\n\n\n17.8.2 Problem 2: Missing self\nclass Dog:\n    def bark():\n        return \"Woof!\"\n\ndog = Dog()\ndog.bark()\n\n\nClick for Answer\n\nError: TypeError: bark() takes 0 positional arguments but 1 was given\nFix:\nclass Dog:\n    def bark(self):  # ‚úì Add self\n        return \"Woof!\"\n\ndog = Dog()\nprint(dog.bark())  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#key-takeaways",
    "href": "chapter-16-oop.html#key-takeaways",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.9 16.8 Key Takeaways",
    "text": "17.9 16.8 Key Takeaways\n\n17.9.1 What You Learned\n\nInclude self - In all instance methods\n**Call super().__init__()** - In derived classes\nInitialize all attributes - In init\nUse @property - For computed attributes\nCheck with hasattr() - Before accessing attributes\nProvide defaults - For optional parameters\nUse isinstance() - For type checking\n\n\n\n17.9.2 Common Patterns\n# Pattern 1: Basic class\nclass MyClass:\n    def __init__(self, value):\n        self.value = value\n    \n    def method(self):\n        return self.value\n\n# Pattern 2: Inheritance\nclass Child(Parent):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n# Pattern 3: Property\nclass MyClass:\n    @property\n    def value(self):\n        return self._value\n    \n    @value.setter\n    def value(self, val):\n        self._value = val",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-16-oop.html#moving-forward",
    "href": "chapter-16-oop.html#moving-forward",
    "title": "17¬† Chapter 16: Object-Oriented Programming - Class and Object Errors",
    "section": "17.10 16.9 Moving Forward",
    "text": "17.10 16.9 Moving Forward\nYou now understand OOP! In Chapter 17, we‚Äôll explore Modules and Imports!",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Chapter 16: Object-Oriented Programming - Class and Object Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html",
    "href": "chapter-17-modules-imports.html",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "",
    "text": "18.1 Introduction\nModules organize code into reusable files. Understanding imports is essential for using Python libraries and organizing your own code.\nCommon errors: - ModuleNotFoundError: Module not installed or found - ImportError: Can‚Äôt import specific name - AttributeError: Module attribute doesn‚Äôt exist - Circular imports\nLet‚Äôs master imports!",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#basic-imports",
    "href": "chapter-17-modules-imports.html#basic-imports",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.2 17.1 Basic Imports",
    "text": "18.2 17.1 Basic Imports\n\n18.2.1 Import Syntax\n# Import entire module\nimport math\nprint(math.pi)  # 3.14159...\n\n# Import specific function\nfrom math import sqrt\nprint(sqrt(16))  # 4.0\n\n# Import multiple\nfrom math import pi, sqrt, ceil\n\n# Import with alias\nimport numpy as np\narr = np.array([1, 2, 3])\n\n# Import all (not recommended)\nfrom math import *\n\n# Import submodule\nfrom os.path import join\npath = join('folder', 'file.txt')\n\n\n\n18.2.2 Error Type 1: ModuleNotFoundError: No module named 'module_name'\nError Message:\n&gt;&gt;&gt; import pandas\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nModuleNotFoundError: No module named 'pandas'\nWhat Happened: Module not installed or not in Python path.\nWhy It Happens: - Module not installed - Wrong module name - Wrong Python environment - Module in wrong location\nCode Example - WRONG:\n# Module not installed\nimport pandas  # ERROR if not installed\n\n# Typo in name\nimport nump  # ERROR! Should be numpy\n\n# Wrong capitalization\nimport Pandas  # ERROR! Should be pandas\n\n# Module doesn't exist\nimport my_nonexistent_module  # ERROR!\nCode Example - CORRECT:\n# Install module first\n# pip install pandas\n\nimport pandas  # ‚úì After installation\n\n# Check if module exists before importing\ntry:\n    import pandas as pd\nexcept ModuleNotFoundError:\n    print(\"pandas not installed\")  # ‚úì\n    pd = None\n\n# Use importlib to check\nimport importlib.util\nspec = importlib.util.find_spec(\"pandas\")\nif spec is not None:\n    import pandas  # ‚úì Module exists\nelse:\n    print(\"pandas not found\")\n\n# Correct module name\nimport numpy  # ‚úì Correct spelling\n\n# Check installed packages\n# pip list\n# pip show pandas\n\n# Use correct Python environment\n# python -m pip install pandas\n# python3 -m pip install pandas\n\n# Add to path if needed\nimport sys\nsys.path.append('/path/to/module')  # ‚úì\nimport my_module",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#from-imports",
    "href": "chapter-17-modules-imports.html#from-imports",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.3 17.2 From Imports",
    "text": "18.3 17.2 From Imports\n\n18.3.1 Importing Specific Names\n# Import specific function\nfrom math import sqrt, pi\n\n# Import class\nfrom datetime import datetime\n\n# Import with alias\nfrom collections import defaultdict as dd\n\n# Import from subpackage\nfrom os.path import join, exists\n\n# Multiple lines\nfrom mymodule import (\n    function1,\n    function2,\n    MyClass\n)\n\n\n\n18.3.2 Error Type 2: ImportError: cannot import name 'name' from 'module'\nError Message:\n&gt;&gt;&gt; from math import square_root\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nImportError: cannot import name 'square_root' from 'math'\nWhat Happened: Trying to import name that doesn‚Äôt exist in module.\nWhy It Happens: - Function/class doesn‚Äôt exist - Typo in name - Wrong module - Circular import\nCode Example - WRONG:\n# Function doesn't exist\nfrom math import square_root  # ERROR! It's sqrt\n\n# Class doesn't exist\nfrom datetime import Date  # ERROR! It's date\n\n# Wrong module\nfrom os import listdir  # Actually in os module, this works\nfrom sys import listdir  # ERROR! Not in sys\n\n# Typo\nfrom math import squrt  # ERROR! Typo\nCode Example - CORRECT:\n# Correct function name\nfrom math import sqrt  # ‚úì\n\n# Correct class name\nfrom datetime import date  # ‚úì\n\n# Check what's in module\nimport math\nprint(dir(math))  # ‚úì List all names\n\n# Check if name exists\nif hasattr(math, 'sqrt'):\n    from math import sqrt  # ‚úì\nelse:\n    print(\"sqrt not in math\")\n\n# Try/except for import\ntry:\n    from math import sqrt\nexcept ImportError:\n    print(\"Cannot import sqrt\")  # ‚úì\n    sqrt = None\n\n# Import module, then access\nimport math\nresult = math.sqrt(16)  # ‚úì Always works\n\n# Check module documentation\nhelp(math)  # ‚úì See available names",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#creating-your-own-modules",
    "href": "chapter-17-modules-imports.html#creating-your-own-modules",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.4 17.3 Creating Your Own Modules",
    "text": "18.4 17.3 Creating Your Own Modules\n\n18.4.1 Module Structure\n# mymodule.py\n\"\"\"\nMy custom module\n\"\"\"\n\n# Module-level constant\nPI = 3.14159\n\n# Function\ndef greet(name):\n    \"\"\"Greet someone\"\"\"\n    return f\"Hello, {name}!\"\n\n# Class\nclass Calculator:\n    \"\"\"Simple calculator\"\"\"\n    @staticmethod\n    def add(x, y):\n        return x + y\n\n# Main execution guard\nif __name__ == \"__main__\":\n    print(\"Running as script\")\n    print(greet(\"World\"))\n# Use the module (in another file)\nimport mymodule\n\nprint(mymodule.PI)\nprint(mymodule.greet(\"Alice\"))\ncalc = mymodule.Calculator()\nprint(calc.add(5, 3))\n\n\n\n18.4.2 Error Type 3: Circular Import Error\nWhat Happened: Two modules import each other.\nCode Example - WRONG:\n# module_a.py\nfrom module_b import func_b\n\ndef func_a():\n    return func_b()\n\n# module_b.py\nfrom module_a import func_a  # ERROR! Circular\n\ndef func_b():\n    return func_a()\n\n# main.py\nimport module_a  # ERROR! Circular import\nCode Example - CORRECT:\n# Solution 1: Restructure to remove circular dependency\n# module_a.py\ndef func_a():\n    from module_b import func_b  # ‚úì Import inside function\n    return func_b()\n\n# module_b.py\ndef func_b():\n    return \"result\"\n\n# Solution 2: Create third module\n# common.py\ndef shared_function():\n    return \"shared\"\n\n# module_a.py\nfrom common import shared_function\n\ndef func_a():\n    return shared_function()\n\n# module_b.py\nfrom common import shared_function\n\ndef func_b():\n    return shared_function()\n\n# Solution 3: Use lazy import\n# module_a.py\ndef func_a():\n    import module_b  # ‚úì Import when called\n    return module_b.func_b()\n\n# Solution 4: Import at bottom\n# module_a.py\ndef func_a():\n    return func_b()\n\nfrom module_b import func_b  # ‚úì After definition",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#package-structure",
    "href": "chapter-17-modules-imports.html#package-structure",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.5 17.4 Package Structure",
    "text": "18.5 17.4 Package Structure\n\n18.5.1 Creating Packages\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\n    subpackage/\n        __init__.py\n        module3.py\n# mypackage/__init__.py\n\"\"\"Package initialization\"\"\"\nfrom .module1 import function1\nfrom .module2 import Class2\n\n__all__ = ['function1', 'Class2']\n\n# mypackage/module1.py\ndef function1():\n    return \"Function 1\"\n\n# mypackage/module2.py\nclass Class2:\n    pass\n\n# Usage\nfrom mypackage import function1, Class2\nfrom mypackage.subpackage import module3",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#import-best-practices",
    "href": "chapter-17-modules-imports.html#import-best-practices",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.6 17.5 Import Best Practices",
    "text": "18.6 17.5 Import Best Practices\n\n18.6.1 Guidelines\n# ‚úì GOOD: Import order (PEP 8)\n# 1. Standard library\nimport os\nimport sys\nfrom datetime import datetime\n\n# 2. Third-party\nimport numpy as np\nimport pandas as pd\n\n# 3. Local/custom\nfrom mymodule import myfunction\n\n# ‚úì GOOD: Specific imports\nfrom math import sqrt, pi\n\n# ‚úó AVOID: Import *\nfrom math import *  # Pollutes namespace\n\n# ‚úì GOOD: Clear aliases\nimport numpy as np\nimport pandas as pd\n\n# ‚úó AVOID: Unclear aliases\nimport numpy as n\nimport pandas as p\n\n# ‚úì GOOD: Group related imports\nfrom os import (\n    path,\n    listdir,\n    makedirs\n)\n\n# ‚úó AVOID: Multiple statements per line\nimport sys, os  # Use separate lines\n\n# ‚úì GOOD: Absolute imports\nfrom mypackage.subpackage import module\n\n# ‚úì GOOD: Relative imports (within package)\nfrom . import sibling_module\nfrom .. import parent_module\nfrom ..sibling import cousin_module",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#common-patterns",
    "href": "chapter-17-modules-imports.html#common-patterns",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.7 17.6 Common Patterns",
    "text": "18.7 17.6 Common Patterns\n\n18.7.1 Import Patterns\n# Conditional imports\ntry:\n    import pandas as pd\n    HAS_PANDAS = True\nexcept ImportError:\n    HAS_PANDAS = False\n\nif HAS_PANDAS:\n    # Use pandas\n    df = pd.DataFrame()\n\n# Version checking\nimport sys\nif sys.version_info &lt; (3, 6):\n    raise RuntimeError(\"Python 3.6+ required\")\n\n# Dynamic imports\nmodule_name = \"math\"\nmodule = __import__(module_name)\nresult = module.sqrt(16)\n\n# Or use importlib\nimport importlib\nmodule = importlib.import_module(\"math\")\nresult = module.sqrt(16)\n\n# Lazy imports\nclass MyClass:\n    def method(self):\n        import expensive_module  # ‚úì Only import when needed\n        return expensive_module.function()\n\n# Optional dependencies\ntry:\n    import matplotlib.pyplot as plt\n    CAN_PLOT = True\nexcept ImportError:\n    CAN_PLOT = False\n\ndef plot_data(data):\n    if not CAN_PLOT:\n        print(\"matplotlib not available\")\n        return\n    plt.plot(data)\n    plt.show()",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#practice-problems",
    "href": "chapter-17-modules-imports.html#practice-problems",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.8 17.7 Practice Problems",
    "text": "18.8 17.7 Practice Problems\n\n18.8.1 Problem 1: Module Not Found\nimport numpyy\n\n\nClick for Answer\n\nError: ModuleNotFoundError: No module named 'numpyy'\nFix:\nimport numpy  # ‚úì Correct spelling\n\n# Or install if needed\n# pip install numpy\n\n\n\n\n18.8.2 Problem 2: Import Name Error\nfrom math import square_root\n\n\nClick for Answer\n\nError: ImportError: cannot import name 'square_root'\nFix:\nfrom math import sqrt  # ‚úì Correct name\n\n# Check available names\nimport math\nprint(dir(math))  # ‚úì",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#key-takeaways",
    "href": "chapter-17-modules-imports.html#key-takeaways",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.9 17.8 Key Takeaways",
    "text": "18.9 17.8 Key Takeaways\n\n18.9.1 What You Learned\n\nInstall before importing - pip install package\nCheck spelling - Module names are case-sensitive\nAvoid circular imports - Restructure code\nUse try/except - For optional imports\nImport at top - Unless lazy loading\nFollow PEP 8 - Import order and style\nCheck with dir() - See module contents",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-17-modules-imports.html#moving-forward",
    "href": "chapter-17-modules-imports.html#moving-forward",
    "title": "18¬† Chapter 17: Modules and Imports - Import Errors",
    "section": "18.10 17.9 Moving Forward",
    "text": "18.10 17.9 Moving Forward\nYou now understand imports! In Chapter 18, we‚Äôll explore Exception Handling!",
    "crumbs": [
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Chapter 17: Modules and Imports - Import Errors</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html",
    "href": "chapter-18-exception-handling.html",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "",
    "text": "19.1 Introduction\nException handling lets you gracefully manage errors instead of crashing. Proper exception handling is crucial for robust applications.\nCommon topics: - try/except/finally blocks - Multiple exception types - Raising exceptions - Custom exceptions - Best practices\nLet‚Äôs master exception handling!",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#basic-exception-handling",
    "href": "chapter-18-exception-handling.html#basic-exception-handling",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.2 18.1 Basic Exception Handling",
    "text": "19.2 18.1 Basic Exception Handling\n\n19.2.1 try/except Blocks\n# Basic try/except\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n    result = None\n\n# Multiple exceptions\ntry:\n    value = int(\"abc\")\nexcept ValueError:\n    print(\"Invalid number\")\nexcept TypeError:\n    print(\"Wrong type\")\n\n# Catch any exception\ntry:\n    risky_operation()\nexcept Exception as e:\n    print(f\"Error: {e}\")\n\n# Multiple exceptions in one block\ntry:\n    operation()\nexcept (ValueError, TypeError) as e:\n    print(f\"Error: {e}\")\n\n# Get exception details\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError as e:\n    print(f\"Error type: {type(e)}\")\n    print(f\"Error message: {e}\")",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#else-and-finally",
    "href": "chapter-18-exception-handling.html#else-and-finally",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.3 18.2 else and finally",
    "text": "19.3 18.2 else and finally\n\n19.3.1 Complete try Block\n# try/except/else/finally\ntry:\n    file = open('data.txt', 'r')\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\n    data = None\nelse:\n    print(\"File read successfully\")  # Only if no exception\nfinally:\n    print(\"Cleanup\")  # Always executes\n    if 'file' in locals():\n        file.close()\n\n# Common pattern\ntry:\n    result = risky_operation()\nexcept Exception as e:\n    print(f\"Error: {e}\")\n    result = default_value\nelse:\n    print(\"Success\")\nfinally:\n    cleanup()\n\n# finally for cleanup\nfile = None\ntry:\n    file = open('data.txt', 'r')\n    data = file.read()\nexcept Exception as e:\n    print(f\"Error: {e}\")\nfinally:\n    if file:\n        file.close()  # Always closes",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#raising-exceptions",
    "href": "chapter-18-exception-handling.html#raising-exceptions",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.4 18.3 Raising Exceptions",
    "text": "19.4 18.3 Raising Exceptions\n\n19.4.1 Creating Exceptions\n# Raise exception\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Divisor cannot be zero\")\n    return a / b\n\n# Re-raise exception\ntry:\n    risky_operation()\nexcept Exception as e:\n    print(f\"Logging error: {e}\")\n    raise  # Re-raise same exception\n\n# Raise different exception\ntry:\n    external_api_call()\nexcept ExternalAPIError as e:\n    raise RuntimeError(\"API failed\") from e\n\n# Raise with context\ndef process_data(data):\n    if not data:\n        raise ValueError(\"Data cannot be empty\")\n    if not isinstance(data, list):\n        raise TypeError(f\"Expected list, got {type(data)}\")\n    return process(data)",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#custom-exceptions",
    "href": "chapter-18-exception-handling.html#custom-exceptions",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.5 18.4 Custom Exceptions",
    "text": "19.5 18.4 Custom Exceptions\n\n19.5.1 Creating Custom Exceptions\n# Basic custom exception\nclass MyCustomError(Exception):\n    pass\n\nraise MyCustomError(\"Something went wrong\")\n\n# With additional data\nclass ValidationError(Exception):\n    def __init__(self, message, field=None):\n        super().__init__(message)\n        self.field = field\n\ntry:\n    raise ValidationError(\"Invalid email\", field=\"email\")\nexcept ValidationError as e:\n    print(f\"Error in {e.field}: {e}\")\n\n# Exception hierarchy\nclass AppError(Exception):\n    \"\"\"Base exception for app\"\"\"\n    pass\n\nclass DatabaseError(AppError):\n    \"\"\"Database related errors\"\"\"\n    pass\n\nclass NetworkError(AppError):\n    \"\"\"Network related errors\"\"\"\n    pass\n\ntry:\n    raise DatabaseError(\"Connection failed\")\nexcept DatabaseError as e:\n    print(\"Database error\")\nexcept AppError as e:\n    print(\"App error\")\n\n# With additional methods\nclass HTTPError(Exception):\n    def __init__(self, status_code, message):\n        self.status_code = status_code\n        self.message = message\n        super().__init__(self.message)\n    \n    def is_client_error(self):\n        return 400 &lt;= self.status_code &lt; 500\n    \n    def is_server_error(self):\n        return 500 &lt;= self.status_code &lt; 600\n\ntry:\n    raise HTTPError(404, \"Not Found\")\nexcept HTTPError as e:\n    if e.is_client_error():\n        print(\"Client error\")",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#exception-best-practices",
    "href": "chapter-18-exception-handling.html#exception-best-practices",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.6 18.5 Exception Best Practices",
    "text": "19.6 18.5 Exception Best Practices\n\n19.6.1 Good Patterns\n# ‚úì GOOD: Specific exceptions\ntry:\n    value = int(user_input)\nexcept ValueError:  # Specific\n    print(\"Invalid number\")\n\n# ‚úó AVOID: Bare except\ntry:\n    value = int(user_input)\nexcept:  # Catches everything, even KeyboardInterrupt!\n    print(\"Error\")\n\n# ‚úì GOOD: Catch specific, then general\ntry:\n    operation()\nexcept ValueError:\n    handle_value_error()\nexcept TypeError:\n    handle_type_error()\nexcept Exception as e:\n    handle_general_error(e)\n\n# ‚úó AVOID: Catch Exception first\ntry:\n    operation()\nexcept Exception:  # Too broad, catches everything\n    pass\nexcept ValueError:  # Never reached!\n    pass\n\n# ‚úì GOOD: Don't suppress errors\ntry:\n    important_operation()\nexcept Exception as e:\n    logger.error(f\"Error: {e}\")\n    raise  # Re-raise\n\n# ‚úó AVOID: Silent failures\ntry:\n    important_operation()\nexcept:\n    pass  # Error lost!\n\n# ‚úì GOOD: Use finally for cleanup\nresource = None\ntry:\n    resource = acquire_resource()\n    use_resource(resource)\nfinally:\n    if resource:\n        resource.release()\n\n# ‚úì GOOD: Use context managers (better than finally)\nwith open('file.txt', 'r') as file:\n    data = file.read()\n# File automatically closed\n\n# ‚úì GOOD: Fail fast\ndef process(data):\n    if not data:\n        raise ValueError(\"Data required\")\n    # Process data\n\n# ‚úó AVOID: Catching too much\ntry:\n    # Many operations\n    operation1()\n    operation2()\n    operation3()\nexcept Exception:\n    # Which operation failed?\n    pass\n\n# ‚úì GOOD: Narrow try blocks\ntry:\n    operation1()\nexcept SpecificError:\n    handle_error()\n\ntry:\n    operation2()\nexcept AnotherError:\n    handle_error()",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#common-exception-types",
    "href": "chapter-18-exception-handling.html#common-exception-types",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.7 18.6 Common Exception Types",
    "text": "19.7 18.6 Common Exception Types\n\n19.7.1 Built-in Exceptions\n# ValueError: Invalid value\ntry:\n    int(\"abc\")\nexcept ValueError:\n    print(\"Cannot convert to int\")\n\n# TypeError: Wrong type\ntry:\n    \"2\" + 2\nexcept TypeError:\n    print(\"Cannot add string and int\")\n\n# KeyError: Key doesn't exist\ntry:\n    d = {'a': 1}\n    value = d['b']\nexcept KeyError:\n    print(\"Key not found\")\n\n# IndexError: Index out of range\ntry:\n    lst = [1, 2, 3]\n    value = lst[10]\nexcept IndexError:\n    print(\"Index out of range\")\n\n# FileNotFoundError: File doesn't exist\ntry:\n    with open('nonexistent.txt') as f:\n        data = f.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\n\n# AttributeError: Attribute doesn't exist\ntry:\n    x = 5\n    x.append(1)\nexcept AttributeError:\n    print(\"Attribute doesn't exist\")\n\n# ZeroDivisionError: Division by zero\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n\n# ImportError: Cannot import\ntry:\n    import nonexistent_module\nexcept ImportError:\n    print(\"Module not found\")\n\n# RuntimeError: General runtime error\ntry:\n    raise RuntimeError(\"Something went wrong\")\nexcept RuntimeError:\n    print(\"Runtime error\")",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#context-managers",
    "href": "chapter-18-exception-handling.html#context-managers",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.8 18.7 Context Managers",
    "text": "19.8 18.7 Context Managers\n\n19.8.1 with Statement\n# File handling\nwith open('file.txt', 'r') as file:\n    data = file.read()\n# File automatically closed\n\n# Multiple resources\nwith open('input.txt', 'r') as infile, \\\n     open('output.txt', 'w') as outfile:\n    data = infile.read()\n    outfile.write(data)\n\n# Custom context manager\nclass DatabaseConnection:\n    def __enter__(self):\n        print(\"Opening connection\")\n        self.conn = connect_to_database()\n        return self.conn\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(\"Closing connection\")\n        self.conn.close()\n        return False  # Don't suppress exceptions\n\nwith DatabaseConnection() as conn:\n    conn.execute(\"SELECT * FROM users\")\n\n# Using contextlib\nfrom contextlib import contextmanager\n\n@contextmanager\ndef managed_resource():\n    resource = acquire_resource()\n    try:\n        yield resource\n    finally:\n        resource.release()\n\nwith managed_resource() as resource:\n    use_resource(resource)",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#assertion-errors",
    "href": "chapter-18-exception-handling.html#assertion-errors",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.9 18.8 Assertion Errors",
    "text": "19.9 18.8 Assertion Errors\n\n19.9.1 Using Assertions\n# Basic assertion\nx = 5\nassert x &gt; 0, \"x must be positive\"\n\n# Development checks\ndef calculate_average(numbers):\n    assert len(numbers) &gt; 0, \"List cannot be empty\"\n    return sum(numbers) / len(numbers)\n\n# ‚úì GOOD: Use for development checks\ndef set_age(age):\n    assert isinstance(age, int), \"Age must be int\"\n    assert age &gt;= 0, \"Age must be positive\"\n    self.age = age\n\n# ‚úó AVOID: For user input validation\ndef process_input(user_input):\n    assert user_input  # BAD! Use proper validation\n    return process(user_input)\n\n# ‚úì GOOD: Proper validation\ndef process_input(user_input):\n    if not user_input:\n        raise ValueError(\"Input required\")\n    return process(user_input)\n\n# Note: Assertions can be disabled with -O flag\n# python -O script.py  # Skips assertions",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#logging-errors",
    "href": "chapter-18-exception-handling.html#logging-errors",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.10 18.9 Logging Errors",
    "text": "19.10 18.9 Logging Errors\n\n19.10.1 Error Logging\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nlogger = logging.getLogger(__name__)\n\n# Log exceptions\ntry:\n    risky_operation()\nexcept Exception as e:\n    logger.error(f\"Operation failed: {e}\")\n    logger.exception(\"Full traceback:\")  # Includes traceback\n\n# Different log levels\ntry:\n    operation()\nexcept ValueError as e:\n    logger.warning(f\"Validation error: {e}\")\nexcept Exception as e:\n    logger.error(f\"Unexpected error: {e}\")\n    logger.exception(\"Details:\")\n\n# Custom exception logging\nclass CustomError(Exception):\n    def __init__(self, message, code):\n        super().__init__(message)\n        self.code = code\n\ntry:\n    raise CustomError(\"Failed\", code=500)\nexcept CustomError as e:\n    logger.error(f\"Error {e.code}: {e}\")",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#practice-problems",
    "href": "chapter-18-exception-handling.html#practice-problems",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.11 18.10 Practice Problems",
    "text": "19.11 18.10 Practice Problems\n\n19.11.1 Problem 1: Bare Except\ntry:\n    value = int(input())\nexcept:\n    print(\"Error\")\n\n\nClick for Answer\n\nIssue: Catches everything, including KeyboardInterrupt\nFix:\ntry:\n    value = int(input())\nexcept ValueError:  # ‚úì Specific exception\n    print(\"Invalid number\")\nexcept KeyboardInterrupt:\n    print(\"Cancelled\")",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#key-takeaways",
    "href": "chapter-18-exception-handling.html#key-takeaways",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.12 18.11 Key Takeaways",
    "text": "19.12 18.11 Key Takeaways\n\n19.12.1 What You Learned\n\nUse specific exceptions - Not bare except\nClean up in finally - Or use context managers\nDon‚Äôt suppress errors - Log and re-raise\nRaise for validation - Don‚Äôt return None\nCreate custom exceptions - For app-specific errors\nLog exceptions - Use logging.exception()\nUse with statement - For resources\n\n\n\n19.12.2 Common Patterns\n# Pattern 1: Specific handling\ntry:\n    operation()\nexcept SpecificError:\n    handle()\n\n# Pattern 2: With cleanup\ntry:\n    resource = acquire()\n    use(resource)\nfinally:\n    release(resource)\n\n# Pattern 3: Context manager\nwith resource() as r:\n    use(r)\n\n# Pattern 4: Log and re-raise\ntry:\n    operation()\nexcept Exception as e:\n    logger.error(f\"Error: {e}\")\n    raise",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-18-exception-handling.html#moving-forward",
    "href": "chapter-18-exception-handling.html#moving-forward",
    "title": "19¬† Chapter 18: Exception Handling - try/except Patterns",
    "section": "19.13 18.12 Moving Forward",
    "text": "19.13 18.12 Moving Forward\nYou now understand exception handling! In Chapter 19, we‚Äôll explore Debugging Techniques!",
    "crumbs": [
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Chapter 18: Exception Handling - try/except Patterns</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html",
    "href": "chapter-19-debugging.html",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "",
    "text": "20.1 Introduction\nDebugging is the art of finding and fixing bugs. Mastering debugging techniques dramatically improves your productivity and code quality.\nTopics covered: - Print debugging - Using debuggers (pdb) - IDE debugging - Logging - Common debugging strategies\nLet‚Äôs master debugging!",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#print-debugging",
    "href": "chapter-19-debugging.html#print-debugging",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.2 19.1 Print Debugging",
    "text": "20.2 19.1 Print Debugging\n\n20.2.1 Basic Debugging with Print\n# Simple print debugging\ndef calculate_total(items):\n    total = 0\n    print(f\"Starting calculation with {len(items)} items\")  # Debug\n    for item in items:\n        print(f\"Processing item: {item}\")  # Debug\n        total += item['price']\n    print(f\"Final total: {total}\")  # Debug\n    return total\n\n# Print variable types\nvalue = get_value()\nprint(f\"value = {value}, type = {type(value)}\")  # Debug\n\n# Print with context\ndef process(data):\n    print(f\"[process] Input: {data}\")  # Debug with context\n    result = transform(data)\n    print(f\"[process] Result: {result}\")  # Debug\n    return result\n\n# Use repr() for detailed output\ntext = \"hello\\nworld\"\nprint(f\"text = {text!r}\")  # 'hello\\nworld' (shows newline)\n\n# Temporary assertions\ndef divide(a, b):\n    print(f\"divide({a}, {b})\")  # Debug\n    assert b != 0, f\"b is {b}\"  # Debug assertion\n    return a / b",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#python-debugger-pdb",
    "href": "chapter-19-debugging.html#python-debugger-pdb",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.3 19.2 Python Debugger (pdb)",
    "text": "20.3 19.2 Python Debugger (pdb)\n\n20.3.1 Using pdb\nimport pdb\n\n# Set breakpoint\ndef buggy_function(x, y):\n    result = x + y\n    pdb.set_trace()  # Execution pauses here\n    return result * 2\n\n# Python 3.7+: builtin breakpoint()\ndef buggy_function(x, y):\n    result = x + y\n    breakpoint()  # Easier syntax\n    return result * 2\n\n# Post-mortem debugging\ntry:\n    buggy_operation()\nexcept Exception:\n    import pdb\n    pdb.post_mortem()  # Debug at exception\n\n# pdb commands:\n# n (next) - Execute current line\n# s (step) - Step into function\n# c (continue) - Continue execution\n# l (list) - Show code\n# p variable - Print variable\n# pp variable - Pretty print\n# w (where) - Show stack trace\n# u (up) - Move up stack\n# d (down) - Move down stack\n# q (quit) - Exit debugger",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#logging-for-debugging",
    "href": "chapter-19-debugging.html#logging-for-debugging",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.4 19.3 Logging for Debugging",
    "text": "20.4 19.3 Logging for Debugging\n\n20.4.1 Strategic Logging\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    filename='debug.log'\n)\n\nlogger = logging.getLogger(__name__)\n\ndef process_data(data):\n    logger.debug(f\"Processing {len(data)} items\")\n    \n    for i, item in enumerate(data):\n        logger.debug(f\"Item {i}: {item}\")\n        try:\n            result = transform(item)\n            logger.debug(f\"Transformed to: {result}\")\n        except Exception as e:\n            logger.error(f\"Failed on item {i}: {e}\")\n            logger.exception(\"Full traceback:\")\n    \n    logger.info(\"Processing complete\")\n\n# Different log levels\nlogger.debug(\"Detailed debugging info\")\nlogger.info(\"General information\")\nlogger.warning(\"Warning message\")\nlogger.error(\"Error occurred\")\nlogger.critical(\"Critical error!\")\n\n# Conditional logging\nif logger.isEnabledFor(logging.DEBUG):\n    expensive_debug_info = compute_debug_info()\n    logger.debug(f\"Debug info: {expensive_debug_info}\")\n\n# Multiple loggers\nuser_logger = logging.getLogger('user_actions')\nsystem_logger = logging.getLogger('system')\n\nuser_logger.info(\"User logged in\")\nsystem_logger.debug(\"System check passed\")",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#common-debugging-strategies",
    "href": "chapter-19-debugging.html#common-debugging-strategies",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.5 19.4 Common Debugging Strategies",
    "text": "20.5 19.4 Common Debugging Strategies\n\n20.5.1 Systematic Approaches\n# 1. Binary search / Divide and conquer\ndef complex_function():\n    step1()\n    step2()\n    print(\"Checkpoint 1\")  # Add checkpoints\n    step3()\n    step4()\n    print(\"Checkpoint 2\")\n    step5()\n\n# 2. Simplify inputs\n# Instead of:\nresult = complex_function(large_data, many_params, complex_config)\n\n# Try:\nresult = complex_function([1, 2, 3], simple_params, default_config)\n\n# 3. Comment out sections\ndef buggy_function():\n    part1()\n    part2()\n    # part3()  # Comment out to isolate\n    # part4()\n    part5()\n\n# 4. Add assertions\ndef process(data):\n    assert data is not None, \"Data is None\"\n    assert len(data) &gt; 0, f\"Data is empty: {data}\"\n    \n    result = transform(data)\n    \n    assert result is not None, \"Result is None\"\n    assert isinstance(result, list), f\"Result type: {type(result)}\"\n    \n    return result\n\n# 5. Rubber duck debugging\n# Explain your code line by line (to rubber duck)\n# Often reveals the bug!\n\n# 6. Check assumptions\ndef divide(a, b):\n    # Assumption: b is never zero\n    print(f\"Dividing {a} by {b}\")\n    print(f\"b == 0? {b == 0}\")  # Check assumption\n    return a / b\n\n# 7. Read error messages carefully\ntry:\n    result = data['key']['subkey'][0]\nexcept Exception as e:\n    print(f\"Error type: {type(e)}\")\n    print(f\"Error message: {e}\")\n    print(f\"Error args: {e.args}\")\n    import traceback\n    traceback.print_exc()\n\n# 8. Verify data types\ndef process(value):\n    print(f\"value: {value}\")\n    print(f\"type: {type(value)}\")\n    print(f\"is None: {value is None}\")\n    print(f\"is empty: {not value}\")\n    print(f\"len: {len(value) if hasattr(value, '__len__') else 'N/A'}\")",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#common-bug-patterns",
    "href": "chapter-19-debugging.html#common-bug-patterns",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.6 19.5 Common Bug Patterns",
    "text": "20.6 19.5 Common Bug Patterns\n\n20.6.1 Recognizing Patterns\n# 1. Off-by-one errors\n# Wrong:\nfor i in range(len(items) + 1):  # Goes too far!\n    print(items[i])\n\n# Correct:\nfor i in range(len(items)):\n    print(items[i])\n\n# 2. Mutable default arguments\n# Wrong:\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\n# Correct:\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\n# 3. Variable scope issues\n# Wrong:\ndef update_global():\n    count = count + 1  # UnboundLocalError\n\n# Correct:\ndef update_global():\n    global count\n    count = count + 1\n\n# 4. String/bytes confusion\n# Wrong:\ntext = b\"hello\"\ntext.upper()  # Returns bytes, not string!\n\n# Correct:\ntext = b\"hello\"\ntext = text.decode('utf-8')\ntext.upper()  # Now works\n\n# 5. Integer division\n# Python 2 vs 3:\nresult = 5 / 2  # 2 in Python 2, 2.5 in Python 3\n\n# Explicit:\nresult = 5 // 2  # 2 (integer division)\nresult = 5 / 2   # 2.5 (float division)\n\n# 6. Reference vs copy\n# Wrong:\nlist1 = [1, 2, 3]\nlist2 = list1  # Reference, not copy!\nlist2.append(4)\nprint(list1)  # [1, 2, 3, 4] - modified!\n\n# Correct:\nlist1 = [1, 2, 3]\nlist2 = list1.copy()  # Or list(list1) or list1[:]\nlist2.append(4)\nprint(list1)  # [1, 2, 3] - unchanged",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#ide-debugging-tools",
    "href": "chapter-19-debugging.html#ide-debugging-tools",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.7 19.6 IDE Debugging Tools",
    "text": "20.7 19.6 IDE Debugging Tools\n\n20.7.1 Using IDE Debuggers\n# Most IDEs (PyCharm, VS Code, etc.) provide:\n\n# 1. Breakpoints\n#    - Click left of line number\n#    - Code pauses when reached\n\n# 2. Step controls\n#    - Step Over: Execute line, don't enter functions\n#    - Step Into: Enter function calls\n#    - Step Out: Exit current function\n#    - Continue: Run until next breakpoint\n\n# 3. Variable inspection\n#    - View all variables\n#    - Evaluate expressions\n#    - Modify values during debugging\n\n# 4. Watch expressions\n#    - Monitor specific variables\n#    - Track changes\n\n# 5. Call stack\n#    - See function call history\n#    - Navigate up/down stack\n\n# 6. Conditional breakpoints\n#    - Only pause when condition is True\n#    - Example: i == 10\n\n# 7. Exception breakpoints\n#    - Pause on any exception\n#    - Or specific exception types",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#performance-debugging",
    "href": "chapter-19-debugging.html#performance-debugging",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.8 19.7 Performance Debugging",
    "text": "20.8 19.7 Performance Debugging\n\n20.8.1 Finding Slow Code\nimport time\n\n# Simple timing\nstart = time.time()\nslow_function()\nend = time.time()\nprint(f\"Took {end - start:.2f} seconds\")\n\n# Context manager for timing\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer(name):\n    start = time.time()\n    yield\n    end = time.time()\n    print(f\"{name} took {end - start:.2f} seconds\")\n\nwith timer(\"Database query\"):\n    query_database()\n\n# Profile with timeit\nimport timeit\n\n# Time a statement\ntime = timeit.timeit('sum(range(100))', number=10000)\nprint(f\"Time: {time}\")\n\n# Compare approaches\ntime1 = timeit.timeit('[i for i in range(1000)]', number=1000)\ntime2 = timeit.timeit('list(range(1000))', number=1000)\nprint(f\"List comp: {time1}, list(): {time2}\")\n\n# Use cProfile\nimport cProfile\nimport pstats\n\ncProfile.run('expensive_function()', 'output.prof')\n\n# Analyze results\nstats = pstats.Stats('output.prof')\nstats.sort_stats('cumulative')\nstats.print_stats(10)  # Top 10 functions\n\n# Line profiler (requires line_profiler package)\n# @profile decorator\n# kernprof -l script.py\n# python -m line_profiler script.py.lprof\n\n# Memory profiling (requires memory_profiler)\n# from memory_profiler import profile\n# @profile\n# def my_function():\n#     ...",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#debugging-checklist",
    "href": "chapter-19-debugging.html#debugging-checklist",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.9 19.8 Debugging Checklist",
    "text": "20.9 19.8 Debugging Checklist\n\n20.9.1 Systematic Approach\n\"\"\"\nWhen you encounter a bug:\n\n1. ‚úì Reproduce the bug\n   - Can you make it happen consistently?\n   - What are the exact steps?\n   - What inputs cause it?\n\n2. ‚úì Isolate the problem\n   - Which function/module?\n   - Binary search: comment out code\n   - Simplify inputs\n\n3. ‚úì Examine the error\n   - Read error message carefully\n   - Note the line number\n   - Check the stack trace\n\n4. ‚úì Form a hypothesis\n   - What do you think is wrong?\n   - What should happen vs what does happen?\n\n5. ‚úì Test your hypothesis\n   - Add print statements\n   - Use debugger\n   - Add assertions\n\n6. ‚úì Fix the bug\n   - Make smallest change possible\n   - Don't add features while fixing bugs\n\n7. ‚úì Verify the fix\n   - Run the test case\n   - Check edge cases\n   - Make sure you didn't break anything else\n\n8. ‚úì Prevent regression\n   - Add a test\n   - Document the bug\n   - Review similar code\n\"\"\"",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#debugging-tools-summary",
    "href": "chapter-19-debugging.html#debugging-tools-summary",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.10 19.9 Debugging Tools Summary",
    "text": "20.10 19.9 Debugging Tools Summary\n\n20.10.1 Tool Comparison\n# Print debugging\n# ‚úì Quick and simple\n# ‚úì Works everywhere\n# ‚úó Clutters code\n# ‚úó Easy to forget to remove\n\n# pdb (Python debugger)\n# ‚úì Interactive\n# ‚úì Inspect variables\n# ‚úó Command line only\n# ‚úó Learning curve\n\n# IDE debuggers\n# ‚úì Visual interface\n# ‚úì Easy breakpoints\n# ‚úì Variable inspection\n# ‚úó Requires IDE\n\n# Logging\n# ‚úì Permanent\n# ‚úì Levels (debug, info, error)\n# ‚úì Can log to file\n# ‚úó Overhead\n\n# Assertions\n# ‚úì Check assumptions\n# ‚úì Document expectations\n# ‚úó Can be disabled\n# ‚úó Crashes on failure",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#key-takeaways",
    "href": "chapter-19-debugging.html#key-takeaways",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.11 19.10 Key Takeaways",
    "text": "20.11 19.10 Key Takeaways\n\n20.11.1 What You Learned\n\nUse print strategically - Add context\nLearn pdb basics - n, s, c, p commands\nUse logging - For production code\nRead errors carefully - Stack trace has clues\nIsolate the problem - Binary search\nCheck assumptions - Add assertions\nUse IDE debugger - Visual and powerful\n\n\n\n20.11.2 Debugging Workflow\n# 1. Reproduce\n# 2. Isolate\n# 3. Understand\n# 4. Fix\n# 5. Test\n# 6. Prevent",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-19-debugging.html#moving-forward",
    "href": "chapter-19-debugging.html#moving-forward",
    "title": "20¬† Chapter 19: Debugging Techniques - Finding and Fixing Errors",
    "section": "20.12 19.11 Moving Forward",
    "text": "20.12 19.11 Moving Forward\nYou now understand debugging! In Chapter 20, we‚Äôll explore Testing and Code Quality - the final chapter!",
    "crumbs": [
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Chapter 19: Debugging Techniques - Finding and Fixing Errors</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html",
    "href": "chapter-20-testing-quality.html",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "",
    "text": "21.1 Introduction\nTesting and code quality ensure your code works correctly and is maintainable. This final chapter covers testing frameworks, best practices, and tools for writing professional Python code.\nTopics covered: - Unit testing - Test-driven development - Code quality tools - Best practices\nLet‚Äôs complete your journey!",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#unit-testing-basics",
    "href": "chapter-20-testing-quality.html#unit-testing-basics",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.2 20.1 Unit Testing Basics",
    "text": "21.2 20.1 Unit Testing Basics\n\n21.2.1 Using unittest\nimport unittest\n\n# Code to test\ndef add(a, b):\n    return a + b\n\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\n# Test class\nclass TestMath(unittest.TestCase):\n    \n    def test_add(self):\n        self.assertEqual(add(2, 3), 5)\n        self.assertEqual(add(-1, 1), 0)\n        self.assertEqual(add(0, 0), 0)\n    \n    def test_divide(self):\n        self.assertEqual(divide(10, 2), 5)\n        self.assertEqual(divide(9, 3), 3)\n    \n    def test_divide_by_zero(self):\n        with self.assertRaises(ValueError):\n            divide(10, 0)\n    \n    def test_types(self):\n        self.assertIsInstance(add(1, 2), int)\n        self.assertTrue(add(1, 1) &gt; 0)\n        self.assertFalse(add(0, 0) &gt; 0)\n\n# Run tests\nif __name__ == '__main__':\n    unittest.main()",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#common-test-assertions",
    "href": "chapter-20-testing-quality.html#common-test-assertions",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.3 20.2 Common Test Assertions",
    "text": "21.3 20.2 Common Test Assertions\n\n21.3.1 unittest Assertions\nimport unittest\n\nclass TestAssertions(unittest.TestCase):\n    \n    def test_equality(self):\n        self.assertEqual(1, 1)\n        self.assertNotEqual(1, 2)\n    \n    def test_truth(self):\n        self.assertTrue(True)\n        self.assertFalse(False)\n    \n    def test_none(self):\n        self.assertIsNone(None)\n        self.assertIsNotNone(\"value\")\n    \n    def test_membership(self):\n        self.assertIn(1, [1, 2, 3])\n        self.assertNotIn(4, [1, 2, 3])\n    \n    def test_types(self):\n        self.assertIsInstance(1, int)\n        self.assertIsInstance(\"text\", str)\n    \n    def test_comparisons(self):\n        self.assertGreater(2, 1)\n        self.assertLess(1, 2)\n        self.assertGreaterEqual(2, 2)\n        self.assertLessEqual(1, 2)\n    \n    def test_sequences(self):\n        self.assertListEqual([1, 2], [1, 2])\n        self.assertDictEqual({'a': 1}, {'a': 1})\n    \n    def test_exceptions(self):\n        with self.assertRaises(ValueError):\n            int(\"abc\")\n        \n        with self.assertRaises(ZeroDivisionError):\n            1 / 0\n    \n    def test_almost_equal(self):\n        self.assertAlmostEqual(0.1 + 0.2, 0.3)",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#pytest-framework",
    "href": "chapter-20-testing-quality.html#pytest-framework",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.4 20.3 pytest Framework",
    "text": "21.4 20.3 pytest Framework\n\n21.4.1 Using pytest\n# test_math.py\nimport pytest\n\ndef add(a, b):\n    return a + b\n\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\n# Tests (no class needed)\ndef test_add():\n    assert add(2, 3) == 5\n    assert add(-1, 1) == 0\n\ndef test_divide():\n    assert divide(10, 2) == 5\n    assert divide(9, 3) == 3\n\ndef test_divide_by_zero():\n    with pytest.raises(ValueError):\n        divide(10, 0)\n\n# Parametrized tests\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (2, 3, 5),\n    (-1, 1, 0),\n    (0, 0, 0),\n    (100, 200, 300),\n])\ndef test_add_parametrized(a, b, expected):\n    assert add(a, b) == expected\n\n# Fixtures\n@pytest.fixture\ndef sample_data():\n    return [1, 2, 3, 4, 5]\n\ndef test_with_fixture(sample_data):\n    assert len(sample_data) == 5\n    assert sum(sample_data) == 15\n\n# Run: pytest test_math.py",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#test-organization",
    "href": "chapter-20-testing-quality.html#test-organization",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.5 20.4 Test Organization",
    "text": "21.5 20.4 Test Organization\n\n21.5.1 Structuring Tests\n# Project structure\n\"\"\"\nmyproject/\n    mypackage/\n        __init__.py\n        module1.py\n        module2.py\n    tests/\n        __init__.py\n        test_module1.py\n        test_module2.py\n    setup.py\n    README.md\n\"\"\"\n\n# test_module1.py\nimport unittest\nfrom mypackage import module1\n\nclass TestModule1(unittest.TestCase):\n    \n    def setUp(self):\n        \"\"\"Run before each test\"\"\"\n        self.data = [1, 2, 3]\n    \n    def tearDown(self):\n        \"\"\"Run after each test\"\"\"\n        self.data = None\n    \n    def test_function1(self):\n        result = module1.function1(self.data)\n        self.assertEqual(result, expected)\n    \n    def test_function2(self):\n        result = module1.function2(self.data)\n        self.assertTrue(result)\n\n# Run all tests\n# python -m unittest discover tests\n# pytest tests/",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#test-driven-development-tdd",
    "href": "chapter-20-testing-quality.html#test-driven-development-tdd",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.6 20.5 Test-Driven Development (TDD)",
    "text": "21.6 20.5 Test-Driven Development (TDD)\n\n21.6.1 TDD Workflow\n\"\"\"\nTDD Cycle:\n1. Write test (it fails - Red)\n2. Write code (make it pass - Green)\n3. Refactor (improve code - Refactor)\n4. Repeat\n\"\"\"\n\n# Example: TDD for a function\n\n# Step 1: Write test first\ndef test_calculate_discount():\n    assert calculate_discount(100, 10) == 90\n    assert calculate_discount(50, 20) == 40\n\n# Step 2: Run test (fails - function doesn't exist)\n\n# Step 3: Write minimal code\ndef calculate_discount(price, discount_percent):\n    return price - (price * discount_percent / 100)\n\n# Step 4: Run test (passes)\n\n# Step 5: Add more tests\ndef test_calculate_discount_edge_cases():\n    assert calculate_discount(100, 0) == 100\n    assert calculate_discount(100, 100) == 0\n    with pytest.raises(ValueError):\n        calculate_discount(100, -10)\n\n# Step 6: Update code\ndef calculate_discount(price, discount_percent):\n    if discount_percent &lt; 0 or discount_percent &gt; 100:\n        raise ValueError(\"Discount must be 0-100\")\n    return price - (price * discount_percent / 100)\n\n# Step 7: Refactor if needed",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#code-coverage",
    "href": "chapter-20-testing-quality.html#code-coverage",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.7 20.6 Code Coverage",
    "text": "21.7 20.6 Code Coverage\n\n21.7.1 Measuring Test Coverage\n# Install coverage\n# pip install coverage\n\n# Run tests with coverage\n# coverage run -m pytest\n\n# View report\n# coverage report\n\n# Generate HTML report\n# coverage html\n# open htmlcov/index.html\n\n# .coveragerc configuration\n\"\"\"\n[run]\nsource = mypackage\nomit = \n    */tests/*\n    */venv/*\n\n[report]\nexclude_lines =\n    pragma: no cover\n    def __repr__\n    raise NotImplementedError\n    if __name__ == .__main__.:\n\"\"\"\n\n# Aim for high coverage\n# 80%+ is good\n# 100% is ideal but not always necessary",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#code-quality-tools",
    "href": "chapter-20-testing-quality.html#code-quality-tools",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.8 20.7 Code Quality Tools",
    "text": "21.8 20.7 Code Quality Tools\n\n21.8.1 Linting and Formatting\n# pylint - Code analysis\n# pip install pylint\n# pylint mymodule.py\n\n# flake8 - Style guide enforcement\n# pip install flake8\n# flake8 mymodule.py\n\n# black - Code formatter\n# pip install black\n# black mymodule.py\n\n# mypy - Type checking\n# pip install mypy\n# mypy mymodule.py\n\n# Example with type hints\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two integers\"\"\"\n    return a + b\n\n# isort - Import sorting\n# pip install isort\n# isort mymodule.py\n\n# Example .flake8 config\n\"\"\"\n[flake8]\nmax-line-length = 88\nextend-ignore = E203, W503\nexclude = \n    .git,\n    __pycache__,\n    venv\n\"\"\"\n\n# Example pyproject.toml for black\n\"\"\"\n[tool.black]\nline-length = 88\ntarget-version = ['py38']\ninclude = '\\.pyi?$'\n\"\"\"",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#best-practices",
    "href": "chapter-20-testing-quality.html#best-practices",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.9 20.8 Best Practices",
    "text": "21.9 20.8 Best Practices\n\n21.9.1 Writing Quality Code\n# 1. Write docstrings\ndef calculate_total(items: list, tax_rate: float) -&gt; float:\n    \"\"\"\n    Calculate total price including tax.\n    \n    Args:\n        items: List of items with 'price' key\n        tax_rate: Tax rate as decimal (0.08 = 8%)\n    \n    Returns:\n        Total price including tax\n    \n    Raises:\n        ValueError: If tax_rate is negative\n    \n    Example:\n        &gt;&gt;&gt; items = [{'price': 10}, {'price': 20}]\n        &gt;&gt;&gt; calculate_total(items, 0.08)\n        32.4\n    \"\"\"\n    if tax_rate &lt; 0:\n        raise ValueError(\"Tax rate cannot be negative\")\n    \n    subtotal = sum(item['price'] for item in items)\n    return subtotal * (1 + tax_rate)\n\n# 2. Use type hints\nfrom typing import List, Dict, Optional\n\ndef process_data(\n    data: List[Dict[str, any]],\n    filter_key: Optional[str] = None\n) -&gt; List[Dict[str, any]]:\n    \"\"\"Process data with optional filtering\"\"\"\n    if filter_key:\n        return [d for d in data if filter_key in d]\n    return data\n\n# 3. Follow PEP 8\n# - 4 spaces for indentation\n# - 2 blank lines between functions\n# - Lowercase with underscores for functions\n# - CamelCase for classes\n\n# ‚úì Good\ndef calculate_average(numbers):\n    return sum(numbers) / len(numbers)\n\nclass DataProcessor:\n    pass\n\n# ‚úó Bad\ndef calculateAverage(numbers):  # camelCase\n    return sum(numbers)/len(numbers)  # no spaces\n\n# 4. Keep functions small\n# ‚úì Good - One responsibility\ndef validate_email(email):\n    return '@' in email and '.' in email\n\ndef send_email(email, message):\n    if not validate_email(email):\n        raise ValueError(\"Invalid email\")\n    # Send email\n\n# ‚úó Bad - Too many responsibilities\ndef process_user_registration(email, password, name):\n    # Validate email\n    # Validate password\n    # Hash password\n    # Save to database\n    # Send confirmation email\n    # Log activity\n    pass  # Too much!\n\n# 5. Use meaningful names\n# ‚úì Good\nuser_age = 25\ntotal_price = calculate_total(items)\nis_valid = validate_input(data)\n\n# ‚úó Bad\nx = 25\ntmp = calc(items)\nflag = check(data)\n\n# 6. Don't repeat yourself (DRY)\n# ‚úó Bad\ndef calculate_area_rectangle(width, height):\n    return width * height\n\ndef calculate_area_square(side):\n    return side * side\n\n# ‚úì Good\ndef calculate_area(width, height=None):\n    if height is None:\n        height = width\n    return width * height\n\n# 7. Handle errors properly\n# ‚úì Good\ndef read_file(filename):\n    try:\n        with open(filename, 'r') as f:\n            return f.read()\n    except FileNotFoundError:\n        logger.error(f\"File not found: {filename}\")\n        raise\n    except Exception as e:\n        logger.error(f\"Error reading {filename}: {e}\")\n        raise\n\n# ‚úó Bad\ndef read_file(filename):\n    try:\n        with open(filename, 'r') as f:\n            return f.read()\n    except:\n        pass  # Silent failure!",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#continuous-integration",
    "href": "chapter-20-testing-quality.html#continuous-integration",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.10 20.9 Continuous Integration",
    "text": "21.10 20.9 Continuous Integration\n\n21.10.1 CI/CD Setup\n# GitHub Actions example\n# .github/workflows/tests.yml\n\"\"\"\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.9\n    \n    - name: Install dependencies\n      run: |\n        pip install -r requirements.txt\n        pip install pytest coverage\n    \n    - name: Run tests\n      run: |\n        pytest\n    \n    - name: Check coverage\n      run: |\n        coverage run -m pytest\n        coverage report --fail-under=80\n    \n    - name: Lint\n      run: |\n        pip install flake8\n        flake8 .\n\"\"\"\n\n# pre-commit hooks\n# .pre-commit-config.yaml\n\"\"\"\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 23.1.0\n    hooks:\n      - id: black\n  \n  - repo: https://github.com/pycqa/flake8\n    rev: 6.0.0\n    hooks:\n      - id: flake8\n  \n  - repo: https://github.com/pycqa/isort\n    rev: 5.12.0\n    hooks:\n      - id: isort\n\"\"\"",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#final-checklist",
    "href": "chapter-20-testing-quality.html#final-checklist",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.11 20.10 Final Checklist",
    "text": "21.11 20.10 Final Checklist\n\n21.11.1 Code Quality Checklist\n\"\"\"\nBefore committing code:\n\n‚úì Tests pass\n  - All unit tests pass\n  - Coverage &gt; 80%\n  - Edge cases covered\n\n‚úì Code quality\n  - No linter warnings\n  - Code formatted (black)\n  - Imports sorted (isort)\n  - Type hints added\n\n‚úì Documentation\n  - Docstrings added\n  - README updated\n  - CHANGELOG updated\n\n‚úì Best practices\n  - No duplicate code\n  - Functions &lt; 20 lines\n  - No magic numbers\n  - Error handling\n\n‚úì Review\n  - Self-review changes\n  - Test locally\n  - Check CI passes\n\"\"\"",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#key-takeaways",
    "href": "chapter-20-testing-quality.html#key-takeaways",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.12 20.11 Key Takeaways",
    "text": "21.12 20.11 Key Takeaways\n\n21.12.1 What You Learned\n\nWrite tests first - TDD approach\nTest edge cases - Not just happy path\nAim for high coverage - 80%+ is good\nUse quality tools - Linters, formatters\nFollow PEP 8 - Consistent style\nWrite docstrings - Document your code\nKeep it simple - KISS principle\n\n\n\n21.12.2 Quality Pyramid\n         /\\\n        /CI\\\n       /----\\\n      /Tests \\\n     /--------\\\n    /  Linting \\\n   /------------\\\n  / Code Reviews \\\n /----------------\\",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#congratulations",
    "href": "chapter-20-testing-quality.html#congratulations",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.13 20.12 Congratulations! üéâ",
    "text": "21.13 20.12 Congratulations! üéâ\n\n21.13.1 You‚Äôve Completed the Python Error Guide!\nYou‚Äôve mastered all 20 chapters:\nPart I: Fundamentals - Variables, Operators, Strings - Lists, Dictionaries, Sets, Tuples - Conditionals, Loops, Functions, Files\nPart II: Libraries - Regular Expressions - Pandas, NumPy, Matplotlib\nPart III: Advanced - OOP, Modules, Exceptions - Debugging, Testing, Quality",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#next-steps",
    "href": "chapter-20-testing-quality.html#next-steps",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.14 20.13 Next Steps",
    "text": "21.14 20.13 Next Steps\n\n21.14.1 Continue Your Python Journey\n\nPractice regularly\n\nCode every day\nBuild projects\nContribute to open source\n\nRead quality code\n\nStudy Python standard library\nRead popular projects\nLearn from experts\n\nStay updated\n\nFollow Python PEPs\nRead blogs and articles\nJoin Python communities\n\nSpecialize\n\nWeb (Django, Flask)\nData Science (Pandas, scikit-learn)\nDevOps (automation)\nML/AI (TensorFlow, PyTorch)\n\nTeach others\n\nWrite blog posts\nAnswer questions\nMentor beginners",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#resources",
    "href": "chapter-20-testing-quality.html#resources",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.15 20.14 Resources",
    "text": "21.15 20.14 Resources\n\n21.15.1 Recommended Learning\nBooks: - ‚ÄúFluent Python‚Äù by Luciano Ramalho - ‚ÄúEffective Python‚Äù by Brett Slatkin - ‚ÄúPython Tricks‚Äù by Dan Bader\nWebsites: - Real Python (realpython.com) - Python Docs (docs.python.org) - PEP 8 Style Guide\nPractice: - LeetCode - HackerRank - Project Euler\nCommunities: - r/Python - Python Discord - Stack Overflow",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  },
  {
    "objectID": "chapter-20-testing-quality.html#thank-you",
    "href": "chapter-20-testing-quality.html#thank-you",
    "title": "21¬† Chapter 20: Testing and Code Quality - Writing Better Code",
    "section": "21.16 üéä Thank You!",
    "text": "21.16 üéä Thank You!\nYou‚Äôve completed this comprehensive guide to Python errors and best practices. You now have the knowledge to:\n\n‚úÖ Understand and fix Python errors\n‚úÖ Write clean, maintainable code\n‚úÖ Test your code properly\n‚úÖ Debug effectively\n‚úÖ Follow best practices\n\nKeep coding, keep learning, and keep growing! üêçüíô\n\nEnd of Python Error Guide Thank you for learning with us!",
    "crumbs": [
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Chapter 20: Testing and Code Quality - Writing Better Code</span>"
    ]
  }
]